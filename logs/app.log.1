[2017-05-04 12:21:58.280] [ERROR] app - Redis client default error happens { '0': 
   { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
       at Object.exports._errnoException (util.js:1050:11)
       at exports._exceptionWithHostPort (util.js:1073:20)
       at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
     code: 'ECONNREFUSED',
     errno: 'ECONNREFUSED',
     syscall: 'connect',
     address: '127.0.0.1',
     port: 6379 } }
[2017-05-04 12:21:58.296] [INFO] app - Redis client default is ended {}
[2017-05-04 12:21:58.309] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 12:21:58.504] [WARN] app - Redis client default is reconnecting to redis://127.0.0.1:6379 { '0': 
   { delay: 200,
     attempt: 1,
     error: 
      { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
          at Object.exports._errnoException (util.js:1050:11)
          at exports._exceptionWithHostPort (util.js:1073:20)
          at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
        code: 'ECONNREFUSED',
        errno: 'ECONNREFUSED',
        syscall: 'connect',
        address: '127.0.0.1',
        port: 6379 },
     total_retry_time: 0,
     times_connected: 0 } }
[2017-05-04 12:21:58.509] [ERROR] app - Redis client default error happens { '0': 
   { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
       at Object.exports._errnoException (util.js:1050:11)
       at exports._exceptionWithHostPort (util.js:1073:20)
       at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
     code: 'ECONNREFUSED',
     errno: 'ECONNREFUSED',
     syscall: 'connect',
     address: '127.0.0.1',
     port: 6379 } }
[2017-05-04 12:21:58.853] [WARN] app - Redis client default is reconnecting to redis://127.0.0.1:6379 { '0': 
   { delay: 340,
     attempt: 2,
     error: 
      { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
          at Object.exports._errnoException (util.js:1050:11)
          at exports._exceptionWithHostPort (util.js:1073:20)
          at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
        code: 'ECONNREFUSED',
        errno: 'ECONNREFUSED',
        syscall: 'connect',
        address: '127.0.0.1',
        port: 6379 },
     total_retry_time: 200,
     times_connected: 0 } }
[2017-05-04 12:21:58.856] [ERROR] app - Redis client default error happens { '0': 
   { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
       at Object.exports._errnoException (util.js:1050:11)
       at exports._exceptionWithHostPort (util.js:1073:20)
       at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
     code: 'ECONNREFUSED',
     errno: 'ECONNREFUSED',
     syscall: 'connect',
     address: '127.0.0.1',
     port: 6379 } }
[2017-05-04 12:21:59.437] [WARN] app - Redis client default is reconnecting to redis://127.0.0.1:6379 { '0': 
   { delay: 578,
     attempt: 3,
     error: 
      { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
          at Object.exports._errnoException (util.js:1050:11)
          at exports._exceptionWithHostPort (util.js:1073:20)
          at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
        code: 'ECONNREFUSED',
        errno: 'ECONNREFUSED',
        syscall: 'connect',
        address: '127.0.0.1',
        port: 6379 },
     total_retry_time: 540,
     times_connected: 0 } }
[2017-05-04 12:21:59.441] [ERROR] app - Redis client default error happens { '0': 
   { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
       at Object.exports._errnoException (util.js:1050:11)
       at exports._exceptionWithHostPort (util.js:1073:20)
       at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
     code: 'ECONNREFUSED',
     errno: 'ECONNREFUSED',
     syscall: 'connect',
     address: '127.0.0.1',
     port: 6379 } }
[2017-05-04 12:22:00.430] [WARN] app - Redis client default is reconnecting to redis://127.0.0.1:6379 { '0': 
   { delay: 983,
     attempt: 4,
     error: 
      { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
          at Object.exports._errnoException (util.js:1050:11)
          at exports._exceptionWithHostPort (util.js:1073:20)
          at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
        code: 'ECONNREFUSED',
        errno: 'ECONNREFUSED',
        syscall: 'connect',
        address: '127.0.0.1',
        port: 6379 },
     total_retry_time: 1118,
     times_connected: 0 } }
[2017-05-04 12:22:00.433] [ERROR] app - Redis client default error happens { '0': 
   { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
       at Object.exports._errnoException (util.js:1050:11)
       at exports._exceptionWithHostPort (util.js:1073:20)
       at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
     code: 'ECONNREFUSED',
     errno: 'ECONNREFUSED',
     syscall: 'connect',
     address: '127.0.0.1',
     port: 6379 } }
[2017-05-04 12:22:02.109] [WARN] app - Redis client default is reconnecting to redis://127.0.0.1:6379 { '0': 
   { delay: 1671,
     attempt: 5,
     error: 
      { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
          at Object.exports._errnoException (util.js:1050:11)
          at exports._exceptionWithHostPort (util.js:1073:20)
          at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
        code: 'ECONNREFUSED',
        errno: 'ECONNREFUSED',
        syscall: 'connect',
        address: '127.0.0.1',
        port: 6379 },
     total_retry_time: 2101,
     times_connected: 0 } }
[2017-05-04 12:22:02.112] [ERROR] app - Redis client default error happens { '0': 
   { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
       at Object.exports._errnoException (util.js:1050:11)
       at exports._exceptionWithHostPort (util.js:1073:20)
       at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
     code: 'ECONNREFUSED',
     errno: 'ECONNREFUSED',
     syscall: 'connect',
     address: '127.0.0.1',
     port: 6379 } }
[2017-05-04 12:22:04.649] [ERROR] app - Redis client default error happens { '0': 
   { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
       at Object.exports._errnoException (util.js:1050:11)
       at exports._exceptionWithHostPort (util.js:1073:20)
       at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
     code: 'ECONNREFUSED',
     errno: 'ECONNREFUSED',
     syscall: 'connect',
     address: '127.0.0.1',
     port: 6379 } }
[2017-05-04 12:22:04.658] [INFO] app - Redis client default is ended {}
[2017-05-04 12:22:04.665] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 12:22:04.864] [WARN] app - Redis client default is reconnecting to redis://127.0.0.1:6379 { '0': 
   { delay: 200,
     attempt: 1,
     error: 
      { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
          at Object.exports._errnoException (util.js:1050:11)
          at exports._exceptionWithHostPort (util.js:1073:20)
          at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
        code: 'ECONNREFUSED',
        errno: 'ECONNREFUSED',
        syscall: 'connect',
        address: '127.0.0.1',
        port: 6379 },
     total_retry_time: 0,
     times_connected: 0 } }
[2017-05-04 12:22:04.867] [ERROR] app - Redis client default error happens { '0': 
   { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
       at Object.exports._errnoException (util.js:1050:11)
       at exports._exceptionWithHostPort (util.js:1073:20)
       at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
     code: 'ECONNREFUSED',
     errno: 'ECONNREFUSED',
     syscall: 'connect',
     address: '127.0.0.1',
     port: 6379 } }
[2017-05-04 12:22:05.208] [WARN] app - Redis client default is reconnecting to redis://127.0.0.1:6379 { '0': 
   { delay: 340,
     attempt: 2,
     error: 
      { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
          at Object.exports._errnoException (util.js:1050:11)
          at exports._exceptionWithHostPort (util.js:1073:20)
          at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
        code: 'ECONNREFUSED',
        errno: 'ECONNREFUSED',
        syscall: 'connect',
        address: '127.0.0.1',
        port: 6379 },
     total_retry_time: 200,
     times_connected: 0 } }
[2017-05-04 12:22:05.210] [ERROR] app - Redis client default error happens { '0': 
   { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
       at Object.exports._errnoException (util.js:1050:11)
       at exports._exceptionWithHostPort (util.js:1073:20)
       at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
     code: 'ECONNREFUSED',
     errno: 'ECONNREFUSED',
     syscall: 'connect',
     address: '127.0.0.1',
     port: 6379 } }
[2017-05-04 12:22:05.795] [WARN] app - Redis client default is reconnecting to redis://127.0.0.1:6379 { '0': 
   { delay: 578,
     attempt: 3,
     error: 
      { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
          at Object.exports._errnoException (util.js:1050:11)
          at exports._exceptionWithHostPort (util.js:1073:20)
          at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
        code: 'ECONNREFUSED',
        errno: 'ECONNREFUSED',
        syscall: 'connect',
        address: '127.0.0.1',
        port: 6379 },
     total_retry_time: 540,
     times_connected: 0 } }
[2017-05-04 12:22:05.798] [ERROR] app - Redis client default error happens { '0': 
   { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
       at Object.exports._errnoException (util.js:1050:11)
       at exports._exceptionWithHostPort (util.js:1073:20)
       at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
     code: 'ECONNREFUSED',
     errno: 'ECONNREFUSED',
     syscall: 'connect',
     address: '127.0.0.1',
     port: 6379 } }
[2017-05-04 12:22:06.786] [WARN] app - Redis client default is reconnecting to redis://127.0.0.1:6379 { '0': 
   { delay: 983,
     attempt: 4,
     error: 
      { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
          at Object.exports._errnoException (util.js:1050:11)
          at exports._exceptionWithHostPort (util.js:1073:20)
          at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
        code: 'ECONNREFUSED',
        errno: 'ECONNREFUSED',
        syscall: 'connect',
        address: '127.0.0.1',
        port: 6379 },
     total_retry_time: 1118,
     times_connected: 0 } }
[2017-05-04 12:22:06.788] [ERROR] app - Redis client default error happens { '0': 
   { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
       at Object.exports._errnoException (util.js:1050:11)
       at exports._exceptionWithHostPort (util.js:1073:20)
       at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
     code: 'ECONNREFUSED',
     errno: 'ECONNREFUSED',
     syscall: 'connect',
     address: '127.0.0.1',
     port: 6379 } }
[2017-05-04 12:22:08.463] [WARN] app - Redis client default is reconnecting to redis://127.0.0.1:6379 { '0': 
   { delay: 1671,
     attempt: 5,
     error: 
      { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
          at Object.exports._errnoException (util.js:1050:11)
          at exports._exceptionWithHostPort (util.js:1073:20)
          at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
        code: 'ECONNREFUSED',
        errno: 'ECONNREFUSED',
        syscall: 'connect',
        address: '127.0.0.1',
        port: 6379 },
     total_retry_time: 2101,
     times_connected: 0 } }
[2017-05-04 12:22:08.466] [ERROR] app - Redis client default error happens { '0': 
   { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
       at Object.exports._errnoException (util.js:1050:11)
       at exports._exceptionWithHostPort (util.js:1073:20)
       at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
     code: 'ECONNREFUSED',
     errno: 'ECONNREFUSED',
     syscall: 'connect',
     address: '127.0.0.1',
     port: 6379 } }
[2017-05-04 12:22:11.311] [WARN] app - Redis client default is reconnecting to redis://127.0.0.1:6379 { '0': 
   { delay: 2841,
     attempt: 6,
     error: 
      { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
          at Object.exports._errnoException (util.js:1050:11)
          at exports._exceptionWithHostPort (util.js:1073:20)
          at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
        code: 'ECONNREFUSED',
        errno: 'ECONNREFUSED',
        syscall: 'connect',
        address: '127.0.0.1',
        port: 6379 },
     total_retry_time: 3772,
     times_connected: 0 } }
[2017-05-04 12:22:11.313] [ERROR] app - Redis client default error happens { '0': 
   { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
       at Object.exports._errnoException (util.js:1050:11)
       at exports._exceptionWithHostPort (util.js:1073:20)
       at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
     code: 'ECONNREFUSED',
     errno: 'ECONNREFUSED',
     syscall: 'connect',
     address: '127.0.0.1',
     port: 6379 } }
[2017-05-04 12:22:16.148] [WARN] app - Redis client default is reconnecting to redis://127.0.0.1:6379 { '0': 
   { delay: 4830,
     attempt: 7,
     error: 
      { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
          at Object.exports._errnoException (util.js:1050:11)
          at exports._exceptionWithHostPort (util.js:1073:20)
          at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
        code: 'ECONNREFUSED',
        errno: 'ECONNREFUSED',
        syscall: 'connect',
        address: '127.0.0.1',
        port: 6379 },
     total_retry_time: 6613,
     times_connected: 0 } }
[2017-05-04 12:22:16.150] [ERROR] app - Redis client default error happens { '0': 
   { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
       at Object.exports._errnoException (util.js:1050:11)
       at exports._exceptionWithHostPort (util.js:1073:20)
       at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
     code: 'ECONNREFUSED',
     errno: 'ECONNREFUSED',
     syscall: 'connect',
     address: '127.0.0.1',
     port: 6379 } }
[2017-05-04 12:22:24.365] [WARN] app - Redis client default is reconnecting to redis://127.0.0.1:6379 { '0': 
   { delay: 8211,
     attempt: 8,
     error: 
      { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
          at Object.exports._errnoException (util.js:1050:11)
          at exports._exceptionWithHostPort (util.js:1073:20)
          at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
        code: 'ECONNREFUSED',
        errno: 'ECONNREFUSED',
        syscall: 'connect',
        address: '127.0.0.1',
        port: 6379 },
     total_retry_time: 11443,
     times_connected: 0 } }
[2017-05-04 12:22:24.369] [ERROR] app - Redis client default error happens { '0': 
   { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
       at Object.exports._errnoException (util.js:1050:11)
       at exports._exceptionWithHostPort (util.js:1073:20)
       at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
     code: 'ECONNREFUSED',
     errno: 'ECONNREFUSED',
     syscall: 'connect',
     address: '127.0.0.1',
     port: 6379 } }
[2017-05-04 12:22:38.330] [WARN] app - Redis client default is reconnecting to redis://127.0.0.1:6379 { '0': 
   { delay: 13959,
     attempt: 9,
     error: 
      { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
          at Object.exports._errnoException (util.js:1050:11)
          at exports._exceptionWithHostPort (util.js:1073:20)
          at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
        code: 'ECONNREFUSED',
        errno: 'ECONNREFUSED',
        syscall: 'connect',
        address: '127.0.0.1',
        port: 6379 },
     total_retry_time: 19654,
     times_connected: 0 } }
[2017-05-04 12:22:38.333] [ERROR] app - Redis client default error happens { '0': 
   { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
       at Object.exports._errnoException (util.js:1050:11)
       at exports._exceptionWithHostPort (util.js:1073:20)
       at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
     code: 'ECONNREFUSED',
     errno: 'ECONNREFUSED',
     syscall: 'connect',
     address: '127.0.0.1',
     port: 6379 } }
[2017-05-04 12:23:02.068] [WARN] app - Redis client default is reconnecting to redis://127.0.0.1:6379 { '0': 
   { delay: 23730,
     attempt: 10,
     error: 
      { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
          at Object.exports._errnoException (util.js:1050:11)
          at exports._exceptionWithHostPort (util.js:1073:20)
          at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
        code: 'ECONNREFUSED',
        errno: 'ECONNREFUSED',
        syscall: 'connect',
        address: '127.0.0.1',
        port: 6379 },
     total_retry_time: 33613,
     times_connected: 0 } }
[2017-05-04 12:32:45.496] [ERROR] app - Redis client default error happens { '0': 
   { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
       at Object.exports._errnoException (util.js:1050:11)
       at exports._exceptionWithHostPort (util.js:1073:20)
       at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
     code: 'ECONNREFUSED',
     errno: 'ECONNREFUSED',
     syscall: 'connect',
     address: '127.0.0.1',
     port: 6379 } }
[2017-05-04 12:32:45.505] [INFO] app - Redis client default is ended {}
[2017-05-04 12:32:45.513] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 12:32:45.709] [WARN] app - Redis client default is reconnecting to redis://127.0.0.1:6379 { '0': 
   { delay: 200,
     attempt: 1,
     error: 
      { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
          at Object.exports._errnoException (util.js:1050:11)
          at exports._exceptionWithHostPort (util.js:1073:20)
          at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
        code: 'ECONNREFUSED',
        errno: 'ECONNREFUSED',
        syscall: 'connect',
        address: '127.0.0.1',
        port: 6379 },
     total_retry_time: 0,
     times_connected: 0 } }
[2017-05-04 12:32:45.713] [ERROR] app - Redis client default error happens { '0': 
   { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
       at Object.exports._errnoException (util.js:1050:11)
       at exports._exceptionWithHostPort (util.js:1073:20)
       at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
     code: 'ECONNREFUSED',
     errno: 'ECONNREFUSED',
     syscall: 'connect',
     address: '127.0.0.1',
     port: 6379 } }
[2017-05-04 12:32:46.055] [WARN] app - Redis client default is reconnecting to redis://127.0.0.1:6379 { '0': 
   { delay: 340,
     attempt: 2,
     error: 
      { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
          at Object.exports._errnoException (util.js:1050:11)
          at exports._exceptionWithHostPort (util.js:1073:20)
          at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
        code: 'ECONNREFUSED',
        errno: 'ECONNREFUSED',
        syscall: 'connect',
        address: '127.0.0.1',
        port: 6379 },
     total_retry_time: 200,
     times_connected: 0 } }
[2017-05-04 12:32:46.059] [ERROR] app - Redis client default error happens { '0': 
   { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
       at Object.exports._errnoException (util.js:1050:11)
       at exports._exceptionWithHostPort (util.js:1073:20)
       at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
     code: 'ECONNREFUSED',
     errno: 'ECONNREFUSED',
     syscall: 'connect',
     address: '127.0.0.1',
     port: 6379 } }
[2017-05-04 12:32:46.641] [WARN] app - Redis client default is reconnecting to redis://127.0.0.1:6379 { '0': 
   { delay: 578,
     attempt: 3,
     error: 
      { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
          at Object.exports._errnoException (util.js:1050:11)
          at exports._exceptionWithHostPort (util.js:1073:20)
          at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
        code: 'ECONNREFUSED',
        errno: 'ECONNREFUSED',
        syscall: 'connect',
        address: '127.0.0.1',
        port: 6379 },
     total_retry_time: 540,
     times_connected: 0 } }
[2017-05-04 12:32:46.646] [ERROR] app - Redis client default error happens { '0': 
   { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
       at Object.exports._errnoException (util.js:1050:11)
       at exports._exceptionWithHostPort (util.js:1073:20)
       at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
     code: 'ECONNREFUSED',
     errno: 'ECONNREFUSED',
     syscall: 'connect',
     address: '127.0.0.1',
     port: 6379 } }
[2017-05-04 12:32:47.631] [WARN] app - Redis client default is reconnecting to redis://127.0.0.1:6379 { '0': 
   { delay: 983,
     attempt: 4,
     error: 
      { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
          at Object.exports._errnoException (util.js:1050:11)
          at exports._exceptionWithHostPort (util.js:1073:20)
          at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
        code: 'ECONNREFUSED',
        errno: 'ECONNREFUSED',
        syscall: 'connect',
        address: '127.0.0.1',
        port: 6379 },
     total_retry_time: 1118,
     times_connected: 0 } }
[2017-05-04 12:32:47.634] [ERROR] app - Redis client default error happens { '0': 
   { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
       at Object.exports._errnoException (util.js:1050:11)
       at exports._exceptionWithHostPort (util.js:1073:20)
       at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
     code: 'ECONNREFUSED',
     errno: 'ECONNREFUSED',
     syscall: 'connect',
     address: '127.0.0.1',
     port: 6379 } }
[2017-05-04 12:32:49.309] [WARN] app - Redis client default is reconnecting to redis://127.0.0.1:6379 { '0': 
   { delay: 1671,
     attempt: 5,
     error: 
      { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
          at Object.exports._errnoException (util.js:1050:11)
          at exports._exceptionWithHostPort (util.js:1073:20)
          at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
        code: 'ECONNREFUSED',
        errno: 'ECONNREFUSED',
        syscall: 'connect',
        address: '127.0.0.1',
        port: 6379 },
     total_retry_time: 2101,
     times_connected: 0 } }
[2017-05-04 12:32:49.312] [ERROR] app - Redis client default error happens { '0': 
   { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
       at Object.exports._errnoException (util.js:1050:11)
       at exports._exceptionWithHostPort (util.js:1073:20)
       at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
     code: 'ECONNREFUSED',
     errno: 'ECONNREFUSED',
     syscall: 'connect',
     address: '127.0.0.1',
     port: 6379 } }
[2017-05-04 12:32:52.157] [WARN] app - Redis client default is reconnecting to redis://127.0.0.1:6379 { '0': 
   { delay: 2841,
     attempt: 6,
     error: 
      { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
          at Object.exports._errnoException (util.js:1050:11)
          at exports._exceptionWithHostPort (util.js:1073:20)
          at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
        code: 'ECONNREFUSED',
        errno: 'ECONNREFUSED',
        syscall: 'connect',
        address: '127.0.0.1',
        port: 6379 },
     total_retry_time: 3772,
     times_connected: 0 } }
[2017-05-04 12:32:52.158] [ERROR] app - Redis client default error happens { '0': 
   { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
       at Object.exports._errnoException (util.js:1050:11)
       at exports._exceptionWithHostPort (util.js:1073:20)
       at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
     code: 'ECONNREFUSED',
     errno: 'ECONNREFUSED',
     syscall: 'connect',
     address: '127.0.0.1',
     port: 6379 } }
[2017-05-04 12:32:56.992] [WARN] app - Redis client default is reconnecting to redis://127.0.0.1:6379 { '0': 
   { delay: 4830,
     attempt: 7,
     error: 
      { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
          at Object.exports._errnoException (util.js:1050:11)
          at exports._exceptionWithHostPort (util.js:1073:20)
          at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
        code: 'ECONNREFUSED',
        errno: 'ECONNREFUSED',
        syscall: 'connect',
        address: '127.0.0.1',
        port: 6379 },
     total_retry_time: 6613,
     times_connected: 0 } }
[2017-05-04 12:32:56.995] [ERROR] app - Redis client default error happens { '0': 
   { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
       at Object.exports._errnoException (util.js:1050:11)
       at exports._exceptionWithHostPort (util.js:1073:20)
       at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
     code: 'ECONNREFUSED',
     errno: 'ECONNREFUSED',
     syscall: 'connect',
     address: '127.0.0.1',
     port: 6379 } }
[2017-05-04 12:33:05.210] [WARN] app - Redis client default is reconnecting to redis://127.0.0.1:6379 { '0': 
   { delay: 8211,
     attempt: 8,
     error: 
      { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
          at Object.exports._errnoException (util.js:1050:11)
          at exports._exceptionWithHostPort (util.js:1073:20)
          at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
        code: 'ECONNREFUSED',
        errno: 'ECONNREFUSED',
        syscall: 'connect',
        address: '127.0.0.1',
        port: 6379 },
     total_retry_time: 11443,
     times_connected: 0 } }
[2017-05-04 12:33:05.213] [ERROR] app - Redis client default error happens { '0': 
   { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
       at Object.exports._errnoException (util.js:1050:11)
       at exports._exceptionWithHostPort (util.js:1073:20)
       at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
     code: 'ECONNREFUSED',
     errno: 'ECONNREFUSED',
     syscall: 'connect',
     address: '127.0.0.1',
     port: 6379 } }
[2017-05-04 12:33:19.177] [WARN] app - Redis client default is reconnecting to redis://127.0.0.1:6379 { '0': 
   { delay: 13959,
     attempt: 9,
     error: 
      { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
          at Object.exports._errnoException (util.js:1050:11)
          at exports._exceptionWithHostPort (util.js:1073:20)
          at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
        code: 'ECONNREFUSED',
        errno: 'ECONNREFUSED',
        syscall: 'connect',
        address: '127.0.0.1',
        port: 6379 },
     total_retry_time: 19654,
     times_connected: 0 } }
[2017-05-04 12:33:19.180] [ERROR] app - Redis client default error happens { '0': 
   { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
       at Object.exports._errnoException (util.js:1050:11)
       at exports._exceptionWithHostPort (util.js:1073:20)
       at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
     code: 'ECONNREFUSED',
     errno: 'ECONNREFUSED',
     syscall: 'connect',
     address: '127.0.0.1',
     port: 6379 } }
[2017-05-04 12:33:42.915] [WARN] app - Redis client default is reconnecting to redis://127.0.0.1:6379 { '0': 
   { delay: 23730,
     attempt: 10,
     error: 
      { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
          at Object.exports._errnoException (util.js:1050:11)
          at exports._exceptionWithHostPort (util.js:1073:20)
          at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
        code: 'ECONNREFUSED',
        errno: 'ECONNREFUSED',
        syscall: 'connect',
        address: '127.0.0.1',
        port: 6379 },
     total_retry_time: 33613,
     times_connected: 0 } }
[2017-05-04 12:33:42.921] [ERROR] app - Redis client default error happens { '0': 
   { Error: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379
       at Object.exports._errnoException (util.js:1050:11)
       at exports._exceptionWithHostPort (util.js:1073:20)
       at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1097:14)
     code: 'ECONNREFUSED',
     errno: 'ECONNREFUSED',
     syscall: 'connect',
     address: '127.0.0.1',
     port: 6379 } }
[2017-05-04 12:42:48.972] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 12:42:48.992] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 12:42:48.995] [INFO] app - Redis client default is ready {}
[2017-05-04 12:42:49.099] [WARN] console - application is startup, listening on port 3000
[2017-05-04 12:43:00.272] [WARN] console - in api ...............
[2017-05-04 12:43:00.284] [ERROR] console - (node:95941) DeprecationWarning: Mongoose: mpromise (mongoose's default promise library) is deprecated, plug in your own promise library instead: http://mongoosejs.com/docs/promises.html
[2017-05-04 12:43:00.290] [WARN] console - [ { _id: 5902b753c5756d72945d90b3,
    updatedAt: 2017-04-28T03:30:27.167Z,
    createdAt: 2017-04-28T03:30:27.167Z,
    username: '222',
    __v: 0 },
  { _id: 590467fb9bb491da74caee32,
    updatedAt: 2017-04-29T10:16:27.758Z,
    createdAt: 2017-04-29T10:16:27.758Z,
    username: 'user0.38955004828614115',
    __v: 0 },
  { _id: 5904689fb4b502db0a450395,
    updatedAt: 2017-04-29T10:19:11.350Z,
    createdAt: 2017-04-29T10:19:11.350Z,
    username: 'user0.9823151939002306',
    __v: 0 } ]
[2017-05-04 12:43:40.085] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 12:43:40.099] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 12:43:40.102] [INFO] app - Redis client default is ready {}
[2017-05-04 12:43:40.188] [WARN] console - application is startup, listening on port 3000
[2017-05-04 13:02:34.667] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:02:34.685] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:02:34.688] [INFO] app - Redis client default is ready {}
[2017-05-04 13:02:34.780] [WARN] console - application is startup, listening on port 3000
[2017-05-04 13:03:57.451] [WARN] console - in api ...............
[2017-05-04 13:03:57.464] [ERROR] console - (node:96172) DeprecationWarning: Mongoose: mpromise (mongoose's default promise library) is deprecated, plug in your own promise library instead: http://mongoosejs.com/docs/promises.html
[2017-05-04 13:03:57.472] [WARN] console - [ { _id: 5902b753c5756d72945d90b3,
    updatedAt: 2017-04-28T03:30:27.167Z,
    createdAt: 2017-04-28T03:30:27.167Z,
    username: '222',
    __v: 0 },
  { _id: 590467fb9bb491da74caee32,
    updatedAt: 2017-04-29T10:16:27.758Z,
    createdAt: 2017-04-29T10:16:27.758Z,
    username: 'user0.38955004828614115',
    __v: 0 },
  { _id: 5904689fb4b502db0a450395,
    updatedAt: 2017-04-29T10:19:11.350Z,
    createdAt: 2017-04-29T10:19:11.350Z,
    username: 'user0.9823151939002306',
    __v: 0 } ]
[2017-05-04 13:05:36.001] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:05:36.014] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:05:36.017] [INFO] app - Redis client default is ready {}
[2017-05-04 13:05:36.132] [WARN] console - application is startup, listening on port 3000
[2017-05-04 13:05:38.372] [WARN] console - in api ...............
[2017-05-04 13:05:38.375] [ERROR] console - TypeError: Cannot read property 'main' of undefined
    at UserService._callee3$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:19:18)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:437
    at UserService.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:99)
    at UserService.find (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:99:22)
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:5:54)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:437
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:99
    at getUser (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:55:21)
[2017-05-04 13:06:16.499] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:06:16.516] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:06:16.586] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:06:16.604] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:06:16.530] [INFO] app - Redis client default is ready {}
[2017-05-04 13:06:16.653] [WARN] console - application is startup, listening on port 3000
[2017-05-04 13:06:21.418] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:06:21.429] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:06:21.432] [INFO] app - Redis client default is ready {}
[2017-05-04 13:06:21.494] [WARN] console - application is startup, listening on port 3000
[2017-05-04 13:06:22.499] [WARN] console - in api ...............
[2017-05-04 13:06:22.500] [WARN] console - RedisClient {
  domain: null,
  _events: 
   { newListener: [Function],
     connect: [Function],
     ready: [Function],
     reconnecting: [Function],
     error: [ [Function], [Function: errorHandler] ],
     end: [Function] },
  _eventsCount: 6,
  _maxListeners: undefined,
  address: '127.0.0.1:6379',
  connection_options: { port: 6379, host: '127.0.0.1', family: 4 },
  connection_id: 0,
  connected: true,
  ready: true,
  should_buffer: false,
  max_attempts: 0,
  command_queue: { [String: ''] '0': undefined, _capacity: 16, _length: 0, _front: 1 },
  offline_queue: { [String: ''] _capacity: 16, _length: 0, _front: 0 },
  pipeline_queue: { [String: ''] _capacity: 16, _length: 0, _front: 0 },
  connect_timeout: 3600000,
  enable_offline_queue: true,
  retry_max_delay: null,
  retry_timer: null,
  retry_totaltime: 0,
  retry_delay: 200,
  retry_backoff: 1.7,
  attempts: 1,
  pub_sub_mode: 0,
  subscription_set: {},
  monitoring: false,
  message_buffers: false,
  closing: false,
  server_info: 
   { redis_version: '3.2.8',
     redis_git_sha1: '00000000',
     redis_git_dirty: '0',
     redis_build_id: 'ae7e7d2604b97c53',
     redis_mode: 'standalone',
     os: 'Darwin 15.0.0 x86_64',
     arch_bits: '64',
     multiplexing_api: 'kqueue',
     gcc_version: '4.2.1',
     process_id: '96159',
     run_id: 'ebe29182b7fe6e47163ac97dca7db95076a825ff',
     tcp_port: '6379',
     uptime_in_seconds: '234',
     uptime_in_days: '0',
     hz: '10',
     lru_clock: '702157',
     executable: '/usr/local/redis/./bin/redis-server',
     config_file: '/usr/local/redis/./etc/redis.conf',
     connected_clients: '1',
     client_longest_output_list: '0',
     client_biggest_input_buf: '0',
     blocked_clients: '0',
     used_memory: '1008608',
     used_memory_human: '984.97K',
     used_memory_rss: '2060288',
     used_memory_rss_human: '1.96M',
     used_memory_peak: '1059168',
     used_memory_peak_human: '1.01M',
     total_system_memory: '8589934592',
     total_system_memory_human: '8.00G',
     used_memory_lua: '37888',
     used_memory_lua_human: '37.00K',
     maxmemory: '0',
     maxmemory_human: '0B',
     maxmemory_policy: 'noeviction',
     mem_fragmentation_ratio: '2.04',
     mem_allocator: 'libc',
     loading: '0',
     rdb_changes_since_last_save: '0',
     rdb_bgsave_in_progress: '0',
     rdb_last_save_time: '1493874147',
     rdb_last_bgsave_status: 'ok',
     rdb_last_bgsave_time_sec: '-1',
     rdb_current_bgsave_time_sec: '-1',
     aof_enabled: '0',
     aof_rewrite_in_progress: '0',
     aof_rewrite_scheduled: '0',
     aof_last_rewrite_time_sec: '-1',
     aof_current_rewrite_time_sec: '-1',
     aof_last_bgrewrite_status: 'ok',
     aof_last_write_status: 'ok',
     total_connections_received: '5',
     total_commands_processed: '4',
     instantaneous_ops_per_sec: '0',
     total_net_input_bytes: '70',
     total_net_output_bytes: '8567',
     instantaneous_input_kbps: '0.00',
     instantaneous_output_kbps: '0.00',
     rejected_connections: '0',
     sync_full: '0',
     sync_partial_ok: '0',
     sync_partial_err: '0',
     expired_keys: '0',
     evicted_keys: '0',
     keyspace_hits: '0',
     keyspace_misses: '0',
     pubsub_channels: '0',
     pubsub_patterns: '0',
     latest_fork_usec: '0',
     migrate_cached_sockets: '0',
     role: 'master',
     connected_slaves: '0',
     master_repl_offset: '0',
     repl_backlog_active: '0',
     repl_backlog_size: '1048576',
     repl_backlog_first_byte_offset: '0',
     repl_backlog_histlen: '0',
     used_cpu_sys: '0.09',
     used_cpu_user: '0.05',
     used_cpu_sys_children: '0.00',
     used_cpu_user_children: '0.00',
     cluster_enabled: '0',
     versions: [ 3, 2, 8 ] },
  auth_pass: undefined,
  selected_db: undefined,
  old_state: null,
  fire_strings: true,
  pipeline: false,
  sub_commands_left: 0,
  times_connected: 1,
  buffers: false,
  options: 
   { port: 6379,
     host: '127.0.0.1',
     socket_nodelay: true,
     socket_keepalive: true,
     return_buffers: false,
     detect_buffers: false },
  reply: 'ON',
  reply_parser: 
   JavascriptRedisParser {
     optionReturnBuffers: false,
     optionStringNumbers: false,
     returnError: [Function: returnError],
     returnFatalError: [Function: returnFatalError],
     returnReply: [Function: returnReply],
     name: 'javascript',
     offset: 2142,
     buffer: null,
     bigStrSize: 0,
     bigOffset: 0,
     totalChunkSize: 0,
     bufferCache: [],
     arrayCache: [],
     arrayPos: [] },
  stream: 
   Socket {
     connecting: false,
     _hadError: false,
     _handle: 
      TCP {
        bytesRead: 2142,
        _externalStream: {},
        fd: 15,
        reading: true,
        owner: [Circular],
        onread: [Function: onread],
        onconnection: null,
        writeQueueSize: 0 },
     _parent: null,
     _host: null,
     _readableState: 
      ReadableState {
        objectMode: false,
        highWaterMark: 16384,
        buffer: [Object],
        length: 0,
        pipes: null,
        pipesCount: 0,
        flowing: true,
        ended: false,
        endEmitted: false,
        reading: true,
        sync: false,
        needReadable: true,
        emittedReadable: false,
        readableListening: false,
        resumeScheduled: false,
        defaultEncoding: 'utf8',
        ranOut: false,
        awaitDrain: 0,
        readingMore: false,
        decoder: null,
        encoding: null },
     readable: true,
     domain: null,
     _events: 
      { end: [Object],
        finish: [Function: onSocketFinish],
        _socketEnd: [Function: onSocketEnd],
        data: [Function],
        error: [Function],
        clientError: [Function],
        close: [Object],
        drain: [Function] },
     _eventsCount: 8,
     _maxListeners: undefined,
     _writableState: 
      WritableState {
        objectMode: false,
        highWaterMark: 16384,
        needDrain: false,
        ending: false,
        ended: false,
        finished: false,
        decodeStrings: false,
        defaultEncoding: 'utf8',
        length: 0,
        writing: false,
        corked: 0,
        sync: false,
        bufferProcessing: false,
        onwrite: [Function: bound onwrite],
        writecb: null,
        writelen: 0,
        bufferedRequest: null,
        lastBufferedRequest: null,
        pendingcb: 0,
        prefinished: false,
        errorEmitted: false,
        bufferedRequestCount: 0,
        corkedRequestsFree: [Object] },
     writable: true,
     allowHalfOpen: false,
     destroyed: false,
     _bytesDispatched: 14,
     _sockname: null,
     _pendingData: null,
     _pendingEncoding: '',
     server: null,
     _server: null,
     read: [Function],
     _consuming: true,
     _idleNext: null,
     _idlePrev: null,
     _idleTimeout: -1 },
  emitted_end: false,
  cork: [Function],
  uncork: [Function] }
[2017-05-04 13:06:22.520] [ERROR] console - (node:96265) DeprecationWarning: Mongoose: mpromise (mongoose's default promise library) is deprecated, plug in your own promise library instead: http://mongoosejs.com/docs/promises.html
[2017-05-04 13:06:22.526] [WARN] console - [ { _id: 5902b753c5756d72945d90b3,
    updatedAt: 2017-04-28T03:30:27.167Z,
    createdAt: 2017-04-28T03:30:27.167Z,
    username: '222',
    __v: 0 },
  { _id: 590467fb9bb491da74caee32,
    updatedAt: 2017-04-29T10:16:27.758Z,
    createdAt: 2017-04-29T10:16:27.758Z,
    username: 'user0.38955004828614115',
    __v: 0 },
  { _id: 5904689fb4b502db0a450395,
    updatedAt: 2017-04-29T10:19:11.350Z,
    createdAt: 2017-04-29T10:19:11.350Z,
    username: 'user0.9823151939002306',
    __v: 0 } ]
[2017-05-04 13:14:56.544] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:14:56.556] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:14:56.560] [INFO] app - Redis client default is ready {}
[2017-05-04 13:14:56.684] [WARN] console - application is startup, listening on port 3000
[2017-05-04 13:14:59.854] [WARN] console - in api ...............
[2017-05-04 13:14:59.855] [WARN] console - RedisClient {
  domain: null,
  _events: 
   { newListener: [Function],
     connect: [Function],
     ready: [Function],
     reconnecting: [Function],
     error: [ [Function], [Function: errorHandler] ],
     end: [Function] },
  _eventsCount: 6,
  _maxListeners: undefined,
  address: '127.0.0.1:6379',
  connection_options: { port: 6379, host: '127.0.0.1', family: 4 },
  connection_id: 0,
  connected: true,
  ready: true,
  should_buffer: false,
  max_attempts: 0,
  command_queue: { [String: ''] '0': undefined, _capacity: 16, _length: 0, _front: 1 },
  offline_queue: { [String: ''] _capacity: 16, _length: 0, _front: 0 },
  pipeline_queue: { [String: ''] _capacity: 16, _length: 0, _front: 0 },
  connect_timeout: 3600000,
  enable_offline_queue: true,
  retry_max_delay: null,
  retry_timer: null,
  retry_totaltime: 0,
  retry_delay: 200,
  retry_backoff: 1.7,
  attempts: 1,
  pub_sub_mode: 0,
  subscription_set: {},
  monitoring: false,
  message_buffers: false,
  closing: false,
  server_info: 
   { redis_version: '3.2.8',
     redis_git_sha1: '00000000',
     redis_git_dirty: '0',
     redis_build_id: 'ae7e7d2604b97c53',
     redis_mode: 'standalone',
     os: 'Darwin 15.0.0 x86_64',
     arch_bits: '64',
     multiplexing_api: 'kqueue',
     gcc_version: '4.2.1',
     process_id: '96159',
     run_id: 'ebe29182b7fe6e47163ac97dca7db95076a825ff',
     tcp_port: '6379',
     uptime_in_seconds: '749',
     uptime_in_days: '0',
     hz: '10',
     lru_clock: '702672',
     executable: '/usr/local/redis/./bin/redis-server',
     config_file: '/usr/local/redis/./etc/redis.conf',
     connected_clients: '1',
     client_longest_output_list: '0',
     client_biggest_input_buf: '0',
     blocked_clients: '0',
     used_memory: '1008608',
     used_memory_human: '984.97K',
     used_memory_rss: '2064384',
     used_memory_rss_human: '1.97M',
     used_memory_peak: '1059168',
     used_memory_peak_human: '1.01M',
     total_system_memory: '8589934592',
     total_system_memory_human: '8.00G',
     used_memory_lua: '37888',
     used_memory_lua_human: '37.00K',
     maxmemory: '0',
     maxmemory_human: '0B',
     maxmemory_policy: 'noeviction',
     mem_fragmentation_ratio: '2.05',
     mem_allocator: 'libc',
     loading: '0',
     rdb_changes_since_last_save: '0',
     rdb_bgsave_in_progress: '0',
     rdb_last_save_time: '1493874147',
     rdb_last_bgsave_status: 'ok',
     rdb_last_bgsave_time_sec: '-1',
     rdb_current_bgsave_time_sec: '-1',
     aof_enabled: '0',
     aof_rewrite_in_progress: '0',
     aof_rewrite_scheduled: '0',
     aof_last_rewrite_time_sec: '-1',
     aof_current_rewrite_time_sec: '-1',
     aof_last_bgrewrite_status: 'ok',
     aof_last_write_status: 'ok',
     total_connections_received: '6',
     total_commands_processed: '5',
     instantaneous_ops_per_sec: '0',
     total_net_input_bytes: '84',
     total_net_output_bytes: '10709',
     instantaneous_input_kbps: '0.00',
     instantaneous_output_kbps: '0.00',
     rejected_connections: '0',
     sync_full: '0',
     sync_partial_ok: '0',
     sync_partial_err: '0',
     expired_keys: '0',
     evicted_keys: '0',
     keyspace_hits: '0',
     keyspace_misses: '0',
     pubsub_channels: '0',
     pubsub_patterns: '0',
     latest_fork_usec: '0',
     migrate_cached_sockets: '0',
     role: 'master',
     connected_slaves: '0',
     master_repl_offset: '0',
     repl_backlog_active: '0',
     repl_backlog_size: '1048576',
     repl_backlog_first_byte_offset: '0',
     repl_backlog_histlen: '0',
     used_cpu_sys: '0.28',
     used_cpu_user: '0.15',
     used_cpu_sys_children: '0.00',
     used_cpu_user_children: '0.00',
     cluster_enabled: '0',
     versions: [ 3, 2, 8 ] },
  auth_pass: undefined,
  selected_db: undefined,
  old_state: null,
  fire_strings: true,
  pipeline: false,
  sub_commands_left: 0,
  times_connected: 1,
  buffers: false,
  options: 
   { port: 6379,
     host: '127.0.0.1',
     socket_nodelay: true,
     socket_keepalive: true,
     return_buffers: false,
     detect_buffers: false },
  reply: 'ON',
  reply_parser: 
   JavascriptRedisParser {
     optionReturnBuffers: false,
     optionStringNumbers: false,
     returnError: [Function: returnError],
     returnFatalError: [Function: returnFatalError],
     returnReply: [Function: returnReply],
     name: 'javascript',
     offset: 2143,
     buffer: null,
     bigStrSize: 0,
     bigOffset: 0,
     totalChunkSize: 0,
     bufferCache: [],
     arrayCache: [],
     arrayPos: [] },
  stream: 
   Socket {
     connecting: false,
     _hadError: false,
     _handle: 
      TCP {
        bytesRead: 2143,
        _externalStream: {},
        fd: 15,
        reading: true,
        owner: [Circular],
        onread: [Function: onread],
        onconnection: null,
        writeQueueSize: 0 },
     _parent: null,
     _host: null,
     _readableState: 
      ReadableState {
        objectMode: false,
        highWaterMark: 16384,
        buffer: [Object],
        length: 0,
        pipes: null,
        pipesCount: 0,
        flowing: true,
        ended: false,
        endEmitted: false,
        reading: true,
        sync: false,
        needReadable: true,
        emittedReadable: false,
        readableListening: false,
        resumeScheduled: false,
        defaultEncoding: 'utf8',
        ranOut: false,
        awaitDrain: 0,
        readingMore: false,
        decoder: null,
        encoding: null },
     readable: true,
     domain: null,
     _events: 
      { end: [Object],
        finish: [Function: onSocketFinish],
        _socketEnd: [Function: onSocketEnd],
        data: [Function],
        error: [Function],
        clientError: [Function],
        close: [Object],
        drain: [Function] },
     _eventsCount: 8,
     _maxListeners: undefined,
     _writableState: 
      WritableState {
        objectMode: false,
        highWaterMark: 16384,
        needDrain: false,
        ending: false,
        ended: false,
        finished: false,
        decodeStrings: false,
        defaultEncoding: 'utf8',
        length: 0,
        writing: false,
        corked: 0,
        sync: false,
        bufferProcessing: false,
        onwrite: [Function: bound onwrite],
        writecb: null,
        writelen: 0,
        bufferedRequest: null,
        lastBufferedRequest: null,
        pendingcb: 0,
        prefinished: false,
        errorEmitted: false,
        bufferedRequestCount: 0,
        corkedRequestsFree: [Object] },
     writable: true,
     allowHalfOpen: false,
     destroyed: false,
     _bytesDispatched: 14,
     _sockname: null,
     _pendingData: null,
     _pendingEncoding: '',
     server: null,
     _server: null,
     read: [Function],
     _consuming: true,
     _idleNext: null,
     _idlePrev: null,
     _idleTimeout: -1 },
  emitted_end: false,
  cork: [Function],
  uncork: [Function] }
[2017-05-04 13:14:59.887] [ERROR] console - (node:96760) DeprecationWarning: Mongoose: mpromise (mongoose's default promise library) is deprecated, plug in your own promise library instead: http://mongoosejs.com/docs/promises.html
[2017-05-04 13:14:59.896] [WARN] console - [ { _id: 5902b753c5756d72945d90b3,
    updatedAt: 2017-04-28T03:30:27.167Z,
    createdAt: 2017-04-28T03:30:27.167Z,
    username: '222',
    __v: 0 },
  { _id: 590467fb9bb491da74caee32,
    updatedAt: 2017-04-29T10:16:27.758Z,
    createdAt: 2017-04-29T10:16:27.758Z,
    username: 'user0.38955004828614115',
    __v: 0 },
  { _id: 5904689fb4b502db0a450395,
    updatedAt: 2017-04-29T10:19:11.350Z,
    createdAt: 2017-04-29T10:19:11.350Z,
    username: 'user0.9823151939002306',
    __v: 0 } ]
[2017-05-04 13:15:36.519] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:15:36.531] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:15:36.535] [INFO] app - Redis client default is ready {}
[2017-05-04 13:15:36.654] [WARN] console - application is startup, listening on port 3000
[2017-05-04 13:15:50.611] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:15:50.630] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:15:50.659] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:15:50.675] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:15:50.635] [INFO] app - Redis client default is ready {}
[2017-05-04 13:15:50.855] [WARN] console - application is startup, listening on port 3000
[2017-05-04 13:15:54.831] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:15:54.844] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:15:54.849] [INFO] app - Redis client default is ready {}
[2017-05-04 13:15:54.907] [WARN] console - application is startup, listening on port 3000
[2017-05-04 13:16:24.192] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:16:24.208] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:16:24.214] [INFO] app - Redis client default is ready {}
[2017-05-04 13:16:24.385] [WARN] console - application is startup, listening on port 3000
[2017-05-04 13:16:25.342] [WARN] console - ?????
[2017-05-04 13:16:45.565] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:16:45.577] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:16:45.581] [INFO] app - Redis client default is ready {}
[2017-05-04 13:16:45.715] [WARN] console - application is startup, listening on port 3000
[2017-05-04 13:18:19.642] [WARN] console - in api ...............
[2017-05-04 13:18:19.643] [WARN] console - RedisClient {
  domain: null,
  _events: 
   { newListener: [Function],
     connect: [Function],
     ready: [Function],
     reconnecting: [Function],
     error: [ [Function], [Function: errorHandler] ],
     end: [Function] },
  _eventsCount: 6,
  _maxListeners: undefined,
  address: '127.0.0.1:6379',
  connection_options: { port: 6379, host: '127.0.0.1', family: 4 },
  connection_id: 0,
  connected: true,
  ready: true,
  should_buffer: false,
  max_attempts: 0,
  command_queue: { [String: ''] '0': undefined, _capacity: 16, _length: 0, _front: 1 },
  offline_queue: { [String: ''] _capacity: 16, _length: 0, _front: 0 },
  pipeline_queue: { [String: ''] _capacity: 16, _length: 0, _front: 0 },
  connect_timeout: 3600000,
  enable_offline_queue: true,
  retry_max_delay: null,
  retry_timer: null,
  retry_totaltime: 0,
  retry_delay: 200,
  retry_backoff: 1.7,
  attempts: 1,
  pub_sub_mode: 0,
  subscription_set: {},
  monitoring: false,
  message_buffers: false,
  closing: false,
  server_info: 
   { redis_version: '3.2.8',
     redis_git_sha1: '00000000',
     redis_git_dirty: '0',
     redis_build_id: 'ae7e7d2604b97c53',
     redis_mode: 'standalone',
     os: 'Darwin 15.0.0 x86_64',
     arch_bits: '64',
     multiplexing_api: 'kqueue',
     gcc_version: '4.2.1',
     process_id: '96159',
     run_id: 'ebe29182b7fe6e47163ac97dca7db95076a825ff',
     tcp_port: '6379',
     uptime_in_seconds: '858',
     uptime_in_days: '0',
     hz: '10',
     lru_clock: '702781',
     executable: '/usr/local/redis/./bin/redis-server',
     config_file: '/usr/local/redis/./etc/redis.conf',
     connected_clients: '1',
     client_longest_output_list: '0',
     client_biggest_input_buf: '0',
     blocked_clients: '0',
     used_memory: '1008608',
     used_memory_human: '984.97K',
     used_memory_rss: '2076672',
     used_memory_rss_human: '1.98M',
     used_memory_peak: '1059168',
     used_memory_peak_human: '1.01M',
     total_system_memory: '8589934592',
     total_system_memory_human: '8.00G',
     used_memory_lua: '37888',
     used_memory_lua_human: '37.00K',
     maxmemory: '0',
     maxmemory_human: '0B',
     maxmemory_policy: 'noeviction',
     mem_fragmentation_ratio: '2.06',
     mem_allocator: 'libc',
     loading: '0',
     rdb_changes_since_last_save: '0',
     rdb_bgsave_in_progress: '0',
     rdb_last_save_time: '1493874147',
     rdb_last_bgsave_status: 'ok',
     rdb_last_bgsave_time_sec: '-1',
     rdb_current_bgsave_time_sec: '-1',
     aof_enabled: '0',
     aof_rewrite_in_progress: '0',
     aof_rewrite_scheduled: '0',
     aof_last_rewrite_time_sec: '-1',
     aof_current_rewrite_time_sec: '-1',
     aof_last_bgrewrite_status: 'ok',
     aof_last_write_status: 'ok',
     total_connections_received: '12',
     total_commands_processed: '11',
     instantaneous_ops_per_sec: '0',
     total_net_input_bytes: '168',
     total_net_output_bytes: '23572',
     instantaneous_input_kbps: '0.00',
     instantaneous_output_kbps: '0.00',
     rejected_connections: '0',
     sync_full: '0',
     sync_partial_ok: '0',
     sync_partial_err: '0',
     expired_keys: '0',
     evicted_keys: '0',
     keyspace_hits: '0',
     keyspace_misses: '0',
     pubsub_channels: '0',
     pubsub_patterns: '0',
     latest_fork_usec: '0',
     migrate_cached_sockets: '0',
     role: 'master',
     connected_slaves: '0',
     master_repl_offset: '0',
     repl_backlog_active: '0',
     repl_backlog_size: '1048576',
     repl_backlog_first_byte_offset: '0',
     repl_backlog_histlen: '0',
     used_cpu_sys: '0.32',
     used_cpu_user: '0.18',
     used_cpu_sys_children: '0.00',
     used_cpu_user_children: '0.00',
     cluster_enabled: '0',
     versions: [ 3, 2, 8 ] },
  auth_pass: undefined,
  selected_db: undefined,
  old_state: null,
  fire_strings: true,
  pipeline: false,
  sub_commands_left: 0,
  times_connected: 1,
  buffers: false,
  options: 
   { port: 6379,
     host: '127.0.0.1',
     socket_nodelay: true,
     socket_keepalive: true,
     return_buffers: false,
     detect_buffers: false },
  reply: 'ON',
  reply_parser: 
   JavascriptRedisParser {
     optionReturnBuffers: false,
     optionStringNumbers: false,
     returnError: [Function: returnError],
     returnFatalError: [Function: returnFatalError],
     returnReply: [Function: returnReply],
     name: 'javascript',
     offset: 2146,
     buffer: null,
     bigStrSize: 0,
     bigOffset: 0,
     totalChunkSize: 0,
     bufferCache: [],
     arrayCache: [],
     arrayPos: [] },
  stream: 
   Socket {
     connecting: false,
     _hadError: false,
     _handle: 
      TCP {
        bytesRead: 2146,
        _externalStream: {},
        fd: 15,
        reading: true,
        owner: [Circular],
        onread: [Function: onread],
        onconnection: null,
        writeQueueSize: 0 },
     _parent: null,
     _host: null,
     _readableState: 
      ReadableState {
        objectMode: false,
        highWaterMark: 16384,
        buffer: [Object],
        length: 0,
        pipes: null,
        pipesCount: 0,
        flowing: true,
        ended: false,
        endEmitted: false,
        reading: true,
        sync: false,
        needReadable: true,
        emittedReadable: false,
        readableListening: false,
        resumeScheduled: false,
        defaultEncoding: 'utf8',
        ranOut: false,
        awaitDrain: 0,
        readingMore: false,
        decoder: null,
        encoding: null },
     readable: true,
     domain: null,
     _events: 
      { end: [Object],
        finish: [Function: onSocketFinish],
        _socketEnd: [Function: onSocketEnd],
        data: [Function],
        error: [Function],
        clientError: [Function],
        close: [Object],
        drain: [Function] },
     _eventsCount: 8,
     _maxListeners: undefined,
     _writableState: 
      WritableState {
        objectMode: false,
        highWaterMark: 16384,
        needDrain: false,
        ending: false,
        ended: false,
        finished: false,
        decodeStrings: false,
        defaultEncoding: 'utf8',
        length: 0,
        writing: false,
        corked: 0,
        sync: false,
        bufferProcessing: false,
        onwrite: [Function: bound onwrite],
        writecb: null,
        writelen: 0,
        bufferedRequest: null,
        lastBufferedRequest: null,
        pendingcb: 0,
        prefinished: false,
        errorEmitted: false,
        bufferedRequestCount: 0,
        corkedRequestsFree: [Object] },
     writable: true,
     allowHalfOpen: false,
     destroyed: false,
     _bytesDispatched: 14,
     _sockname: null,
     _pendingData: null,
     _pendingEncoding: '',
     server: null,
     _server: null,
     read: [Function],
     _consuming: true,
     _idleNext: null,
     _idlePrev: null,
     _idleTimeout: -1 },
  emitted_end: false,
  cork: [Function],
  uncork: [Function] }
[2017-05-04 13:18:19.669] [ERROR] console - (node:96914) DeprecationWarning: Mongoose: mpromise (mongoose's default promise library) is deprecated, plug in your own promise library instead: http://mongoosejs.com/docs/promises.html
[2017-05-04 13:18:19.674] [WARN] console - [ { _id: 5902b753c5756d72945d90b3,
    updatedAt: 2017-04-28T03:30:27.167Z,
    createdAt: 2017-04-28T03:30:27.167Z,
    username: '222',
    __v: 0 },
  { _id: 590467fb9bb491da74caee32,
    updatedAt: 2017-04-29T10:16:27.758Z,
    createdAt: 2017-04-29T10:16:27.758Z,
    username: 'user0.38955004828614115',
    __v: 0 },
  { _id: 5904689fb4b502db0a450395,
    updatedAt: 2017-04-29T10:19:11.350Z,
    createdAt: 2017-04-29T10:19:11.350Z,
    username: 'user0.9823151939002306',
    __v: 0 } ]
[2017-05-04 13:18:30.561] [WARN] console - in api ...............
[2017-05-04 13:18:30.561] [WARN] console - RedisClient {
  domain: null,
  _events: 
   { newListener: [Function],
     connect: [Function],
     ready: [Function],
     reconnecting: [Function],
     error: [ [Function], [Function: errorHandler] ],
     end: [Function] },
  _eventsCount: 6,
  _maxListeners: undefined,
  address: '127.0.0.1:6379',
  connection_options: { port: 6379, host: '127.0.0.1', family: 4 },
  connection_id: 0,
  connected: true,
  ready: true,
  should_buffer: false,
  max_attempts: 0,
  command_queue: { [String: ''] '0': undefined, _capacity: 16, _length: 0, _front: 1 },
  offline_queue: { [String: ''] _capacity: 16, _length: 0, _front: 0 },
  pipeline_queue: { [String: ''] _capacity: 16, _length: 0, _front: 0 },
  connect_timeout: 3600000,
  enable_offline_queue: true,
  retry_max_delay: null,
  retry_timer: null,
  retry_totaltime: 0,
  retry_delay: 200,
  retry_backoff: 1.7,
  attempts: 1,
  pub_sub_mode: 0,
  subscription_set: {},
  monitoring: false,
  message_buffers: false,
  closing: false,
  server_info: 
   { redis_version: '3.2.8',
     redis_git_sha1: '00000000',
     redis_git_dirty: '0',
     redis_build_id: 'ae7e7d2604b97c53',
     redis_mode: 'standalone',
     os: 'Darwin 15.0.0 x86_64',
     arch_bits: '64',
     multiplexing_api: 'kqueue',
     gcc_version: '4.2.1',
     process_id: '96159',
     run_id: 'ebe29182b7fe6e47163ac97dca7db95076a825ff',
     tcp_port: '6379',
     uptime_in_seconds: '858',
     uptime_in_days: '0',
     hz: '10',
     lru_clock: '702781',
     executable: '/usr/local/redis/./bin/redis-server',
     config_file: '/usr/local/redis/./etc/redis.conf',
     connected_clients: '1',
     client_longest_output_list: '0',
     client_biggest_input_buf: '0',
     blocked_clients: '0',
     used_memory: '1008608',
     used_memory_human: '984.97K',
     used_memory_rss: '2076672',
     used_memory_rss_human: '1.98M',
     used_memory_peak: '1059168',
     used_memory_peak_human: '1.01M',
     total_system_memory: '8589934592',
     total_system_memory_human: '8.00G',
     used_memory_lua: '37888',
     used_memory_lua_human: '37.00K',
     maxmemory: '0',
     maxmemory_human: '0B',
     maxmemory_policy: 'noeviction',
     mem_fragmentation_ratio: '2.06',
     mem_allocator: 'libc',
     loading: '0',
     rdb_changes_since_last_save: '0',
     rdb_bgsave_in_progress: '0',
     rdb_last_save_time: '1493874147',
     rdb_last_bgsave_status: 'ok',
     rdb_last_bgsave_time_sec: '-1',
     rdb_current_bgsave_time_sec: '-1',
     aof_enabled: '0',
     aof_rewrite_in_progress: '0',
     aof_rewrite_scheduled: '0',
     aof_last_rewrite_time_sec: '-1',
     aof_current_rewrite_time_sec: '-1',
     aof_last_bgrewrite_status: 'ok',
     aof_last_write_status: 'ok',
     total_connections_received: '12',
     total_commands_processed: '11',
     instantaneous_ops_per_sec: '0',
     total_net_input_bytes: '168',
     total_net_output_bytes: '23572',
     instantaneous_input_kbps: '0.00',
     instantaneous_output_kbps: '0.00',
     rejected_connections: '0',
     sync_full: '0',
     sync_partial_ok: '0',
     sync_partial_err: '0',
     expired_keys: '0',
     evicted_keys: '0',
     keyspace_hits: '0',
     keyspace_misses: '0',
     pubsub_channels: '0',
     pubsub_patterns: '0',
     latest_fork_usec: '0',
     migrate_cached_sockets: '0',
     role: 'master',
     connected_slaves: '0',
     master_repl_offset: '0',
     repl_backlog_active: '0',
     repl_backlog_size: '1048576',
     repl_backlog_first_byte_offset: '0',
     repl_backlog_histlen: '0',
     used_cpu_sys: '0.32',
     used_cpu_user: '0.18',
     used_cpu_sys_children: '0.00',
     used_cpu_user_children: '0.00',
     cluster_enabled: '0',
     versions: [ 3, 2, 8 ] },
  auth_pass: undefined,
  selected_db: undefined,
  old_state: null,
  fire_strings: true,
  pipeline: false,
  sub_commands_left: 0,
  times_connected: 1,
  buffers: false,
  options: 
   { port: 6379,
     host: '127.0.0.1',
     socket_nodelay: true,
     socket_keepalive: true,
     return_buffers: false,
     detect_buffers: false },
  reply: 'ON',
  reply_parser: 
   JavascriptRedisParser {
     optionReturnBuffers: false,
     optionStringNumbers: false,
     returnError: [Function: returnError],
     returnFatalError: [Function: returnFatalError],
     returnReply: [Function: returnReply],
     name: 'javascript',
     offset: 2146,
     buffer: null,
     bigStrSize: 0,
     bigOffset: 0,
     totalChunkSize: 0,
     bufferCache: [],
     arrayCache: [],
     arrayPos: [] },
  stream: 
   Socket {
     connecting: false,
     _hadError: false,
     _handle: 
      TCP {
        bytesRead: 2146,
        _externalStream: {},
        fd: 15,
        reading: true,
        owner: [Circular],
        onread: [Function: onread],
        onconnection: null,
        writeQueueSize: 0 },
     _parent: null,
     _host: null,
     _readableState: 
      ReadableState {
        objectMode: false,
        highWaterMark: 16384,
        buffer: [Object],
        length: 0,
        pipes: null,
        pipesCount: 0,
        flowing: true,
        ended: false,
        endEmitted: false,
        reading: true,
        sync: false,
        needReadable: true,
        emittedReadable: false,
        readableListening: false,
        resumeScheduled: false,
        defaultEncoding: 'utf8',
        ranOut: false,
        awaitDrain: 0,
        readingMore: false,
        decoder: null,
        encoding: null },
     readable: true,
     domain: null,
     _events: 
      { end: [Object],
        finish: [Function: onSocketFinish],
        _socketEnd: [Function: onSocketEnd],
        data: [Function],
        error: [Function],
        clientError: [Function],
        close: [Object],
        drain: [Function] },
     _eventsCount: 8,
     _maxListeners: undefined,
     _writableState: 
      WritableState {
        objectMode: false,
        highWaterMark: 16384,
        needDrain: false,
        ending: false,
        ended: false,
        finished: false,
        decodeStrings: false,
        defaultEncoding: 'utf8',
        length: 0,
        writing: false,
        corked: 0,
        sync: false,
        bufferProcessing: false,
        onwrite: [Function: bound onwrite],
        writecb: null,
        writelen: 0,
        bufferedRequest: null,
        lastBufferedRequest: null,
        pendingcb: 0,
        prefinished: false,
        errorEmitted: false,
        bufferedRequestCount: 0,
        corkedRequestsFree: [Object] },
     writable: true,
     allowHalfOpen: false,
     destroyed: false,
     _bytesDispatched: 14,
     _sockname: null,
     _pendingData: null,
     _pendingEncoding: '',
     server: null,
     _server: null,
     read: [Function],
     _consuming: true,
     _idleNext: null,
     _idlePrev: null,
     _idleTimeout: -1 },
  emitted_end: false,
  cork: [Function],
  uncork: [Function] }
[2017-05-04 13:18:30.583] [WARN] console - [ { _id: 5902b753c5756d72945d90b3,
    updatedAt: 2017-04-28T03:30:27.167Z,
    createdAt: 2017-04-28T03:30:27.167Z,
    username: '222',
    __v: 0 },
  { _id: 590467fb9bb491da74caee32,
    updatedAt: 2017-04-29T10:16:27.758Z,
    createdAt: 2017-04-29T10:16:27.758Z,
    username: 'user0.38955004828614115',
    __v: 0 },
  { _id: 5904689fb4b502db0a450395,
    updatedAt: 2017-04-29T10:19:11.350Z,
    createdAt: 2017-04-29T10:19:11.350Z,
    username: 'user0.9823151939002306',
    __v: 0 } ]
[2017-05-04 13:19:13.670] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:19:13.686] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:19:13.689] [INFO] app - Redis client default is ready {}
[2017-05-04 13:19:13.910] [WARN] console - application is startup, listening on port 3000
[2017-05-04 13:19:25.078] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:19:25.096] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:19:25.102] [INFO] app - Redis client default is ready {}
[2017-05-04 13:19:25.361] [WARN] console - application is startup, listening on port 3000
[2017-05-04 13:19:46.903] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:19:46.928] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:19:47.131] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:19:47.148] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:19:46.935] [INFO] app - Redis client default is ready {}
[2017-05-04 13:19:47.228] [WARN] console - application is startup, listening on port 3000
[2017-05-04 13:20:01.610] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:20:01.625] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:20:07.732] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:20:07.745] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:20:09.427] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:20:09.440] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:20:35.800] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:20:35.815] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:20:41.537] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:20:41.553] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:20:43.489] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:20:43.500] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:20:55.228] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:20:55.244] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:20:57.889] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:20:57.902] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:21:18.923] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:21:18.935] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:21:26.092] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:21:26.105] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:22:14.062] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:22:14.075] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:23:08.967] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:23:08.980] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:23:15.114] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:23:15.135] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:23:33.348] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:23:33.366] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:23:48.437] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:23:48.455] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:23:55.841] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:23:55.851] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:23:55.854] [INFO] app - Redis client default is ready {}
[2017-05-04 13:23:55.910] [WARN] console - [Function: logger]
[2017-05-04 13:23:55.918] [WARN] console - application is startup, listening on port 3000
[2017-05-04 13:23:57.475] [WARN] console - this is a logger middleware.
[2017-05-04 13:23:57.476] [WARN] console - RedisClient {
  domain: null,
  _events: 
   { newListener: [Function],
     connect: [Function],
     ready: [Function],
     reconnecting: [Function],
     error: [ [Function], [Function: errorHandler] ],
     end: [Function] },
  _eventsCount: 6,
  _maxListeners: undefined,
  address: '127.0.0.1:6379',
  connection_options: { port: 6379, host: '127.0.0.1', family: 4 },
  connection_id: 0,
  connected: true,
  ready: true,
  should_buffer: false,
  max_attempts: 0,
  command_queue: { [String: ''] '0': undefined, _capacity: 16, _length: 0, _front: 1 },
  offline_queue: { [String: ''] _capacity: 16, _length: 0, _front: 0 },
  pipeline_queue: { [String: ''] _capacity: 16, _length: 0, _front: 0 },
  connect_timeout: 3600000,
  enable_offline_queue: true,
  retry_max_delay: null,
  retry_timer: null,
  retry_totaltime: 0,
  retry_delay: 200,
  retry_backoff: 1.7,
  attempts: 1,
  pub_sub_mode: 0,
  subscription_set: {},
  monitoring: false,
  message_buffers: false,
  closing: false,
  server_info: 
   { redis_version: '3.2.8',
     redis_git_sha1: '00000000',
     redis_git_dirty: '0',
     redis_build_id: 'ae7e7d2604b97c53',
     redis_mode: 'standalone',
     os: 'Darwin 15.0.0 x86_64',
     arch_bits: '64',
     multiplexing_api: 'kqueue',
     gcc_version: '4.2.1',
     process_id: '96159',
     run_id: 'ebe29182b7fe6e47163ac97dca7db95076a825ff',
     tcp_port: '6379',
     uptime_in_seconds: '1288',
     uptime_in_days: '0',
     hz: '10',
     lru_clock: '703211',
     executable: '/usr/local/redis/./bin/redis-server',
     config_file: '/usr/local/redis/./etc/redis.conf',
     connected_clients: '1',
     client_longest_output_list: '0',
     client_biggest_input_buf: '0',
     blocked_clients: '0',
     used_memory: '1007584',
     used_memory_human: '983.97K',
     used_memory_rss: '2097152',
     used_memory_rss_human: '2.00M',
     used_memory_peak: '1059168',
     used_memory_peak_human: '1.01M',
     total_system_memory: '8589934592',
     total_system_memory_human: '8.00G',
     used_memory_lua: '37888',
     used_memory_lua_human: '37.00K',
     maxmemory: '0',
     maxmemory_human: '0B',
     maxmemory_policy: 'noeviction',
     mem_fragmentation_ratio: '2.08',
     mem_allocator: 'libc',
     loading: '0',
     rdb_changes_since_last_save: '0',
     rdb_bgsave_in_progress: '0',
     rdb_last_save_time: '1493874147',
     rdb_last_bgsave_status: 'ok',
     rdb_last_bgsave_time_sec: '-1',
     rdb_current_bgsave_time_sec: '-1',
     aof_enabled: '0',
     aof_rewrite_in_progress: '0',
     aof_rewrite_scheduled: '0',
     aof_last_rewrite_time_sec: '-1',
     aof_current_rewrite_time_sec: '-1',
     aof_last_bgrewrite_status: 'ok',
     aof_last_write_status: 'ok',
     total_connections_received: '32',
     total_commands_processed: '31',
     instantaneous_ops_per_sec: '0',
     total_net_input_bytes: '448',
     total_net_output_bytes: '66527',
     instantaneous_input_kbps: '0.00',
     instantaneous_output_kbps: '0.00',
     rejected_connections: '0',
     sync_full: '0',
     sync_partial_ok: '0',
     sync_partial_err: '0',
     expired_keys: '0',
     evicted_keys: '0',
     keyspace_hits: '0',
     keyspace_misses: '0',
     pubsub_channels: '0',
     pubsub_patterns: '0',
     latest_fork_usec: '0',
     migrate_cached_sockets: '0',
     role: 'master',
     connected_slaves: '0',
     master_repl_offset: '0',
     repl_backlog_active: '0',
     repl_backlog_size: '1048576',
     repl_backlog_first_byte_offset: '0',
     repl_backlog_histlen: '0',
     used_cpu_sys: '0.47',
     used_cpu_user: '0.27',
     used_cpu_sys_children: '0.00',
     used_cpu_user_children: '0.00',
     cluster_enabled: '0',
     versions: [ 3, 2, 8 ] },
  auth_pass: undefined,
  selected_db: undefined,
  old_state: null,
  fire_strings: true,
  pipeline: false,
  sub_commands_left: 0,
  times_connected: 1,
  buffers: false,
  options: 
   { port: 6379,
     host: '127.0.0.1',
     socket_nodelay: true,
     socket_keepalive: true,
     return_buffers: false,
     detect_buffers: false },
  reply: 'ON',
  reply_parser: 
   JavascriptRedisParser {
     optionReturnBuffers: false,
     optionStringNumbers: false,
     returnError: [Function: returnError],
     returnFatalError: [Function: returnFatalError],
     returnReply: [Function: returnReply],
     name: 'javascript',
     offset: 2147,
     buffer: null,
     bigStrSize: 0,
     bigOffset: 0,
     totalChunkSize: 0,
     bufferCache: [],
     arrayCache: [],
     arrayPos: [] },
  stream: 
   Socket {
     connecting: false,
     _hadError: false,
     _handle: 
      TCP {
        bytesRead: 2147,
        _externalStream: {},
        fd: 15,
        reading: true,
        owner: [Circular],
        onread: [Function: onread],
        onconnection: null,
        writeQueueSize: 0 },
     _parent: null,
     _host: null,
     _readableState: 
      ReadableState {
        objectMode: false,
        highWaterMark: 16384,
        buffer: [Object],
        length: 0,
        pipes: null,
        pipesCount: 0,
        flowing: true,
        ended: false,
        endEmitted: false,
        reading: true,
        sync: false,
        needReadable: true,
        emittedReadable: false,
        readableListening: false,
        resumeScheduled: false,
        defaultEncoding: 'utf8',
        ranOut: false,
        awaitDrain: 0,
        readingMore: false,
        decoder: null,
        encoding: null },
     readable: true,
     domain: null,
     _events: 
      { end: [Object],
        finish: [Function: onSocketFinish],
        _socketEnd: [Function: onSocketEnd],
        data: [Function],
        error: [Function],
        clientError: [Function],
        close: [Object],
        drain: [Function] },
     _eventsCount: 8,
     _maxListeners: undefined,
     _writableState: 
      WritableState {
        objectMode: false,
        highWaterMark: 16384,
        needDrain: false,
        ending: false,
        ended: false,
        finished: false,
        decodeStrings: false,
        defaultEncoding: 'utf8',
        length: 0,
        writing: false,
        corked: 0,
        sync: false,
        bufferProcessing: false,
        onwrite: [Function: bound onwrite],
        writecb: null,
        writelen: 0,
        bufferedRequest: null,
        lastBufferedRequest: null,
        pendingcb: 0,
        prefinished: false,
        errorEmitted: false,
        bufferedRequestCount: 0,
        corkedRequestsFree: [Object] },
     writable: true,
     allowHalfOpen: false,
     destroyed: false,
     _bytesDispatched: 14,
     _sockname: null,
     _pendingData: null,
     _pendingEncoding: '',
     server: null,
     _server: null,
     read: [Function],
     _consuming: true,
     _idleNext: null,
     _idlePrev: null,
     _idleTimeout: -1 },
  emitted_end: false,
  cork: [Function],
  uncork: [Function] }
[2017-05-04 13:23:57.500] [ERROR] console - (node:97587) DeprecationWarning: Mongoose: mpromise (mongoose's default promise library) is deprecated, plug in your own promise library instead: http://mongoosejs.com/docs/promises.html
[2017-05-04 13:23:57.508] [WARN] console - [ { _id: 5902b753c5756d72945d90b3,
    updatedAt: 2017-04-28T03:30:27.167Z,
    createdAt: 2017-04-28T03:30:27.167Z,
    username: '222',
    __v: 0 },
  { _id: 590467fb9bb491da74caee32,
    updatedAt: 2017-04-29T10:16:27.758Z,
    createdAt: 2017-04-29T10:16:27.758Z,
    username: 'user0.38955004828614115',
    __v: 0 },
  { _id: 5904689fb4b502db0a450395,
    updatedAt: 2017-04-29T10:19:11.350Z,
    createdAt: 2017-04-29T10:19:11.350Z,
    username: 'user0.9823151939002306',
    __v: 0 } ]
[2017-05-04 13:24:18.813] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:24:18.829] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:24:18.835] [INFO] app - Redis client default is ready {}
[2017-05-04 13:24:19.043] [WARN] console - application is startup, listening on port 3000
[2017-05-04 13:24:38.992] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:24:39.009] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:24:39.118] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:24:39.143] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:24:39.014] [INFO] app - Redis client default is ready {}
[2017-05-04 13:24:39.185] [WARN] console - application is startup, listening on port 3000
[2017-05-04 13:25:38.780] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:25:38.790] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:26:16.504] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:26:16.516] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:28:32.689] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:28:32.703] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:29:08.214] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:29:08.225] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:29:50.070] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:29:50.086] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:30:10.898] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:30:10.909] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:34:46.085] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:34:46.096] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:34:46.100] [INFO] app - Redis client default is ready {}
[2017-05-04 13:34:46.278] [WARN] console - application is startup, listening on port 3000
[2017-05-04 13:34:57.334] [WARN] console - this is a logger middleware.
[2017-05-04 13:34:57.342] [ERROR] console - (node:98246) DeprecationWarning: Mongoose: mpromise (mongoose's default promise library) is deprecated, plug in your own promise library instead: http://mongoosejs.com/docs/promises.html
[2017-05-04 13:35:25.098] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:35:25.108] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:35:25.111] [INFO] app - Redis client default is ready {}
[2017-05-04 13:35:25.251] [WARN] console - application is startup, listening on port 3000
[2017-05-04 13:35:27.375] [WARN] console - this is a logger middleware.
[2017-05-04 13:35:27.389] [ERROR] console - (node:98277) DeprecationWarning: Mongoose: mpromise (mongoose's default promise library) is deprecated, plug in your own promise library instead: http://mongoosejs.com/docs/promises.html
[2017-05-04 13:35:30.813] [WARN] console - this is a logger middleware.
[2017-05-04 13:36:47.935] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:36:47.945] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:36:47.948] [INFO] app - Redis client default is ready {}
[2017-05-04 13:36:48.101] [WARN] console - application is startup, listening on port 3000
[2017-05-04 13:36:49.731] [WARN] console - this is a logger middleware.
[2017-05-04 13:36:49.744] [ERROR] console - (node:98395) DeprecationWarning: Mongoose: mpromise (mongoose's default promise library) is deprecated, plug in your own promise library instead: http://mongoosejs.com/docs/promises.html
[2017-05-04 13:36:52.512] [WARN] console - this is a logger middleware.
[2017-05-04 13:37:06.119] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:37:06.130] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:37:14.260] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:37:14.273] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:37:14.277] [INFO] app - Redis client default is ready {}
[2017-05-04 13:37:14.534] [WARN] console - application is startup, listening on port 3000
[2017-05-04 13:37:18.200] [WARN] console - this is a logger middleware.
[2017-05-04 13:37:18.213] [ERROR] console - (node:98455) DeprecationWarning: Mongoose: mpromise (mongoose's default promise library) is deprecated, plug in your own promise library instead: http://mongoosejs.com/docs/promises.html
[2017-05-04 13:37:28.696] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:37:28.708] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:37:28.711] [INFO] app - Redis client default is ready {}
[2017-05-04 13:37:28.849] [WARN] console - application is startup, listening on port 3000
[2017-05-04 13:37:30.679] [WARN] console - this is a logger middleware.
[2017-05-04 13:37:30.691] [ERROR] console - (node:98484) DeprecationWarning: Mongoose: mpromise (mongoose's default promise library) is deprecated, plug in your own promise library instead: http://mongoosejs.com/docs/promises.html
[2017-05-04 13:37:42.916] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:37:42.928] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:37:42.931] [INFO] app - Redis client default is ready {}
[2017-05-04 13:37:43.149] [WARN] console - application is startup, listening on port 3000
[2017-05-04 13:37:44.754] [WARN] console - this is a logger middleware.
[2017-05-04 13:37:44.766] [ERROR] console - (node:98527) DeprecationWarning: Mongoose: mpromise (mongoose's default promise library) is deprecated, plug in your own promise library instead: http://mongoosejs.com/docs/promises.html
[2017-05-04 13:37:47.424] [WARN] console - this is a logger middleware.
[2017-05-04 13:38:29.579] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:38:29.592] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:38:29.597] [INFO] app - Redis client default is ready {}
[2017-05-04 13:38:29.976] [WARN] console - application is startup, listening on port 3000
[2017-05-04 13:38:42.887] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:38:42.899] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:38:49.590] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:38:49.607] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:38:49.611] [INFO] app - Redis client default is ready {}
[2017-05-04 13:38:49.910] [WARN] console - application is startup, listening on port 3000
[2017-05-04 13:38:51.787] [WARN] console - this is a logger middleware.
[2017-05-04 13:38:51.800] [ERROR] console - (node:98623) DeprecationWarning: Mongoose: mpromise (mongoose's default promise library) is deprecated, plug in your own promise library instead: http://mongoosejs.com/docs/promises.html
[2017-05-04 13:38:58.330] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:38:58.342] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:38:58.449] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:38:58.464] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:38:58.345] [INFO] app - Redis client default is ready {}
[2017-05-04 13:38:58.713] [WARN] console - application is startup, listening on port 3000
[2017-05-04 13:39:03.213] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:39:03.224] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:39:03.227] [INFO] app - Redis client default is ready {}
[2017-05-04 13:39:03.288] [WARN] console - application is startup, listening on port 3000
[2017-05-04 13:39:05.130] [WARN] console - ???fdsfdsfsdf
[2017-05-04 13:39:05.139] [ERROR] console - 
[2017-05-04 13:39:05.139] [ERROR] console -   TypeError: Cannot read property 'req' of undefined
      at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/app/logging.js:14:61)
      at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
      at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
      at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
      at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/app/logging.js:13:191)
      at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/app/logging.js:13:437
      at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/app/logging.js:13:99
      at middleware (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/app/logging.js:10:3)
      at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
      at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:36:12
      at Server.handleRequest (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa/lib/application.js:136:14)
      at emitTwo (events.js:106:13)
      at Server.emit (events.js:194:7)
      at parserOnIncoming (_http_server.js:563:12)
      at HTTPParser.parserOnHeadersComplete (_http_common.js:99:23)
[2017-05-04 13:39:05.140] [ERROR] console - 
[2017-05-04 13:39:23.216] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:39:23.227] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:39:23.230] [INFO] app - Redis client default is ready {}
[2017-05-04 13:39:23.307] [WARN] console - application is startup, listening on port 3000
[2017-05-04 13:39:36.103] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:39:36.121] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:39:36.205] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:39:36.226] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:39:36.128] [INFO] app - Redis client default is ready {}
[2017-05-04 13:39:36.242] [WARN] console - application is startup, listening on port 3000
[2017-05-04 13:39:40.420] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:39:40.435] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:39:40.438] [INFO] app - Redis client default is ready {}
[2017-05-04 13:39:40.505] [WARN] console - application is startup, listening on port 3000
[2017-05-04 13:39:41.825] [DEBUG] app - 2017-5-4 13:39:41 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 13:39:41.828] [WARN] console - this is a logger middleware.
[2017-05-04 13:39:41.843] [ERROR] console - (node:98754) DeprecationWarning: Mongoose: mpromise (mongoose's default promise library) is deprecated, plug in your own promise library instead: http://mongoosejs.com/docs/promises.html
[2017-05-04 13:40:27.013] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:40:27.024] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:40:27.027] [INFO] app - Redis client default is ready {}
[2017-05-04 13:40:27.108] [WARN] console - application is startup, listening on port 3000
[2017-05-04 13:40:28.691] [DEBUG] app - 2017-5-4 13:40:28 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 13:40:28.696] [WARN] console - this is a logger middleware.
[2017-05-04 13:40:28.709] [ERROR] console - (node:98767) DeprecationWarning: Mongoose: mpromise (mongoose's default promise library) is deprecated, plug in your own promise library instead: http://mongoosejs.com/docs/promises.html
[2017-05-04 13:40:35.527] [DEBUG] app - 2017-5-4 13:40:35 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 13:40:35.527] [WARN] console - this is a logger middleware.
[2017-05-04 13:41:10.968] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:41:10.990] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:41:10.998] [INFO] app - Redis client default is ready {}
[2017-05-04 13:41:11.232] [WARN] console - application is startup, listening on port 3000
[2017-05-04 13:55:44.511] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:55:44.525] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:55:59.653] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:55:59.672] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:56:05.511] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:56:05.521] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:56:22.492] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:56:22.508] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:56:27.937] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 13:56:27.952] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 13:56:27.955] [INFO] app - Redis client default is ready {}
[2017-05-04 13:56:28.176] [INFO] app - application is startup, listening on port 3000
[2017-05-04 14:03:23.649] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:03:23.661] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:03:23.665] [INFO] app - Redis client default is ready {}
[2017-05-04 14:03:24.125] [INFO] app - application is startup, listening on port 3000
[2017-05-04 14:18:19.537] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:18:19.547] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:18:19.550] [INFO] app - Redis client default is ready {}
[2017-05-04 14:18:19.853] [INFO] app - application is startup, listening on port 3000
[2017-05-04 14:20:04.045] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:20:04.056] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:20:04.060] [INFO] app - Redis client default is ready {}
[2017-05-04 14:20:04.352] [INFO] app - application is startup, listening on port 3000
[2017-05-04 14:27:08.856] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:27:08.878] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:27:08.886] [INFO] app - Redis client default is ready {}
[2017-05-04 14:27:09.263] [INFO] app - application is startup, listening on port 3000
[2017-05-04 14:27:11.886] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:27:11.907] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:27:12.034] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:27:12.053] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:27:11.914] [INFO] app - Redis client default is ready {}
[2017-05-04 14:27:12.394] [INFO] app - application is startup, listening on port 3000
[2017-05-04 14:27:20.349] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:27:20.361] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:27:27.519] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:27:27.529] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:27:27.533] [INFO] app - Redis client default is ready {}
[2017-05-04 14:27:27.666] [INFO] app - application is startup, listening on port 3000
[2017-05-04 14:29:19.734] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:29:19.745] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:29:22.696] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:29:22.709] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:29:31.495] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:29:31.506] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:29:41.636] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:29:41.654] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:29:41.657] [INFO] app - Redis client default is ready {}
[2017-05-04 14:29:42.035] [INFO] app - application is startup, listening on port 3000
[2017-05-04 14:29:45.540] [DEBUG] app - 2017-5-4 14:29:45 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 14:29:45.547] [WARN] console - this is a logger middleware.
[2017-05-04 14:29:45.549] [ERROR] console - TypeError: Cannot read property 'UserService' of undefined
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:5:25)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:437
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:99
    at getUser (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:54:21)
    at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-router/lib/router.js:326:16
    at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/middlewares/logger.js:3:9)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/middlewares/logger.js:7:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/middlewares/logger.js:7:437
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/middlewares/logger.js:7:99
    at logger (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/middlewares/logger.js:28:17)
    at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
[2017-05-04 14:30:16.048] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:30:16.059] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:30:16.062] [INFO] app - Redis client default is ready {}
[2017-05-04 14:30:16.312] [INFO] app - application is startup, listening on port 3000
[2017-05-04 14:30:18.282] [DEBUG] app - 2017-5-4 14:30:18 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 14:30:18.286] [WARN] console - this is a logger middleware.
[2017-05-04 14:30:18.301] [ERROR] console - (node:529) DeprecationWarning: Mongoose: mpromise (mongoose's default promise library) is deprecated, plug in your own promise library instead: http://mongoosejs.com/docs/promises.html
[2017-05-04 14:31:52.160] [DEBUG] app - 2017-5-4 14:31:52 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 14:31:52.161] [WARN] console - this is a logger middleware.
[2017-05-04 14:35:46.842] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:35:46.855] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:35:46.858] [INFO] app - Redis client default is ready {}
[2017-05-04 14:35:47.219] [INFO] app - application is startup, listening on port 3000
[2017-05-04 14:36:36.279] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:36:36.295] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:36:36.299] [INFO] app - Redis client default is ready {}
[2017-05-04 14:36:36.656] [INFO] app - application is startup, listening on port 3000
[2017-05-04 14:36:37.971] [DEBUG] app - 2017-5-4 14:36:37 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 14:36:37.978] [WARN] console - this is a logger middleware.
[2017-05-04 14:36:37.980] [ERROR] console - TypeError: app.ctx.services.UserService.find is not a function
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:5:54)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:437
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:99
    at getUser (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:54:21)
    at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-router/lib/router.js:326:16
    at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/middlewares/logger.js:3:9)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/middlewares/logger.js:7:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/middlewares/logger.js:7:437
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/middlewares/logger.js:7:99
    at logger (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/middlewares/logger.js:28:17)
    at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
[2017-05-04 14:37:21.049] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:37:21.059] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:37:21.063] [INFO] app - Redis client default is ready {}
[2017-05-04 14:37:21.318] [INFO] app - application is startup, listening on port 3000
[2017-05-04 14:37:22.210] [DEBUG] app - 2017-5-4 14:37:22 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 14:37:22.213] [WARN] console - this is a logger middleware.
[2017-05-04 14:37:22.224] [ERROR] console - (node:685) DeprecationWarning: Mongoose: mpromise (mongoose's default promise library) is deprecated, plug in your own promise library instead: http://mongoosejs.com/docs/promises.html
[2017-05-04 14:38:08.958] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:38:08.970] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:38:08.973] [INFO] app - Redis client default is ready {}
[2017-05-04 14:38:09.156] [INFO] app - application is startup, listening on port 3000
[2017-05-04 14:38:09.962] [DEBUG] app - 2017-5-4 14:38:09 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 14:38:09.966] [WARN] console - this is a logger middleware.
[2017-05-04 14:38:09.975] [ERROR] console - (node:778) DeprecationWarning: Mongoose: mpromise (mongoose's default promise library) is deprecated, plug in your own promise library instead: http://mongoosejs.com/docs/promises.html
[2017-05-04 14:38:26.417] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:38:26.430] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:38:26.433] [INFO] app - Redis client default is ready {}
[2017-05-04 14:38:26.640] [INFO] app - application is startup, listening on port 3000
[2017-05-04 14:38:27.348] [DEBUG] app - 2017-5-4 14:38:27 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 14:38:27.354] [WARN] console - this is a logger middleware.
[2017-05-04 14:38:27.364] [ERROR] console - (node:814) DeprecationWarning: Mongoose: mpromise (mongoose's default promise library) is deprecated, plug in your own promise library instead: http://mongoosejs.com/docs/promises.html
[2017-05-04 14:44:06.908] [WARN] console - U
[2017-05-04 14:44:06.912] [WARN] console - M
[2017-05-04 14:44:09.742] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:44:09.757] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:44:32.082] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:44:32.094] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:44:38.387] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:44:38.399] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:44:38.403] [INFO] app - Redis client default is ready {}
[2017-05-04 14:44:38.744] [INFO] app - application is startup, listening on port 3000
[2017-05-04 14:44:42.017] [DEBUG] app - 2017-5-4 14:44:42 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 14:44:42.021] [WARN] console - this is a logger middleware.
[2017-05-04 14:44:42.036] [ERROR] console - (node:1217) DeprecationWarning: Mongoose: mpromise (mongoose's default promise library) is deprecated, plug in your own promise library instead: http://mongoosejs.com/docs/promises.html
[2017-05-04 14:45:48.215] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:45:48.226] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:45:48.229] [INFO] app - Redis client default is ready {}
[2017-05-04 14:45:48.476] [INFO] app - application is startup, listening on port 3000
[2017-05-04 14:46:11.701] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:46:11.731] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:46:11.736] [INFO] app - Redis client default is ready {}
[2017-05-04 14:46:11.980] [INFO] app - application is startup, listening on port 3000
[2017-05-04 14:46:14.078] [DEBUG] app - 2017-5-4 14:46:14 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 14:46:14.085] [WARN] console - this is a logger middleware.
[2017-05-04 14:46:14.086] [WARN] console - 123
[2017-05-04 14:46:14.095] [ERROR] console - (node:1281) DeprecationWarning: Mongoose: mpromise (mongoose's default promise library) is deprecated, plug in your own promise library instead: http://mongoosejs.com/docs/promises.html
[2017-05-04 14:46:30.225] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:46:30.264] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:46:30.610] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:46:30.672] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:46:30.957] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:46:30.981] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:46:30.279] [INFO] app - Redis client default is ready {}
[2017-05-04 14:46:30.984] [INFO] app - application is startup, listening on port 3000
[2017-05-04 14:46:31.182] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:46:31.222] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:46:31.362] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:46:31.387] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:46:31.436] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:46:31.464] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:46:41.757] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:46:41.769] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:46:45.396] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:46:45.410] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:46:45.413] [INFO] app - Redis client default is ready {}
[2017-05-04 14:46:45.530] [INFO] app - application is startup, listening on port 3000
[2017-05-04 14:46:51.021] [DEBUG] app - 2017-5-4 14:46:51 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 14:46:51.025] [WARN] console - this is a logger middleware.
[2017-05-04 14:46:51.038] [ERROR] console - (node:1431) DeprecationWarning: Mongoose: mpromise (mongoose's default promise library) is deprecated, plug in your own promise library instead: http://mongoosejs.com/docs/promises.html
[2017-05-04 14:49:23.066] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:49:23.078] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:49:23.082] [INFO] app - Redis client default is ready {}
[2017-05-04 14:49:23.283] [INFO] app - application is startup, listening on port 3000
[2017-05-04 14:49:27.624] [DEBUG] app - 2017-5-4 14:49:27 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 14:49:27.628] [WARN] console - this is a logger middleware.
[2017-05-04 14:49:56.956] [DEBUG] app - 2017-5-4 14:49:56 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 14:49:56.957] [WARN] console - this is a logger middleware.
[2017-05-04 14:55:04.458] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:55:04.471] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:55:23.737] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:55:23.776] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:56:29.671] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:56:29.691] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:56:32.009] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:56:32.020] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:56:59.586] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:56:59.598] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:57:10.891] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:57:10.909] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:58:41.285] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:58:41.303] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:59:33.659] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:59:33.676] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 14:59:44.707] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 14:59:44.723] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:00:09.005] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:00:09.016] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:00:28.234] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:00:28.244] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:00:38.835] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:00:38.852] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:00:44.254] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:00:44.268] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:01:01.550] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:01:01.575] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:01:22.411] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:01:22.444] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:01:37.119] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:01:37.132] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:02:17.647] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:02:17.658] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:02:21.796] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:02:21.808] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:02:40.109] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:02:40.123] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:03:26.720] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:03:26.731] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:03:26.734] [INFO] app - Redis client default is ready {}
[2017-05-04 15:03:27.030] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:03:32.373] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:03:32.386] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:03:32.389] [INFO] app - Redis client default is ready {}
[2017-05-04 15:03:32.587] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:03:35.251] [DEBUG] app - 2017-5-4 15:03:35 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:03:35.254] [WARN] console - this is a logger middleware.
[2017-05-04 15:03:52.598] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:03:52.610] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:03:52.616] [INFO] app - Redis client default is ready {}
[2017-05-04 15:03:52.894] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:04:01.296] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:04:01.313] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:04:01.317] [INFO] app - Redis client default is ready {}
[2017-05-04 15:04:01.607] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:05:54.292] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:05:54.306] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:05:54.310] [INFO] app - Redis client default is ready {}
[2017-05-04 15:05:54.511] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:06:04.525] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:06:04.538] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:06:06.202] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:06:06.214] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:06:06.218] [INFO] app - Redis client default is ready {}
[2017-05-04 15:06:06.450] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:06:10.721] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:06:10.732] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:06:10.735] [INFO] app - Redis client default is ready {}
[2017-05-04 15:06:10.934] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:06:15.510] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:06:15.524] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:06:15.527] [INFO] app - Redis client default is ready {}
[2017-05-04 15:06:15.745] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:07:20.463] [DEBUG] app - 2017-5-4 15:07:20 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:07:20.470] [WARN] console - this is a logger middleware.
[2017-05-04 15:07:22.117] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:07:22.129] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:07:22.133] [INFO] app - Redis client default is ready {}
[2017-05-04 15:07:22.370] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:07:23.743] [DEBUG] app - 2017-5-4 15:07:23 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:07:23.749] [WARN] console - this is a logger middleware.
[2017-05-04 15:07:23.765] [WARN] console - undefined
[2017-05-04 15:07:52.557] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:07:52.571] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:07:52.579] [INFO] app - Redis client default is ready {}
[2017-05-04 15:07:52.842] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:07:56.810] [DEBUG] app - 2017-5-4 15:07:56 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:07:56.818] [WARN] console - this is a logger middleware.
[2017-05-04 15:07:56.846] [WARN] console - undefined
[2017-05-04 15:08:07.873] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:08:07.884] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:08:07.886] [INFO] app - Redis client default is ready {}
[2017-05-04 15:08:08.094] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:08:35.885] [WARN] console - UserKv
[2017-05-04 15:08:35.902] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:08:35.915] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:08:35.918] [INFO] app - Redis client default is ready {}
[2017-05-04 15:08:36.086] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:08:37.350] [DEBUG] app - 2017-5-4 15:08:37 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:08:37.355] [WARN] console - this is a logger middleware.
[2017-05-04 15:08:37.357] [ERROR] console - TypeError: Cannot read property 'find' of undefined
    at UserService._callee3$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:20:18)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:437
    at UserService.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:99)
    at UserService.find (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:97:22)
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:5:56)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:437
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:99
    at getUser (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:55:21)
    at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-router/lib/router.js:326:16
    at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/middlewares/logger.js:3:9)
[2017-05-04 15:09:14.877] [WARN] console - UserKv
[2017-05-04 15:09:14.897] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:09:14.912] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:09:14.918] [INFO] app - Redis client default is ready {}
[2017-05-04 15:09:15.111] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:09:18.430] [DEBUG] app - 2017-5-4 15:09:18 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:09:18.434] [WARN] console - this is a logger middleware.
[2017-05-04 15:09:18.438] [ERROR] console - TypeError: Cannot read property 'find' of undefined
    at UserService._callee3$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:20:18)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:437
    at UserService.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:99)
    at UserService.find (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:97:22)
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:5:56)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:437
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:99
    at getUser (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:55:21)
    at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-router/lib/router.js:326:16
    at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/middlewares/logger.js:3:9)
[2017-05-04 15:09:39.575] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:09:39.586] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:09:39.589] [INFO] app - Redis client default is ready {}
[2017-05-04 15:09:39.792] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:09:40.625] [DEBUG] app - 2017-5-4 15:09:40 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:09:40.632] [WARN] console - this is a logger middleware.
[2017-05-04 15:09:40.634] [ERROR] console - TypeError: Cannot read property 'find' of undefined
    at UserService._callee3$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:20:18)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:437
    at UserService.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:99)
    at UserService.find (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:97:22)
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:5:56)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:437
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:99
    at getUser (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:55:21)
    at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-router/lib/router.js:326:16
    at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/middlewares/logger.js:3:9)
[2017-05-04 15:10:13.359] [WARN] console - { UserKv: [Function: UserKv] }
[2017-05-04 15:10:13.365] [WARN] console - undefined
[2017-05-04 15:10:13.393] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:10:13.405] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:10:13.408] [INFO] app - Redis client default is ready {}
[2017-05-04 15:10:13.591] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:10:23.780] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:10:23.791] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:10:23.794] [INFO] app - Redis client default is ready {}
[2017-05-04 15:10:23.991] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:10:50.605] [WARN] console - UserKv
[2017-05-04 15:10:50.634] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:10:50.648] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:10:50.651] [INFO] app - Redis client default is ready {}
[2017-05-04 15:10:50.852] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:10:52.954] [DEBUG] app - 2017-5-4 15:10:52 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:10:52.958] [WARN] console - this is a logger middleware.
[2017-05-04 15:10:52.960] [ERROR] console - TypeError: Cannot read property 'find' of undefined
    at UserService._callee3$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:20:18)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:437
    at UserService.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:99)
    at UserService.find (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:97:22)
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:5:56)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:437
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:99
    at getUser (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:55:21)
    at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-router/lib/router.js:326:16
    at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/middlewares/logger.js:3:9)
[2017-05-04 15:11:14.699] [WARN] console - UserKv
[2017-05-04 15:11:14.717] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:11:14.729] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:11:14.733] [INFO] app - Redis client default is ready {}
[2017-05-04 15:11:14.952] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:11:16.473] [DEBUG] app - 2017-5-4 15:11:16 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:11:16.479] [WARN] console - this is a logger middleware.
[2017-05-04 15:11:16.480] [WARN] console - { redis: 
   { main: 
      RedisClient {
        domain: null,
        _events: [Object],
        _eventsCount: 6,
        _maxListeners: undefined,
        address: '127.0.0.1:6379',
        connection_options: [Object],
        connection_id: 0,
        connected: true,
        ready: true,
        should_buffer: false,
        max_attempts: 0,
        command_queue: [Object],
        offline_queue: [Object],
        pipeline_queue: [Object],
        connect_timeout: 3600000,
        enable_offline_queue: true,
        retry_max_delay: null,
        retry_timer: null,
        retry_totaltime: 0,
        retry_delay: 200,
        retry_backoff: 1.7,
        attempts: 1,
        pub_sub_mode: 0,
        subscription_set: {},
        monitoring: false,
        message_buffers: false,
        closing: false,
        server_info: [Object],
        auth_pass: undefined,
        selected_db: undefined,
        old_state: null,
        fire_strings: true,
        pipeline: false,
        sub_commands_left: 0,
        times_connected: 1,
        buffers: false,
        options: [Object],
        reply: 'ON',
        reply_parser: [Object],
        stream: [Object],
        emitted_end: false,
        cork: [Function],
        uncork: [Function] } },
  mongoose: 
   { main: 
      Mongoose {
        connections: [Object],
        plugins: [],
        models: [Object],
        modelSchemas: [Object],
        options: [Object] } },
  controllers: 
   { userController: UserController {},
     mainController: MainController {} },
  services: { UserService: [Function] },
  models: {},
  kvs: { UserKv: [Function] },
  logger: 
   Logger {
     category: 'app',
     _events: { log: [Object] },
     _eventsCount: 1,
     level: Level { level: 10000, levelStr: 'DEBUG' } } }
[2017-05-04 15:11:16.490] [ERROR] console - TypeError: Cannot read property 'find' of undefined
    at UserService._callee3$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:20:18)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:437
    at UserService.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:99)
    at UserService.find (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:97:22)
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:6:56)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:437
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:99
    at getUser (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:57:21)
    at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-router/lib/router.js:326:16
    at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/middlewares/logger.js:3:9)
[2017-05-04 15:11:39.667] [WARN] console - UserKv
[2017-05-04 15:11:39.702] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:11:39.965] [WARN] console - UserKv
[2017-05-04 15:11:40.004] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:11:40.015] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:11:39.719] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:11:39.728] [INFO] app - Redis client default is ready {}
[2017-05-04 15:11:40.133] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:11:48.060] [WARN] console - UserKv
[2017-05-04 15:11:48.076] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:11:48.085] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:11:48.088] [INFO] app - Redis client default is ready {}
[2017-05-04 15:11:48.222] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:11:49.068] [DEBUG] app - 2017-5-4 15:11:49 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:11:49.074] [WARN] console - this is a logger middleware.
[2017-05-04 15:11:49.075] [WARN] console - { redis: 
   { main: 
      RedisClient {
        domain: null,
        _events: [Object],
        _eventsCount: 6,
        _maxListeners: undefined,
        address: '127.0.0.1:6379',
        connection_options: [Object],
        connection_id: 0,
        connected: true,
        ready: true,
        should_buffer: false,
        max_attempts: 0,
        command_queue: [Object],
        offline_queue: [Object],
        pipeline_queue: [Object],
        connect_timeout: 3600000,
        enable_offline_queue: true,
        retry_max_delay: null,
        retry_timer: null,
        retry_totaltime: 0,
        retry_delay: 200,
        retry_backoff: 1.7,
        attempts: 1,
        pub_sub_mode: 0,
        subscription_set: {},
        monitoring: false,
        message_buffers: false,
        closing: false,
        server_info: [Object],
        auth_pass: undefined,
        selected_db: undefined,
        old_state: null,
        fire_strings: true,
        pipeline: false,
        sub_commands_left: 0,
        times_connected: 1,
        buffers: false,
        options: [Object],
        reply: 'ON',
        reply_parser: [Object],
        stream: [Object],
        emitted_end: false,
        cork: [Function],
        uncork: [Function] } },
  mongoose: 
   { main: 
      Mongoose {
        connections: [Object],
        plugins: [],
        models: [Object],
        modelSchemas: [Object],
        options: [Object] } },
  controllers: 
   { userController: UserController {},
     mainController: MainController {} },
  services: { UserService: [Function] },
  models: {},
  kvs: { UserKv: [Function] },
  logger: 
   Logger {
     category: 'app',
     _events: { log: [Object] },
     _eventsCount: 1,
     level: Level { level: 10000, levelStr: 'DEBUG' } } }
[2017-05-04 15:11:49.083] [ERROR] console - TypeError: Cannot read property 'find' of undefined
    at UserService._callee3$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:20:18)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:437
    at UserService.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:99)
    at UserService.find (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:97:22)
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:6:56)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:437
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:99
    at getUser (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:57:21)
    at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-router/lib/router.js:326:16
    at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/middlewares/logger.js:3:9)
[2017-05-04 15:12:04.881] [WARN] console - UserKv
[2017-05-04 15:12:04.897] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:12:04.907] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:12:04.911] [INFO] app - Redis client default is ready {}
[2017-05-04 15:12:05.105] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:12:06.846] [DEBUG] app - 2017-5-4 15:12:06 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:12:06.853] [WARN] console - this is a logger middleware.
[2017-05-04 15:12:06.853] [WARN] console - [Function]
[2017-05-04 15:12:06.855] [ERROR] console - TypeError: Cannot read property 'find' of undefined
    at UserService._callee3$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:20:18)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:437
    at UserService.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:99)
    at UserService.find (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:97:22)
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:6:56)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:437
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:99
    at getUser (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:57:21)
    at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-router/lib/router.js:326:16
    at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/middlewares/logger.js:3:9)
[2017-05-04 15:12:18.295] [WARN] console - UserKv
[2017-05-04 15:12:18.313] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:12:18.324] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:12:18.327] [INFO] app - Redis client default is ready {}
[2017-05-04 15:12:18.531] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:12:24.076] [WARN] console - UserKv
[2017-05-04 15:12:24.096] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:12:24.104] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:12:24.107] [INFO] app - Redis client default is ready {}
[2017-05-04 15:12:24.292] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:12:25.576] [DEBUG] app - 2017-5-4 15:12:25 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:12:25.579] [WARN] console - this is a logger middleware.
[2017-05-04 15:12:25.580] [WARN] console - UserService {
  context: 
   { redis: { main: [Object] },
     mongoose: { main: [Object] },
     controllers: 
      { userController: UserController {},
        mainController: MainController {} },
     services: { UserService: [Function] },
     models: {},
     kvs: { UserKv: [Function] },
     logger: 
      Logger {
        category: 'app',
        _events: [Object],
        _eventsCount: 1,
        level: [Object] } } }
[2017-05-04 15:12:25.584] [WARN] console - [Function]
[2017-05-04 15:12:45.103] [WARN] console - UserKv
[2017-05-04 15:12:45.133] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:12:45.144] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:12:45.147] [INFO] app - Redis client default is ready {}
[2017-05-04 15:12:45.335] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:12:46.764] [DEBUG] app - 2017-5-4 15:12:46 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:12:46.767] [WARN] console - this is a logger middleware.
[2017-05-04 15:12:46.768] [WARN] console - [Function: find]
[2017-05-04 15:12:46.768] [WARN] console - [Function]
[2017-05-04 15:12:55.897] [WARN] console - UserKv
[2017-05-04 15:12:55.922] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:12:55.931] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:12:55.933] [INFO] app - Redis client default is ready {}
[2017-05-04 15:12:56.115] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:12:57.279] [DEBUG] app - 2017-5-4 15:12:57 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:12:57.282] [WARN] console - this is a logger middleware.
[2017-05-04 15:12:57.285] [ERROR] console - TypeError: Cannot read property 'find' of undefined
    at UserService._callee3$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:20:18)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:437
    at UserService.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:99)
    at UserService.find (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:97:22)
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:6:56)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:437
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:99
    at getUser (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:55:21)
    at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-router/lib/router.js:326:16
    at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/middlewares/logger.js:3:9)
[2017-05-04 15:14:16.678] [WARN] console - UserKv
[2017-05-04 15:14:16.698] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:14:16.708] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:14:16.711] [INFO] app - Redis client default is ready {}
[2017-05-04 15:14:16.887] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:14:18.853] [DEBUG] app - 2017-5-4 15:14:18 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:14:18.858] [WARN] console - this is a logger middleware.
[2017-05-04 15:14:18.860] [ERROR] console - TypeError: Cannot read property 'find' of undefined
    at UserService._callee3$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:20:18)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:437
    at UserService.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:99)
    at UserService.find (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:97:22)
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:6:56)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:437
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:99
    at getUser (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:55:21)
    at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-router/lib/router.js:326:16
    at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/middlewares/logger.js:3:9)
[2017-05-04 15:15:22.081] [WARN] console - UserKv
[2017-05-04 15:15:22.105] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:15:22.116] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:15:22.120] [INFO] app - Redis client default is ready {}
[2017-05-04 15:15:22.326] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:15:23.955] [WARN] console - UserKv
[2017-05-04 15:15:23.971] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:15:23.986] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:15:23.991] [INFO] app - Redis client default is ready {}
[2017-05-04 15:15:24.170] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:15:25.787] [DEBUG] app - 2017-5-4 15:15:25 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:15:25.791] [WARN] console - this is a logger middleware.
[2017-05-04 15:15:25.793] [WARN] console - { redis: 
   { main: 
      RedisClient {
        domain: null,
        _events: [Object],
        _eventsCount: 6,
        _maxListeners: undefined,
        address: '127.0.0.1:6379',
        connection_options: [Object],
        connection_id: 0,
        connected: true,
        ready: true,
        should_buffer: false,
        max_attempts: 0,
        command_queue: [Object],
        offline_queue: [Object],
        pipeline_queue: [Object],
        connect_timeout: 3600000,
        enable_offline_queue: true,
        retry_max_delay: null,
        retry_timer: null,
        retry_totaltime: 0,
        retry_delay: 200,
        retry_backoff: 1.7,
        attempts: 1,
        pub_sub_mode: 0,
        subscription_set: {},
        monitoring: false,
        message_buffers: false,
        closing: false,
        server_info: [Object],
        auth_pass: undefined,
        selected_db: undefined,
        old_state: null,
        fire_strings: true,
        pipeline: false,
        sub_commands_left: 0,
        times_connected: 1,
        buffers: false,
        options: [Object],
        reply: 'ON',
        reply_parser: [Object],
        stream: [Object],
        emitted_end: false,
        cork: [Function],
        uncork: [Function] } },
  mongoose: 
   { main: 
      Mongoose {
        connections: [Object],
        plugins: [],
        models: [Object],
        modelSchemas: [Object],
        options: [Object] } },
  controllers: 
   { userController: UserController {},
     mainController: MainController {} },
  services: { UserService: [Function] },
  models: {},
  kvs: { UserKv: [Function] },
  logger: 
   Logger {
     category: 'app',
     _events: { log: [Object] },
     _eventsCount: 1,
     level: Level { level: 10000, levelStr: 'DEBUG' } } }
[2017-05-04 15:15:25.804] [ERROR] console - TypeError: Cannot read property 'find' of undefined
    at UserService._callee3$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:22:18)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:437
    at UserService.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:99)
    at UserService.find (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:98:22)
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:6:56)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:437
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:99
    at getUser (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:55:21)
    at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-router/lib/router.js:326:16
    at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/middlewares/logger.js:3:9)
[2017-05-04 15:15:54.403] [WARN] console - UserKv
[2017-05-04 15:15:54.425] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:15:54.433] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:15:54.436] [INFO] app - Redis client default is ready {}
[2017-05-04 15:15:54.598] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:15:55.751] [DEBUG] app - 2017-5-4 15:15:55 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:15:55.756] [WARN] console - this is a logger middleware.
[2017-05-04 15:15:55.760] [WARN] console - { redis: 
   { main: 
      RedisClient {
        domain: null,
        _events: [Object],
        _eventsCount: 6,
        _maxListeners: undefined,
        address: '127.0.0.1:6379',
        connection_options: [Object],
        connection_id: 0,
        connected: true,
        ready: true,
        should_buffer: false,
        max_attempts: 0,
        command_queue: [Object],
        offline_queue: [Object],
        pipeline_queue: [Object],
        connect_timeout: 3600000,
        enable_offline_queue: true,
        retry_max_delay: null,
        retry_timer: null,
        retry_totaltime: 0,
        retry_delay: 200,
        retry_backoff: 1.7,
        attempts: 1,
        pub_sub_mode: 0,
        subscription_set: {},
        monitoring: false,
        message_buffers: false,
        closing: false,
        server_info: [Object],
        auth_pass: undefined,
        selected_db: undefined,
        old_state: null,
        fire_strings: true,
        pipeline: false,
        sub_commands_left: 0,
        times_connected: 1,
        buffers: false,
        options: [Object],
        reply: 'ON',
        reply_parser: [Object],
        stream: [Object],
        emitted_end: false,
        cork: [Function],
        uncork: [Function] } },
  mongoose: 
   { main: 
      Mongoose {
        connections: [Object],
        plugins: [],
        models: [Object],
        modelSchemas: [Object],
        options: [Object] } },
  controllers: 
   { userController: UserController {},
     mainController: MainController {} },
  services: { UserService: [Function] },
  models: {},
  kvs: { UserKv: [Function] },
  logger: 
   Logger {
     category: 'app',
     _events: { log: [Object] },
     _eventsCount: 1,
     level: Level { level: 10000, levelStr: 'DEBUG' } } }
[2017-05-04 15:15:55.771] [ERROR] console - TypeError: Cannot read property 'find' of undefined
    at UserService._callee3$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:21:18)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:437
    at UserService.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:99)
    at UserService.find (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:99:22)
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:6:56)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:437
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:99
    at getUser (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:55:21)
    at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-router/lib/router.js:326:16
    at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/middlewares/logger.js:3:9)
[2017-05-04 15:16:29.321] [WARN] console - undefined
[2017-05-04 15:16:29.325] [WARN] console - UserKv
[2017-05-04 15:16:29.326] [WARN] console - undefined
[2017-05-04 15:16:29.350] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:16:29.359] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:16:29.363] [INFO] app - Redis client default is ready {}
[2017-05-04 15:16:29.540] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:16:48.107] [WARN] console - { User: 
   { [Function: model]
     hooks: Kareem { _pres: [Object], _posts: {} },
     base: 
      Mongoose {
        connections: [Object],
        plugins: [],
        models: [Object],
        modelSchemas: [Object],
        options: [Object] },
     modelName: 'User',
     model: [Function: model],
     db: 
      NativeConnection {
        base: [Object],
        collections: [Object],
        models: [Object],
        config: [Object],
        replica: false,
        hosts: null,
        host: '127.0.0.1',
        port: 27017,
        user: undefined,
        pass: undefined,
        name: 'wenode',
        options: [Object],
        otherDbs: [],
        _readyState: 2,
        _closeCalled: false,
        _hasOpened: false,
        _listening: false,
        db: [Object],
        _events: [Object],
        _eventsCount: 4 },
     discriminators: undefined,
     schema: 
      Schema {
        obj: [Object],
        paths: [Object],
        subpaths: {},
        virtuals: [Object],
        singleNestedPaths: {},
        nested: {},
        inherits: {},
        callQueue: [Object],
        _indexes: [],
        methods: [Object],
        statics: {},
        tree: [Object],
        query: {},
        childSchemas: [],
        s: [Object],
        options: [Object],
        '$globalPluginsApplied': true },
     collection: 
      NativeCollection {
        collection: null,
        opts: [Object],
        name: 'users',
        collectionName: 'users',
        conn: [Object],
        queue: [],
        buffer: true,
        emitter: [Object] },
     Query: { [Function] base: [Object] },
     '$__insertMany': [Function],
     insertMany: [Function] } }
[2017-05-04 15:16:48.119] [WARN] console - UserKv
[2017-05-04 15:16:48.120] [WARN] console - undefined
[2017-05-04 15:16:48.138] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:16:48.150] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:16:48.154] [INFO] app - Redis client default is ready {}
[2017-05-04 15:16:48.367] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:16:50.727] [DEBUG] app - 2017-5-4 15:16:50 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:16:50.736] [WARN] console - this is a logger middleware.
[2017-05-04 15:16:50.737] [WARN] console - { redis: 
   { main: 
      RedisClient {
        domain: null,
        _events: [Object],
        _eventsCount: 6,
        _maxListeners: undefined,
        address: '127.0.0.1:6379',
        connection_options: [Object],
        connection_id: 0,
        connected: true,
        ready: true,
        should_buffer: false,
        max_attempts: 0,
        command_queue: [Object],
        offline_queue: [Object],
        pipeline_queue: [Object],
        connect_timeout: 3600000,
        enable_offline_queue: true,
        retry_max_delay: null,
        retry_timer: null,
        retry_totaltime: 0,
        retry_delay: 200,
        retry_backoff: 1.7,
        attempts: 1,
        pub_sub_mode: 0,
        subscription_set: {},
        monitoring: false,
        message_buffers: false,
        closing: false,
        server_info: [Object],
        auth_pass: undefined,
        selected_db: undefined,
        old_state: null,
        fire_strings: true,
        pipeline: false,
        sub_commands_left: 0,
        times_connected: 1,
        buffers: false,
        options: [Object],
        reply: 'ON',
        reply_parser: [Object],
        stream: [Object],
        emitted_end: false,
        cork: [Function],
        uncork: [Function] } },
  mongoose: 
   { main: 
      Mongoose {
        connections: [Object],
        plugins: [],
        models: [Object],
        modelSchemas: [Object],
        options: [Object] } },
  controllers: 
   { userController: UserController {},
     mainController: MainController {} },
  services: { UserService: [Function] },
  models: 
   { User: 
      { [Function: model]
        hooks: [Object],
        base: [Object],
        modelName: 'User',
        model: [Function: model],
        db: [Object],
        discriminators: undefined,
        schema: [Object],
        collection: [Object],
        Query: [Object],
        '$__insertMany': [Function],
        insertMany: [Function] } },
  kvs: { UserKv: [Function] },
  logger: 
   Logger {
     category: 'app',
     _events: { log: [Object] },
     _eventsCount: 1,
     level: Level { level: 10000, levelStr: 'DEBUG' } } }
[2017-05-04 15:16:50.758] [WARN] console - [Function]
[2017-05-04 15:17:03.203] [WARN] console - { User: 
   { [Function: model]
     hooks: Kareem { _pres: [Object], _posts: {} },
     base: 
      Mongoose {
        connections: [Object],
        plugins: [],
        models: [Object],
        modelSchemas: [Object],
        options: [Object] },
     modelName: 'User',
     model: [Function: model],
     db: 
      NativeConnection {
        base: [Object],
        collections: [Object],
        models: [Object],
        config: [Object],
        replica: false,
        hosts: null,
        host: '127.0.0.1',
        port: 27017,
        user: undefined,
        pass: undefined,
        name: 'wenode',
        options: [Object],
        otherDbs: [],
        _readyState: 2,
        _closeCalled: false,
        _hasOpened: false,
        _listening: false,
        db: [Object],
        _events: [Object],
        _eventsCount: 4 },
     discriminators: undefined,
     schema: 
      Schema {
        obj: [Object],
        paths: [Object],
        subpaths: {},
        virtuals: [Object],
        singleNestedPaths: {},
        nested: {},
        inherits: {},
        callQueue: [Object],
        _indexes: [],
        methods: [Object],
        statics: {},
        tree: [Object],
        query: {},
        childSchemas: [],
        s: [Object],
        options: [Object],
        '$globalPluginsApplied': true },
     collection: 
      NativeCollection {
        collection: null,
        opts: [Object],
        name: 'users',
        collectionName: 'users',
        conn: [Object],
        queue: [],
        buffer: true,
        emitter: [Object] },
     Query: { [Function] base: [Object] },
     '$__insertMany': [Function],
     insertMany: [Function] } }
[2017-05-04 15:17:03.212] [WARN] console - UserKv
[2017-05-04 15:17:03.214] [WARN] console - undefined
[2017-05-04 15:17:03.228] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:17:03.237] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:17:03.241] [INFO] app - Redis client default is ready {}
[2017-05-04 15:17:03.432] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:17:05.633] [DEBUG] app - 2017-5-4 15:17:05 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:17:05.638] [WARN] console - this is a logger middleware.
[2017-05-04 15:17:05.639] [WARN] console - { redis: 
   { main: 
      RedisClient {
        domain: null,
        _events: [Object],
        _eventsCount: 6,
        _maxListeners: undefined,
        address: '127.0.0.1:6379',
        connection_options: [Object],
        connection_id: 0,
        connected: true,
        ready: true,
        should_buffer: false,
        max_attempts: 0,
        command_queue: [Object],
        offline_queue: [Object],
        pipeline_queue: [Object],
        connect_timeout: 3600000,
        enable_offline_queue: true,
        retry_max_delay: null,
        retry_timer: null,
        retry_totaltime: 0,
        retry_delay: 200,
        retry_backoff: 1.7,
        attempts: 1,
        pub_sub_mode: 0,
        subscription_set: {},
        monitoring: false,
        message_buffers: false,
        closing: false,
        server_info: [Object],
        auth_pass: undefined,
        selected_db: undefined,
        old_state: null,
        fire_strings: true,
        pipeline: false,
        sub_commands_left: 0,
        times_connected: 1,
        buffers: false,
        options: [Object],
        reply: 'ON',
        reply_parser: [Object],
        stream: [Object],
        emitted_end: false,
        cork: [Function],
        uncork: [Function] } },
  mongoose: 
   { main: 
      Mongoose {
        connections: [Object],
        plugins: [],
        models: [Object],
        modelSchemas: [Object],
        options: [Object] } },
  controllers: 
   { userController: UserController {},
     mainController: MainController {} },
  services: { UserService: [Function] },
  models: 
   { User: 
      { [Function: model]
        hooks: [Object],
        base: [Object],
        modelName: 'User',
        model: [Function: model],
        db: [Object],
        discriminators: undefined,
        schema: [Object],
        collection: [Object],
        Query: [Object],
        '$__insertMany': [Function],
        insertMany: [Function] } },
  kvs: { UserKv: [Function] },
  logger: 
   Logger {
     category: 'app',
     _events: { log: [Object] },
     _eventsCount: 1,
     level: Level { level: 10000, levelStr: 'DEBUG' } } }
[2017-05-04 15:17:05.663] [WARN] console - [Function]
[2017-05-04 15:17:14.617] [WARN] console - { User: 
   { [Function: model]
     hooks: Kareem { _pres: [Object], _posts: {} },
     base: 
      Mongoose {
        connections: [Object],
        plugins: [],
        models: [Object],
        modelSchemas: [Object],
        options: [Object] },
     modelName: 'User',
     model: [Function: model],
     db: 
      NativeConnection {
        base: [Object],
        collections: [Object],
        models: [Object],
        config: [Object],
        replica: false,
        hosts: null,
        host: '127.0.0.1',
        port: 27017,
        user: undefined,
        pass: undefined,
        name: 'wenode',
        options: [Object],
        otherDbs: [],
        _readyState: 2,
        _closeCalled: false,
        _hasOpened: false,
        _listening: false,
        db: [Object],
        _events: [Object],
        _eventsCount: 4 },
     discriminators: undefined,
     schema: 
      Schema {
        obj: [Object],
        paths: [Object],
        subpaths: {},
        virtuals: [Object],
        singleNestedPaths: {},
        nested: {},
        inherits: {},
        callQueue: [Object],
        _indexes: [],
        methods: [Object],
        statics: {},
        tree: [Object],
        query: {},
        childSchemas: [],
        s: [Object],
        options: [Object],
        '$globalPluginsApplied': true },
     collection: 
      NativeCollection {
        collection: null,
        opts: [Object],
        name: 'users',
        collectionName: 'users',
        conn: [Object],
        queue: [],
        buffer: true,
        emitter: [Object] },
     Query: { [Function] base: [Object] },
     '$__insertMany': [Function],
     insertMany: [Function] } }
[2017-05-04 15:17:14.627] [WARN] console - UserKv
[2017-05-04 15:17:14.628] [WARN] console - undefined
[2017-05-04 15:17:14.646] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:17:14.658] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:17:14.662] [INFO] app - Redis client default is ready {}
[2017-05-04 15:17:14.938] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:17:26.220] [WARN] console - UserKv
[2017-05-04 15:17:26.246] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:17:26.261] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:17:26.266] [INFO] app - Redis client default is ready {}
[2017-05-04 15:17:26.460] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:17:31.001] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:17:31.019] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:17:31.023] [INFO] app - Redis client default is ready {}
[2017-05-04 15:17:31.197] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:17:32.772] [DEBUG] app - 2017-5-4 15:17:32 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:17:32.777] [WARN] console - this is a logger middleware.
[2017-05-04 15:17:32.778] [WARN] console - { redis: 
   { main: 
      RedisClient {
        domain: null,
        _events: [Object],
        _eventsCount: 6,
        _maxListeners: undefined,
        address: '127.0.0.1:6379',
        connection_options: [Object],
        connection_id: 0,
        connected: true,
        ready: true,
        should_buffer: false,
        max_attempts: 0,
        command_queue: [Object],
        offline_queue: [Object],
        pipeline_queue: [Object],
        connect_timeout: 3600000,
        enable_offline_queue: true,
        retry_max_delay: null,
        retry_timer: null,
        retry_totaltime: 0,
        retry_delay: 200,
        retry_backoff: 1.7,
        attempts: 1,
        pub_sub_mode: 0,
        subscription_set: {},
        monitoring: false,
        message_buffers: false,
        closing: false,
        server_info: [Object],
        auth_pass: undefined,
        selected_db: undefined,
        old_state: null,
        fire_strings: true,
        pipeline: false,
        sub_commands_left: 0,
        times_connected: 1,
        buffers: false,
        options: [Object],
        reply: 'ON',
        reply_parser: [Object],
        stream: [Object],
        emitted_end: false,
        cork: [Function],
        uncork: [Function] } },
  mongoose: 
   { main: 
      Mongoose {
        connections: [Object],
        plugins: [],
        models: [Object],
        modelSchemas: [Object],
        options: [Object] } },
  controllers: 
   { userController: UserController {},
     mainController: MainController {} },
  services: { UserService: [Function] },
  models: 
   { User: 
      { [Function: model]
        hooks: [Object],
        base: [Object],
        modelName: 'User',
        model: [Function: model],
        db: [Object],
        discriminators: undefined,
        schema: [Object],
        collection: [Object],
        Query: [Object],
        '$__insertMany': [Function],
        insertMany: [Function] } },
  kvs: { UserKv: [Function] },
  logger: 
   Logger {
     category: 'app',
     _events: { log: [Object] },
     _eventsCount: 1,
     level: Level { level: 10000, levelStr: 'DEBUG' } } }
[2017-05-04 15:18:14.623] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:18:14.635] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:18:14.638] [INFO] app - Redis client default is ready {}
[2017-05-04 15:18:14.838] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:18:15.810] [DEBUG] app - 2017-5-4 15:18:15 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:18:15.815] [WARN] console - this is a logger middleware.
[2017-05-04 15:18:37.384] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:18:37.400] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:18:37.403] [INFO] app - Redis client default is ready {}
[2017-05-04 15:18:37.601] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:18:39.374] [DEBUG] app - 2017-5-4 15:18:39 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:18:39.377] [WARN] console - this is a logger middleware.
[2017-05-04 15:18:39.399] [ERROR] console - TypeError: Cannot read property 'kvs' of undefined
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:6:20)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:361
    at process._tickDomainCallback (internal/process/next_tick.js:135:7)
[2017-05-04 15:18:55.902] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:18:55.919] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:18:55.923] [INFO] app - Redis client default is ready {}
[2017-05-04 15:18:56.119] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:18:57.110] [DEBUG] app - 2017-5-4 15:18:57 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:18:57.117] [WARN] console - this is a logger middleware.
[2017-05-04 15:18:57.132] [WARN] console - { UserKv: [Function] }
[2017-05-04 15:19:51.578] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:19:51.592] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:19:51.595] [INFO] app - Redis client default is ready {}
[2017-05-04 15:19:51.795] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:20:09.387] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:20:09.400] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:20:09.405] [INFO] app - Redis client default is ready {}
[2017-05-04 15:20:09.634] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:20:11.619] [DEBUG] app - 2017-5-4 15:20:11 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:20:11.624] [WARN] console - this is a logger middleware.
[2017-05-04 15:20:11.651] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type InternalCache.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:20:51.033] [WARN] console - { default: 
   { logCallback: [Function: logCallback],
     handleOk: [Function: handleOk],
     handleSingleValue: [Function: handleSingleValue],
     handleAffected: [Function: handleAffected] } }
[2017-05-04 15:20:51.060] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:20:51.068] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:20:51.072] [INFO] app - Redis client default is ready {}
[2017-05-04 15:20:51.267] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:21:10.078] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:21:10.094] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:21:10.099] [INFO] app - Redis client default is ready {}
[2017-05-04 15:21:10.283] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:21:13.417] [DEBUG] app - 2017-5-4 15:21:13 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:21:13.427] [WARN] console - this is a logger middleware.
[2017-05-04 15:21:13.449] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type InternalCache.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:26:13.892] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:26:13.903] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:26:13.906] [INFO] app - Redis client default is ready {}
[2017-05-04 15:26:14.084] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:26:35.699] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:26:35.713] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:26:35.715] [INFO] app - Redis client default is ready {}
[2017-05-04 15:26:35.872] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:26:40.243] [DEBUG] app - 2017-5-4 15:26:40 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:26:40.249] [WARN] console - this is a logger middleware.
[2017-05-04 15:26:40.274] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type InternalCache.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:29:56.094] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:29:56.106] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:29:56.109] [INFO] app - Redis client default is ready {}
[2017-05-04 15:29:56.320] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:30:06.022] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:30:06.033] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:30:06.036] [INFO] app - Redis client default is ready {}
[2017-05-04 15:30:06.207] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:30:09.376] [DEBUG] app - 2017-5-4 15:30:09 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:30:09.381] [WARN] console - this is a logger middleware.
[2017-05-04 15:30:09.404] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type InternalCache.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:30:09.404] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:30:09.404] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Object.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:30:09.404] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type NativeConnection.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:30:09.405] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:30:09.405] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type ObjectID.
This is converted to "5902b753c5756d72945d90b3" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:30:09.405] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Schema.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:30:09.405] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type NativeCollection.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:30:09.405] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Object.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:30:09.406] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Object.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:32:04.940] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:32:04.952] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:32:04.955] [INFO] app - Redis client default is ready {}
[2017-05-04 15:32:05.136] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:32:09.083] [DEBUG] app - 2017-5-4 15:32:09 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:32:09.089] [WARN] console - this is a logger middleware.
[2017-05-04 15:32:09.110] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type InternalCache.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:32:09.110] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:32:09.110] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Object.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:32:09.110] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type NativeConnection.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:32:09.110] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:32:09.110] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type ObjectID.
This is converted to "5902b753c5756d72945d90b3" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:32:09.110] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Schema.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:32:09.111] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type NativeCollection.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:32:09.111] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Object.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:32:09.111] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Object.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:32:09.113] [WARN] console - { _id: 5902b753c5756d72945d90b3,
  updatedAt: 2017-04-28T03:30:27.167Z,
  createdAt: 2017-04-28T03:30:27.167Z,
  username: '222',
  __v: 0 }
[2017-05-04 15:32:14.153] [DEBUG] app - 2017-5-4 15:32:14 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:32:14.153] [WARN] console - this is a logger middleware.
[2017-05-04 15:32:14.157] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type InternalCache.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:32:14.158] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:32:14.158] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Object.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:32:14.158] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type NativeConnection.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:32:14.158] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:32:14.158] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type ObjectID.
This is converted to "5902b753c5756d72945d90b3" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:32:14.158] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Schema.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:32:14.158] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type NativeCollection.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:32:14.159] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Object.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:32:14.159] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Object.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:32:14.161] [WARN] console - { _id: 5902b753c5756d72945d90b3,
  updatedAt: 2017-04-28T03:30:27.167Z,
  createdAt: 2017-04-28T03:30:27.167Z,
  username: '222',
  __v: 0 }
[2017-05-04 15:33:40.502] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:33:40.512] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:33:40.515] [INFO] app - Redis client default is ready {}
[2017-05-04 15:33:40.695] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:33:43.557] [DEBUG] app - 2017-5-4 15:33:43 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:33:43.560] [WARN] console - this is a logger middleware.
[2017-05-04 15:33:43.583] [ERROR] app - { ReplyError: ERR wrong number of arguments for 'hmset' command
    at parseError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/redis-parser/lib/parser.js:193:12)
    at parseType (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/redis-parser/lib/parser.js:303:14)
  command: 'HMSET',
  args: 
   [ 'usr:o:id:5902b753c5756d72945d90b3',
     '{"username":"222","id":"5902b753c5756d72945d90b3"}' ],
  code: 'ERR' }
[2017-05-04 15:33:43.587] [ERROR] console - { ReplyError: ERR wrong number of arguments for 'hmset' command
    at parseError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/redis-parser/lib/parser.js:193:12)
    at parseType (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/redis-parser/lib/parser.js:303:14)
  command: 'HMSET',
  args: 
   [ 'usr:o:id:5902b753c5756d72945d90b3',
     '{"username":"222","id":"5902b753c5756d72945d90b3"}' ],
  code: 'ERR' }
[2017-05-04 15:34:00.947] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:34:00.958] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:34:00.964] [INFO] app - Redis client default is ready {}
[2017-05-04 15:34:01.234] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:34:19.843] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:34:19.853] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:34:19.859] [INFO] app - Redis client default is ready {}
[2017-05-04 15:34:20.031] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:34:22.270] [DEBUG] app - 2017-5-4 15:34:22 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:34:22.274] [WARN] console - this is a logger middleware.
[2017-05-04 15:34:22.294] [WARN] console - {"username":"222","id":"5902b753c5756d72945d90b3"}
[2017-05-04 15:34:22.297] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type InternalCache.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:34:22.297] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:34:22.297] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Object.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:34:22.297] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type NativeConnection.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:34:22.297] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:34:22.298] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type ObjectID.
This is converted to "5902b753c5756d72945d90b3" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:34:22.298] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Schema.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:34:22.298] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type NativeCollection.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:34:22.298] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Object.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:34:22.298] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Object.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:34:22.301] [WARN] console - { _id: 5902b753c5756d72945d90b3,
  updatedAt: 2017-04-28T03:30:27.167Z,
  createdAt: 2017-04-28T03:30:27.167Z,
  username: '222',
  __v: 0 }
[2017-05-04 15:37:23.980] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:37:23.997] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:37:24.001] [INFO] app - Redis client default is ready {}
[2017-05-04 15:37:24.177] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:37:28.541] [DEBUG] app - 2017-5-4 15:37:28 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:37:28.545] [WARN] console - this is a logger middleware.
[2017-05-04 15:37:28.562] [WARN] console - {"username":"222","id":"5902b753c5756d72945d90b3"}
[2017-05-04 15:37:28.567] [ERROR] app - { ReplyError: ERR wrong number of arguments for 'hmset' command
    at parseError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/redis-parser/lib/parser.js:193:12)
    at parseType (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/redis-parser/lib/parser.js:303:14)
  command: 'HMSET',
  args: 
   [ 'usr:o:id:5902b753c5756d72945d90b3',
     '{"username":"222","id":"5902b753c5756d72945d90b3"}' ],
  code: 'ERR' }
[2017-05-04 15:37:28.572] [ERROR] console - { ReplyError: ERR wrong number of arguments for 'hmset' command
    at parseError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/redis-parser/lib/parser.js:193:12)
    at parseType (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/redis-parser/lib/parser.js:303:14)
  command: 'HMSET',
  args: 
   [ 'usr:o:id:5902b753c5756d72945d90b3',
     '{"username":"222","id":"5902b753c5756d72945d90b3"}' ],
  code: 'ERR' }
[2017-05-04 15:38:05.881] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:38:05.892] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:38:09.297] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:38:09.309] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:38:09.331] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:38:09.348] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:38:09.439] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:38:09.452] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:38:09.313] [INFO] app - Redis client default is ready {}
[2017-05-04 15:38:09.499] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:38:14.870] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:38:14.885] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:38:14.888] [INFO] app - Redis client default is ready {}
[2017-05-04 15:38:15.040] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:38:49.490] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:38:49.501] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:38:49.504] [INFO] app - Redis client default is ready {}
[2017-05-04 15:38:49.700] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:39:02.368] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:39:02.419] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:39:02.430] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:39:02.451] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:39:02.643] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:39:02.702] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:39:02.426] [INFO] app - Redis client default is ready {}
[2017-05-04 15:39:02.857] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:39:04.445] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:39:04.458] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:39:08.322] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:39:08.337] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:39:08.340] [INFO] app - Redis client default is ready {}
[2017-05-04 15:39:08.491] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:39:10.047] [DEBUG] app - 2017-5-4 15:39:10 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:39:10.058] [WARN] console - this is a logger middleware.
[2017-05-04 15:39:10.095] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type InternalCache.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:39:10.095] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:39:10.095] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Object.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:39:10.095] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type NativeConnection.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:39:10.095] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:39:10.096] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type ObjectID.
This is converted to "5902b753c5756d72945d90b3" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:39:10.096] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Schema.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:39:10.096] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type NativeCollection.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:39:10.097] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Object.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:39:10.097] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Object.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:39:10.101] [WARN] console - { _id: 5902b753c5756d72945d90b3,
  updatedAt: 2017-04-28T03:30:27.167Z,
  createdAt: 2017-04-28T03:30:27.167Z,
  username: '222',
  __v: 0 }
[2017-05-04 15:39:52.442] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:39:52.460] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:39:52.464] [INFO] app - Redis client default is ready {}
[2017-05-04 15:39:52.633] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:39:54.887] [DEBUG] app - 2017-5-4 15:39:54 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:39:54.891] [WARN] console - this is a logger middleware.
[2017-05-04 15:40:02.316] [DEBUG] app - 2017-5-4 15:40:02 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:40:02.318] [WARN] console - this is a logger middleware.
[2017-05-04 15:40:02.681] [DEBUG] app - 2017-5-4 15:40:02 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:40:02.682] [WARN] console - this is a logger middleware.
[2017-05-04 15:40:02.842] [DEBUG] app - 2017-5-4 15:40:02 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:40:02.843] [WARN] console - this is a logger middleware.
[2017-05-04 15:40:21.440] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:40:21.456] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:40:21.461] [INFO] app - Redis client default is ready {}
[2017-05-04 15:40:21.659] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:40:24.057] [DEBUG] app - 2017-5-4 15:40:24 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:40:24.060] [WARN] console - this is a logger middleware.
[2017-05-04 15:40:24.091] [WARN] console - { depopulate: 'function (path) {\n  var populatedIds = this.populated(path);\n  if (!populatedIds) {\n    return;\n  }\n  delete this.$__.populated[path];\n  this.set(path, populatedIds);\n  return this;\n}',
  equals: 'function (doc) {\n  if (!doc) {\n    return false;\n  }\n\n  var tid = this.get(\'_id\');\n  var docid = doc.get ? doc.get(\'_id\') : doc;\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals\n      ? tid.equals(docid)\n      : tid === docid;\n}',
  _posts: '[object Object]',
  '$__getAllSubdocs': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  function docReducer(seed, path) {\n    var val = this[path];\n\n    if (val instanceof Embedded) {\n      seed.push(val);\n    }\n    if (val && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(docReducer.bind(val._doc), seed);\n      seed.push(val);\n    }\n    if (val && val.isMongooseDocumentArray) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n        seed = Object.keys(doc._doc).reduce(docReducer.bind(doc._doc), seed);\n      });\n    } else if (val instanceof Document && val.$__isNested) {\n      if (val) {\n        seed = Object.keys(val).reduce(docReducer.bind(val), seed);\n      }\n    }\n    return seed;\n  }\n\n  var subDocs = Object.keys(this._doc).reduce(docReducer.bind(this), []);\n\n  return subDocs;\n}',
  removeListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  '$__original_save': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  '$__getArrayPathsToValidate': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  // validate all document arrays.\n  return this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return this.getValue(i);\n  }.bind(this))\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  }).reduce(function(seed, array) {\n    return seed.concat(array);\n  }, [])\n  .filter(function(doc) {\n    return doc;\n  });\n}',
  schema: '[object Object]',
  removeAllListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  save: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  isDirectSelected: 'function isDirectSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  removePost: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , posts = proto._posts || (proto._posts || {});\n    if (!posts[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all post callbacks for hook `name`\n      posts[name].length = 0;\n    } else {\n      posts[name] = posts[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  _lazySetupHooks: 'function (proto, methodName, errorCb) {\n    if (\'undefined\' === typeof proto[methodName].numAsyncPres) {\n      this.$hook(methodName, proto[methodName], errorCb);\n    }\n  }',
  toBSON: 'function () {\n  return this.toObject({\n    transform: false,\n    virtuals: false,\n    _skipDepopulateTopLevel: true,\n    depopulate: true,\n    flattenDecimals: false\n  });\n}',
  markModified: 'function (path) {\n  this.$__.activePaths.modify(path);\n}',
  on: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  increment: 'function increment() {\n  this.$__.version = VERSION_ALL;\n  return this;\n}',
  validate: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populated: 'function (path, val, options) {\n  // val and options are internal\n\n  if (val === null || val === void 0) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    var v = this.$__.populated[path];\n    if (v) {\n      return v.value;\n    }\n    return undefined;\n  }\n\n  // internal\n\n  if (val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    return this.$__.populated[path];\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = {value: val, options: options};\n  return val;\n}',
  update: 'function update() {\n  var args = utils.args(arguments);\n  args.unshift({_id: this._id});\n  return this.constructor.update.apply(this.constructor, args);\n}',
  id: '5902b753c5756d72945d90b3',
  '$__setSchema': 'function (schema) {\n  compile(schema.tree, this, undefined, schema.options);\n  this.schema = schema;\n}',
  isInit: 'function (path) {\n  return (path in this.$__.activePaths.states.init);\n}',
  '$__validate': 'function (callback) {\n  var _this = this;\n  var _complete = function() {\n    var err = _this.$__.validationError;\n    _this.$__.validationError = undefined;\n    _this.emit(\'validate\', _this);\n    _this.constructor.emit(\'validate\', _this);\n    if (err) {\n      for (var key in err.errors) {\n        // Make sure cast errors persist\n        if (!_this.__parent && err.errors[key] instanceof MongooseError.CastError) {\n          _this.invalidate(key, err.errors[key]);\n        }\n      }\n\n      return err;\n    }\n  };\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (paths.length === 0) {\n    process.nextTick(function() {\n      var error = _complete();\n      if (error) {\n        return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n          callback(error);\n        });\n      }\n      callback();\n    });\n  }\n\n  var validating = {},\n      total = 0;\n\n  var complete = function() {\n    var error = _complete();\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n    callback();\n  };\n\n  var validatePath = function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n    total++;\n\n    process.nextTick(function() {\n      var p = _this.schema.path(path);\n      if (!p) {\n        return --total || complete();\n      }\n\n      // If user marked as invalid or there was a cast error, don\'t validate\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      var val = _this.getValue(path);\n      p.doValidate(val, function(err) {\n        if (err) {\n          _this.invalidate(path, err, undefined, true);\n        }\n        --total || complete();\n      }, _this);\n    });\n  };\n\n  paths.forEach(validatePath);\n}',
  username: '222',
  db: '[object Object]',
  '$__original_validate': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  discriminators: 'undefined',
  isModified: 'function (paths) {\n  if (paths) {\n    if (!Array.isArray(paths)) {\n      paths = paths.split(\' \');\n    }\n    var modified = this.modifiedPaths();\n    var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n    var isModifiedChild = paths.some(function(path) {\n      return !!~modified.indexOf(path);\n    });\n    return isModifiedChild || paths.some(function(path) {\n      return directModifiedPaths.some(function(mod) {\n        return mod === path || path.indexOf(mod + \'.\') === 0;\n      });\n    });\n  }\n  return this.$__.activePaths.some(\'modify\');\n}',
  '$pre': 'function (name, isAsync, fn, errorCb) {\n    if (\'boolean\' !== typeof arguments[1]) {\n      errorCb = fn;\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {};\n\n    this._lazySetupHooks(proto, name, errorCb);\n\n    if (fn.isAsync = isAsync) {\n      proto[name].numAsyncPres++;\n    }\n\n    (pres[name] = pres[name] || []).push(fn);\n    return this;\n  }',
  toObject: 'function (options) {\n  return this.$toObject(options);\n}',
  '$markValid': 'function (path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n}',
  '$__buildDoc': 'function (obj, fields, skipId) {\n  var doc = {};\n  var exclude = null;\n  var keys;\n  var ki;\n  var _this = this;\n\n  // determine if this doc is a result of a query with\n  // excluded fields\n\n  if (fields && utils.getFunctionName(fields.constructor) === \'Object\') {\n    keys = Object.keys(fields);\n    ki = keys.length;\n\n    if (ki === 1 && keys[0] === \'_id\') {\n      exclude = !!fields[keys[ki]];\n    } else {\n      while (ki--) {\n        if (keys[ki] !== \'_id\' &&\n            (!fields[keys[ki]] || typeof fields[keys[ki]] !== \'object\')) {\n          exclude = !fields[keys[ki]];\n          break;\n        }\n      }\n    }\n  }\n\n  var paths = Object.keys(this.schema.paths);\n  var plen = paths.length;\n  var ii = 0;\n\n  var hasIncludedChildren = {};\n  if (exclude === false && fields) {\n    keys = Object.keys(fields);\n    for (var j = 0; j < keys.length; ++j) {\n      var parts = keys[j].split(\'.\');\n      var c = [];\n      for (var k = 0; k < parts.length; ++k) {\n        c.push(parts[k]);\n        hasIncludedChildren[c.join(\'.\')] = 1;\n      }\n    }\n  }\n\n  for (; ii < plen; ++ii) {\n    var p = paths[ii];\n\n    if (p === \'_id\') {\n      if (skipId) {\n        continue;\n      }\n      if (obj && \'_id\' in obj) {\n        continue;\n      }\n    }\n\n    var type = this.schema.paths[p];\n    var path = p.split(\'.\');\n    var len = path.length;\n    var last = len - 1;\n    var curPath = \'\';\n    var doc_ = doc;\n    var i = 0;\n    var included = false;\n\n    for (; i < len; ++i) {\n      var piece = path[i],\n          def;\n\n      curPath += (!curPath.length ? \'\' : \'.\') + piece;\n\n      // support excluding intermediary levels\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i === last) {\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          } else if (included) {\n            // selected field\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          }\n        } else {\n          def = type.getDefault(_this, false);\n          if (typeof def !== \'undefined\') {\n            doc_[piece] = def;\n            _this.$__.activePaths.default(p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  return doc;\n}',
  getValue: 'function (path) {\n  return utils.getValue(path, this._doc);\n}',
  collection: '[object Object]',
  createdAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  '$isValid': 'function (path) {\n  return !this.$__.validationError || !this.$__.validationError.errors[path];\n}',
  '$__version': 'function (where, delta) {\n  var key = this.schema.options.versionKey;\n\n  if (where === true) {\n    // this is an insert\n    if (key) this.setValue(key, delta[key] = 0);\n    return;\n  }\n\n  // updates\n\n  // only apply versioning if our versionKey was selected. else\n  // there is no way to select the correct version. we could fail\n  // fast here and force them to include the versionKey but\n  // thats a bit intrusive. can we do this automatically?\n  if (!this.isSelected(key)) {\n    return;\n  }\n\n  // $push $addToSet don\'t need the where clause set\n  if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {\n    where[key] = this.getValue(key);\n  }\n\n  if (VERSION_INC === (VERSION_INC & this.$__.version)) {\n    if (!delta.$set || typeof delta.$set[key] === \'undefined\') {\n      delta.$inc || (delta.$inc = {});\n      delta.$inc[key] = 1;\n    }\n  }\n}',
  isDirectModified: 'function (path) {\n  return (path in this.$__.activePaths.states.modify);\n}',
  '$isMongooseModelPrototype': 'true',
  modifiedPaths: 'function () {\n  var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n  return directModifiedPaths.reduce(function(list, path) {\n    var parts = path.split(\'.\');\n    return list.concat(parts.reduce(function(chains, part, i) {\n      return chains.concat(parts.slice(0, i).concat(part).join(\'.\'));\n    }, []).filter(function(chain) {\n      return (list.indexOf(chain) === -1);\n    }));\n  }, []);\n}',
  updatedAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  get: 'function (path, type) {\n  var adhoc;\n  if (type) {\n    adhoc = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  var schema = this.$__path(path) || this.schema.virtualpath(path),\n      pieces = path.split(\'.\'),\n      obj = this._doc;\n\n  for (var i = 0, l = pieces.length; i < l; i++) {\n    obj = obj === null || obj === void 0\n        ? undefined\n        : obj[pieces[i]];\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  // Check if this path is populated - don\'t apply getters if it is,\n  // because otherwise its a nested object. See gh-3357\n  if (schema && !this.populated(path)) {\n    obj = schema.applyGetters(obj, this);\n  }\n\n  return obj;\n}',
  '$__path': 'function (path) {\n  var adhocs = this.$__.adhocPaths,\n      adhocType = adhocs && adhocs[path];\n\n  if (adhocType) {\n    return adhocType;\n  }\n  return this.schema.path(path);\n}',
  listeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  '$__storeShard': 'function () {\n  // backwards compat\n  var key = this.schema.options.shardKey || this.schema.options.shardkey;\n  if (!(key && utils.getFunctionName(key.constructor) === \'Object\')) {\n    return;\n  }\n\n  var orig = this.$__.shardval = {},\n      paths = Object.keys(key),\n      len = paths.length,\n      val;\n\n  for (var i = 0; i < len; ++i) {\n    val = this.getValue(paths[i]);\n    if (isMongooseObject(val)) {\n      orig[paths[i]] = val.toObject({depopulate: true, _isNested: true});\n    } else if (val !== null && val !== undefined && val.valueOf &&\n          // Explicitly don\'t take value of dates\n        (!val.constructor || utils.getFunctionName(val.constructor) !== \'Date\')) {\n      orig[paths[i]] = val.valueOf();\n    } else {\n      orig[paths[i]] = val;\n    }\n  }\n}',
  '$__dirty': 'function () {\n  var _this = this;\n\n  var all = this.$__.activePaths.map(\'modify\', function(path) {\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  });\n\n  // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n  all = all.concat(this.$__.activePaths.map(\'default\', function(path) {\n    if (path === \'_id\' || !_this.getValue(path)) {\n      return;\n    }\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n\n  // Sort dirty paths in a flat hierarchy.\n  all.sort(function(a, b) {\n    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));\n  });\n\n  // Ignore "foo.a" if "foo" is dirty already.\n  var minimal = [],\n      lastPath,\n      top;\n\n  all.forEach(function(item) {\n    if (!item) {\n      return;\n    }\n    if (item.path.indexOf(lastPath) !== 0) {\n      lastPath = item.path + \'.\';\n      minimal.push(item);\n      top = item;\n    } else {\n      // special case for top level MongooseArrays\n      if (top.value && top.value._atomics && top.value.hasAtomics()) {\n        // the `top` array itself and a sub path of `top` are being modified.\n        // the only way to honor all of both modifications is through a $set\n        // of entire array.\n        top.value._atomics = {};\n        top.value._atomics.$set = top.value;\n      }\n    }\n  });\n\n  top = lastPath = null;\n  return minimal;\n}',
  model: 'function model(name) {\n  return this.db.model(name);\n}',
  '$isDefault': 'function (path) {\n  return (path in this.$__.activePaths.states.default);\n}',
  '$__original_remove': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  remove: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populate: 'function populate() {\n  if (arguments.length === 0) {\n    return this;\n  }\n\n  var pop = this.$__.populate || (this.$__.populate = {});\n  var args = utils.args(arguments);\n  var fn;\n\n  if (typeof args[args.length - 1] === \'function\') {\n    fn = args.pop();\n  }\n\n  // allow `doc.populate(callback)`\n  if (args.length) {\n    // use hash to remove duplicate paths\n    var res = utils.populate.apply(null, args);\n    for (var i = 0; i < res.length; ++i) {\n      pop[res[i].path] = res[i];\n    }\n  }\n\n  if (fn) {\n    var paths = utils.object.vals(pop);\n    this.$__.populate = undefined;\n    paths.__noPromise = true;\n    this.constructor.populate(this, paths, fn);\n  }\n\n  return this;\n}',
  '$__shouldModify': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  if (this.isNew) {\n    return true;\n  }\n\n  if (undefined === val && !this.isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (undefined === val && path in this.$__.activePaths.states.default) {\n    // we\'re just unsetting the default value which was never saved\n    return false;\n  }\n\n  // gh-3992: if setting a populated field to a doc, don\'t mark modified\n  // if they have the same _id\n  if (this.populated(path) &&\n      val instanceof Document &&\n      deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal || this.get(path))) {\n    return true;\n  }\n\n  if (!constructing &&\n      val !== null &&\n      val !== undefined &&\n      path in this.$__.activePaths.states.default &&\n      deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n  return false;\n}',
  '$__': '[object Object]',
  '$__fullPath': 'function (path) {\n  // overridden in SubDocuments\n  return path || \'\';\n}',
  _pres: '[object Object]',
  inspect: 'function (options) {\n  var isPOJO = options &&\n    utils.getFunctionName(options.constructor) === \'Object\';\n  var opts;\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n    opts.retainKeyOrder = true;\n  }\n  return this.toObject(opts);\n}',
  '$__reset': 'function reset() {\n  var _this = this;\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return _this.getValue(i);\n  })\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  })\n  .forEach(function(array) {\n    var i = array.length;\n    while (i--) {\n      var doc = array[i];\n      if (!doc) {\n        continue;\n      }\n      doc.$__reset();\n    }\n  });\n\n  // clear atomics\n  this.$__dirty().forEach(function(dirt) {\n    var type = dirt.value;\n    if (type && type._atomics) {\n      type._atomics = {};\n    }\n  });\n\n  // Clear \'dirty\' cache\n  this.$__.activePaths.clear(\'modify\');\n  this.$__.activePaths.clear(\'default\');\n  this.$__.validationError = undefined;\n  this.errors = undefined;\n  _this = this;\n  this.schema.requiredPaths().forEach(function(path) {\n    _this.$__.activePaths.require(path);\n  });\n\n  return this;\n}',
  init: 'function (doc, opts, fn) {\n  // do not prefix this method with $__ since its\n  // used by public hooks\n\n  if (typeof opts === \'function\') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.isNew = false;\n\n  // handle docs with populated paths\n  // If doc._id is not null or undefined\n  if (doc._id !== null && doc._id !== undefined &&\n    opts && opts.populated && opts.populated.length) {\n    var id = String(doc._id);\n    for (var i = 0; i < opts.populated.length; ++i) {\n      var item = opts.populated[i];\n      if (item.isVirtual) {\n        this.populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.populated(item.path, item._docs[id], item);\n      }\n    }\n  }\n\n  init(this, doc, this._doc);\n  this.$__storeShard();\n\n  this.emit(\'init\', this);\n  this.constructor.emit(\'init\', this);\n\n  if (fn) {\n    fn(null);\n  }\n  return this;\n}',
  setMaxListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  initializeTimestamps: 'function () {\n      if (!this.get(createdAt)) {\n        this.set(createdAt, new Date());\n      }\n      if (!this.get(updatedAt)) {\n        this.set(updatedAt, new Date());\n      }\n      return this;\n    }',
  once: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  __v: '0',
  '$toObject': 'function (options, json) {\n  var defaultOptions = {\n    transform: true,\n    json: json,\n    retainKeyOrder: this.schema.options.retainKeyOrder,\n    flattenDecimals: true\n  };\n\n  // _isNested will only be true if this is not the top level document, we\n  // should never depopulate\n  if (options && options.depopulate && options._isNested && this.$__.wasPopulated) {\n    // populated paths that we set to a document\n    return clone(this._id, options);\n  }\n\n  // When internally saving this document we always pass options,\n  // bypassing the custom schema options.\n  if (!(options && utils.getFunctionName(options.constructor) === \'Object\') ||\n      (options && options._useSchemaOptions)) {\n    if (json) {\n      options = this.schema.options.toJSON ?\n        clone(this.schema.options.toJSON) :\n        {};\n      options.json = true;\n      options._useSchemaOptions = true;\n    } else {\n      options = this.schema.options.toObject ?\n        clone(this.schema.options.toObject) :\n        {};\n      options.json = false;\n      options._useSchemaOptions = true;\n    }\n  }\n\n  for (var key in defaultOptions) {\n    if (options[key] === undefined) {\n      options[key] = defaultOptions[key];\n    }\n  }\n\n  (\'minimize\' in options) || (options.minimize = this.schema.options.minimize);\n\n  // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n  var originalTransform = options.transform;\n\n  options._isNested = true;\n\n  var ret = clone(this._doc, options) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, \'paths\', options);\n    // applyGetters for paths will add nested empty objects;\n    // if minimize is set, we need to remove them.\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || options.getters && options.virtuals !== false) {\n    applyGetters(this, ret, \'virtuals\', options);\n  }\n\n  if (options.versionKey === false && this.schema.options.versionKey) {\n    delete ret[this.schema.options.versionKey];\n  }\n\n  var transform = options.transform;\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema\'s transform and\n  // not the parent schema\'s\n  if (transform === true ||\n      (this.schema.options.toObject && transform)) {\n    var opts = options.json ? this.schema.options.toJSON : this.schema.options.toObject;\n\n    if (opts) {\n      transform = (typeof options.transform === \'function\' ? options.transform : opts.transform);\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === \'function\') {\n    var xformed = transform(this, ret, options);\n    if (typeof xformed !== \'undefined\') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n}',
  '$hook': 'function (name, fn, errorCb) {\n    if (arguments.length === 1 && typeof name === \'object\') {\n      for (var k in name) { // `name` is a hash of hookName->hookFn\n        this.$hook(k, name[k]);\n      }\n      return;\n    }\n\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {}\n      , posts = proto._posts = proto._posts || {};\n    pres[name] = pres[name] || [];\n    posts[name] = posts[name] || [];\n\n    proto[name] = function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    };\n    \n    proto[name].numAsyncPres = 0;\n\n    return this;\n  }',
  '$__set': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  var shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts,\n    schema, val, priorVal);\n  var _this = this;\n\n  if (shouldModify) {\n    this.markModified(pathToMark, val);\n\n    // handle directly setting arrays (gh-1126)\n    MongooseArray || (MongooseArray = require(\'./types/array\'));\n    if (val && val.isMongooseArray) {\n      val._registerAtomic(\'$set\', val);\n\n      // Update embedded document parent references (gh-5189)\n      if (val.isMongooseDocumentArray) {\n        val.forEach(function(item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      }\n\n      // Small hack for gh-1638: if we\'re overwriting the entire array, ignore\n      // paths that were modified before the array overwrite\n      this.$__.activePaths.forEach(function(modifiedPath) {\n        if (modifiedPath.indexOf(path + \'.\') === 0) {\n          _this.$__.activePaths.ignore(modifiedPath);\n        }\n      });\n    }\n  }\n\n  var obj = this._doc;\n  var i = 0;\n  var l = parts.length;\n  var cur = \'\';\n\n  for (; i < l; i++) {\n    var next = i + 1;\n    var last = next === l;\n    cur += (cur ? \'.\' + parts[i] : parts[i]);\n\n    if (last) {\n      obj[parts[i]] = val;\n    } else {\n      if (obj[parts[i]] && utils.getFunctionName(obj[parts[i]].constructor) === \'Object\') {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        this.set(cur, {});\n        obj = obj[parts[i]];\n      }\n    }\n  }\n}',
  isNew: 'false',
  unmarkModified: 'function (path) {\n  this.$__.activePaths.init(path);\n}',
  validateSync: 'function (pathsToValidate) {\n  var _this = this;\n\n  if (typeof pathsToValidate === \'string\') {\n    pathsToValidate = pathsToValidate.split(\' \');\n  }\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (pathsToValidate && pathsToValidate.length) {\n    var tmp = [];\n    for (var i = 0; i < paths.length; ++i) {\n      if (pathsToValidate.indexOf(paths[i]) !== -1) {\n        tmp.push(paths[i]);\n      }\n    }\n    paths = tmp;\n  }\n\n  var validating = {};\n\n  paths.forEach(function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n\n    var p = _this.schema.path(path);\n    if (!p) {\n      return;\n    }\n    if (!_this.$isValid(path)) {\n      return;\n    }\n\n    var val = _this.getValue(path);\n    var err = p.doValidateSync(val, _this);\n    if (err) {\n      _this.invalidate(path, err, undefined, true);\n    }\n  });\n\n  var err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n  _this.emit(\'validate\', _this);\n  _this.constructor.emit(\'validate\', _this);\n\n  if (err) {\n    for (var key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n}',
  errors: 'undefined',
  addListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  setValue: 'function (path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n}',
  '$__where': 'function _where(where) {\n  where || (where = {});\n\n  var paths,\n      len;\n\n  if (!where._id) {\n    where._id = this._doc._id;\n  }\n\n  if (this.$__.shardval) {\n    paths = Object.keys(this.$__.shardval);\n    len = paths.length;\n\n    for (var i = 0; i < len; ++i) {\n      where[paths[i]] = this.$__.shardval[paths[i]];\n    }\n  }\n\n  if (this._doc._id == null) {\n    return new Error(\'No _id found on document!\');\n  }\n\n  return where;\n}',
  invalidate: 'function (path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === \'string\') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || \'user defined\',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.errors[path] = err;\n  return this.$__.validationError;\n}',
  _doc: '[object Object]',
  execPopulate: 'function () {\n  var Promise = PromiseProvider.get();\n  var _this = this;\n  return new Promise.ES6(function(resolve, reject) {\n    _this.populate(function(error, res) {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(res);\n      }\n    });\n  });\n}',
  isSelected: 'function isSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    i = paths.length;\n    var pathDot = path + \'.\';\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n\n      if (cur.indexOf(pathDot) === 0) {\n        return inclusive || cur !== pathDot;\n      }\n\n      if (pathDot.indexOf(cur + \'.\') === 0) {\n        return inclusive;\n      }\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  _id: '5902b753c5756d72945d90b3',
  toString: 'function () {\n  return inspect(this.inspect());\n}',
  '$post': 'function (name, isAsync, fn) {\n    if (arguments.length === 2) {\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , posts = proto._posts = proto._posts || {};\n    \n    this._lazySetupHooks(proto, name);\n    (posts[name] = posts[name] || []).push(fn);\n    return this;\n  }',
  '$__handleSave': 'function (options, callback) {\n  var _this = this;\n  var i;\n  var keys;\n  var len;\n  if (!options.safe && this.schema.options.safe) {\n    options.safe = this.schema.options.safe;\n  }\n  if (typeof options.safe === \'boolean\') {\n    options.safe = null;\n  }\n\n  if (this.isNew) {\n    // send entire doc\n    var toObjectOptions = {};\n\n    toObjectOptions.retainKeyOrder = this.schema.options.retainKeyOrder;\n    toObjectOptions.depopulate = 1;\n    toObjectOptions._skipDepopulateTopLevel = true;\n    toObjectOptions.transform = false;\n    toObjectOptions.flattenDecimals = false;\n\n    var obj = this.toObject(toObjectOptions);\n\n    if (!utils.object.hasOwnProperty(obj || {}, \'_id\')) {\n      // documents must have an _id else mongoose won\'t know\n      // what to update later if more changes are made. the user\n      // wouldn\'t know what _id was generated by mongodb either\n      // nor would the ObjectId generated my mongodb necessarily\n      // match the schema definition.\n      setTimeout(function() {\n        callback(new Error(\'document must have an _id before saving\'));\n      }, 0);\n      return;\n    }\n\n    this.$__version(true, obj);\n    this.collection.insert(obj, options.safe, function(err, ret) {\n      if (err) {\n        _this.isNew = true;\n        _this.emit(\'isNew\', true);\n        _this.constructor.emit(\'isNew\', true);\n\n        callback(err);\n        return;\n      }\n\n      callback(null, ret);\n    });\n    this.$__reset();\n    this.isNew = false;\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n    // Make it possible to retry the insert\n    this.$__.inserting = true;\n  } else {\n    // Make sure we don\'t treat it as a new object on error,\n    // since it already exists\n    this.$__.inserting = false;\n\n    var delta = this.$__delta();\n\n    if (delta) {\n      if (delta instanceof Error) {\n        callback(delta);\n        return;\n      }\n\n      var where = this.$__where(delta[0]);\n      if (where instanceof Error) {\n        callback(where);\n        return;\n      }\n\n      if (this.$where) {\n        keys = Object.keys(this.$where);\n        len = keys.length;\n        for (i = 0; i < len; ++i) {\n          where[keys[i]] = this.$where[keys[i]];\n        }\n      }\n\n      this.collection.update(where, delta[1], options.safe, function(err, ret) {\n        if (err) {\n          callback(err);\n          return;\n        }\n        ret.$where = where;\n        callback(null, ret);\n      });\n    } else {\n      this.$__reset();\n      callback();\n      return;\n    }\n\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n  }\n}',
  '$ignore': 'function (path) {\n  this.$__.activePaths.ignore(path);\n}',
  emit: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  removePre: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , pres = proto._pres || (proto._pres || {});\n    if (!pres[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all pre callbacks for hook `name`\n      pres[name].length = 0;\n    } else {\n      pres[name] = pres[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  toJSON: 'function (options) {\n  return this.$toObject(options, true);\n}',
  '$__handleReject': 'function handleReject(err) {\n  // emit on the Model if listening\n  if (this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  } else if (this.constructor.listeners && this.constructor.listeners(\'error\').length) {\n    this.constructor.emit(\'error\', err);\n  } else if (this.listeners && this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  }\n}',
  set: 'function (path, val, type, options) {\n  if (type && utils.getFunctionName(type.constructor) === \'Object\') {\n    options = type;\n    type = undefined;\n  }\n\n  var merge = options && options.merge,\n      adhoc = type && type !== true,\n      constructing = type === true,\n      adhocs;\n\n  var strict = options && \'strict\' in options\n      ? options.strict\n      : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  if (typeof path !== \'string\') {\n    // new Document({ key: val })\n\n    if (path === null || path === void 0) {\n      var _ = path;\n      path = val;\n      val = _;\n    } else {\n      var prefix = val\n          ? val + \'.\'\n          : \'\';\n\n      if (path instanceof Document) {\n        if (path.$__isNested) {\n          path = path.toObject();\n        } else {\n          path = path._doc;\n        }\n      }\n\n      var keys = Object.keys(path);\n      var len = keys.length;\n      var i = 0;\n      var pathtype;\n      var key;\n\n      if (len === 0 && !this.schema.options.minimize) {\n        if (val) {\n          this.set(val, {});\n        }\n        return this;\n      }\n\n      if (this.schema.options.retainKeyOrder) {\n        while (i < len) {\n          _handleIndex.call(this, i++);\n        }\n      } else {\n        while (len--) {\n          _handleIndex.call(this, len);\n        }\n      }\n\n      return this;\n    }\n  }\n\n  function _handleIndex(i) {\n    key = keys[i];\n    var pathName = prefix + key;\n    pathtype = this.schema.pathType(pathName);\n\n    if (path[key] !== null\n        && path[key] !== void 0\n          // need to know if plain object - no Buffer, ObjectId, ref, etc\n        && utils.isObject(path[key])\n        && (!path[key].constructor || utils.getFunctionName(path[key].constructor) === \'Object\')\n        && pathtype !== \'virtual\'\n        && pathtype !== \'real\'\n        && !(this.$__path(pathName) instanceof MixedSchema)\n        && !(this.schema.paths[pathName] &&\n        this.schema.paths[pathName].options &&\n        this.schema.paths[pathName].options.ref)) {\n      this.set(path[key], prefix + key, constructing);\n    } else if (strict) {\n      // Don\'t overwrite defaults with undefined keys (gh-3981)\n      if (constructing && path[key] === void 0 &&\n          this.get(key) !== void 0) {\n        return;\n      }\n\n      if (pathtype === \'real\' || pathtype === \'virtual\') {\n        // Check for setting single embedded schema to document (gh-3535)\n        var p = path[key];\n        if (this.schema.paths[pathName] &&\n            this.schema.paths[pathName].$isSingleNested &&\n            path[key] instanceof Document) {\n          p = p.toObject({ virtuals: false, transform: false });\n        }\n        this.set(prefix + key, p, constructing);\n      } else if (pathtype === \'nested\' && path[key] instanceof Document) {\n        this.set(prefix + key,\n            path[key].toObject({transform: false}), constructing);\n      } else if (strict === \'throw\') {\n        if (pathtype === \'nested\') {\n          throw new ObjectExpectedError(key, path[key]);\n        } else {\n          throw new StrictModeError(key);\n        }\n      }\n    } else if (path[key] !== void 0) {\n      this.set(prefix + key, path[key], constructing);\n    }\n  }\n\n  var pathType = this.schema.pathType(path);\n  if (pathType === \'nested\' && val) {\n    if (utils.isObject(val) &&\n        (!val.constructor || utils.getFunctionName(val.constructor) === \'Object\')) {\n      if (!merge) {\n        this.setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      }\n\n      if (Object.keys(val).length === 0) {\n        this.setValue(path, {});\n        this.markModified(path);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        this.set(val, path, constructing);\n      }\n      return this;\n    }\n    this.invalidate(path, new MongooseError.CastError(\'Object\', val, path));\n    return this;\n  }\n\n  var schema;\n  var parts = path.split(\'.\');\n\n  if (pathType === \'adhocOrUndefined\' && strict) {\n    // check for roots that are Mixed types\n    var mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      var subpath = parts.slice(0, i + 1).join(\'.\');\n      schema = this.schema.path(subpath);\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n\n      // If path is underneath a virtual, bypass everything and just set it.\n      if (i + 1 < parts.length && this.schema.pathType(subpath) === \'virtual\') {\n        mpath.set(path, val, this);\n        return this;\n      }\n    }\n\n    if (!mixed) {\n      if (strict === \'throw\') {\n        throw new StrictModeError(path);\n      }\n      return this;\n    }\n  } else if (pathType === \'virtual\') {\n    schema = this.schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  var pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: "LEFT_SUBFIELD only supports Object"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    for (i = 0; i < parts.length; ++i) {\n      subpath = parts.slice(0, i + 1).join(\'.\');\n      if (this.isDirectModified(subpath) // earlier prefixes that are already\n            // marked as dirty have precedence\n          || this.get(subpath) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n\n  // if this doc is being constructed we should not trigger getters\n  var priorVal = constructing\n      ? undefined\n      : this.getValue(path);\n\n  if (!schema) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n    return this;\n  }\n\n  var shouldSet = true;\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    var didPopulate = false;\n    if (schema.options &&\n        schema.options.ref &&\n        val instanceof Document &&\n        (schema.options.ref === val.constructor.modelName || schema.options.ref === val.constructor.baseModelName)) {\n      if (this.ownerDocument) {\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val._id, {model: val.constructor});\n      } else {\n        this.populated(path, val._id, {model: val.constructor});\n      }\n      didPopulate = true;\n    }\n\n    var popOpts;\n    if (schema.options &&\n        Array.isArray(schema.options.type) &&\n        schema.options.type.length &&\n        schema.options.type[0].ref &&\n        Array.isArray(val) &&\n        val.length > 0 &&\n        val[0] instanceof Document &&\n        val[0].constructor.modelName &&\n        (schema.options.type[0].ref === val[0].constructor.baseModelName || schema.options.type[0].ref === val[0].constructor.modelName)) {\n      if (this.ownerDocument) {\n        popOpts = { model: val[0].constructor };\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val.map(function(v) { return v._id; }), popOpts);\n      } else {\n        popOpts = { model: val[0].constructor };\n        this.populated(path, val.map(function(v) { return v._id; }), popOpts);\n      }\n      didPopulate = true;\n    }\n    val = schema.applySetters(val, this, false, priorVal);\n\n    if (!didPopulate && this.$__.populated) {\n      delete this.$__.populated[path];\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    this.invalidate(path,\n      new MongooseError.CastError(schema.instance, val, path, e));\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n}',
  '$__delta': 'function () {\n  var dirty = this.$__dirty();\n  if (!dirty.length && VERSION_ALL !== this.$__.version) return;\n\n  var where = {},\n      delta = {},\n      len = dirty.length,\n      divergent = [],\n      d = 0;\n\n  where._id = this._doc._id;\n  if (where._id.toObject) {\n    where._id = where._id.toObject({ transform: false, depopulate: true });\n  }\n\n  for (; d < len; ++d) {\n    var data = dirty[d];\n    var value = data.value;\n\n    var match = checkDivergentArray(this, data.path, value);\n    if (match) {\n      divergent.push(match);\n      continue;\n    }\n\n    var pop = this.populated(data.path, true);\n    if (!pop && this.$__.selected) {\n      // If any array was selected using an $elemMatch projection, we alter the path and where clause\n      // NOTE: MongoDB only supports projected $elemMatch on top level array.\n      var pathSplit = data.path.split(\'.\');\n      var top = pathSplit[0];\n      if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {\n        // If the selected array entry was modified\n        if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === \'undefined\') {\n          where[top] = this.$__.selected[top];\n          pathSplit[1] = \'$\';\n          data.path = pathSplit.join(\'.\');\n        }\n        // if the selected array was modified in any other way throw an error\n        else {\n          divergent.push(data.path);\n          continue;\n        }\n      }\n    }\n\n    if (divergent.length) continue;\n\n    if (undefined === value) {\n      operand(this, where, delta, data, 1, \'$unset\');\n    } else if (value === null) {\n      operand(this, where, delta, data, null);\n    } else if (value._path && value._atomics) {\n      // arrays and other custom types (support plugins etc)\n      handleAtomics(this, where, delta, data, value);\n    } else if (value._path && Buffer.isBuffer(value)) {\n      // MongooseBuffer\n      value = value.toObject();\n      operand(this, where, delta, data, value);\n    } else {\n      value = utils.clone(value, {depopulate: 1, _isNested: true});\n      operand(this, where, delta, data, value);\n    }\n  }\n\n  if (divergent.length) {\n    return new DivergentArrayError(divergent);\n  }\n\n  if (this.$__.version) {\n    this.$__version(where, delta);\n  }\n\n  return [where, delta];\n}',
  '$__save': 'function (options, callback) {\n  var _this = this;\n\n  _this.$__handleSave(options, function(error, result) {\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.$__reset();\n    _this.$__storeShard();\n\n    var numAffected = 0;\n    if (result) {\n      if (Array.isArray(result)) {\n        numAffected = result.length;\n      } else if (result.result && result.result.n !== undefined) {\n        numAffected = result.result.n;\n      } else if (result.result && result.result.nModified !== undefined) {\n        numAffected = result.result.nModified;\n      } else {\n        numAffected = result;\n      }\n    }\n\n    // was this an update that required a version bump?\n    if (_this.$__.version && !_this.$__.inserting) {\n      var doIncrement = VERSION_INC === (VERSION_INC & _this.$__.version);\n      _this.$__.version = undefined;\n\n      if (numAffected <= 0) {\n        // the update failed. pass an error back\n        var err = new VersionError(_this);\n        return callback(err);\n      }\n\n      // increment version if was successful\n      if (doIncrement) {\n        var key = _this.schema.options.versionKey;\n        var version = _this.getValue(key) | 0;\n        _this.setValue(key, version + 1);\n      }\n    }\n\n    if (_this.schema.options &&\n        _this.schema.options.saveErrorIfNotFound &&\n        numAffected <= 0) {\n      error = new DocumentNotFoundError(result.$where);\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.emit(\'save\', _this, numAffected);\n    _this.constructor.emit(\'save\', _this, numAffected);\n    callback(null, _this, numAffected);\n  });\n}' }
[2017-05-04 15:41:13.029] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:41:13.053] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:41:13.059] [INFO] app - Redis client default is ready {}
[2017-05-04 15:41:13.244] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:41:18.693] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:41:18.708] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:41:18.712] [INFO] app - Redis client default is ready {}
[2017-05-04 15:41:18.898] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:41:20.560] [DEBUG] app - 2017-5-4 15:41:20 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:41:20.566] [WARN] console - this is a logger middleware.
[2017-05-04 15:41:20.589] [WARN] console - { depopulate: 'function (path) {\n  var populatedIds = this.populated(path);\n  if (!populatedIds) {\n    return;\n  }\n  delete this.$__.populated[path];\n  this.set(path, populatedIds);\n  return this;\n}',
  equals: 'function (doc) {\n  if (!doc) {\n    return false;\n  }\n\n  var tid = this.get(\'_id\');\n  var docid = doc.get ? doc.get(\'_id\') : doc;\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals\n      ? tid.equals(docid)\n      : tid === docid;\n}',
  _posts: '[object Object]',
  '$__getAllSubdocs': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  function docReducer(seed, path) {\n    var val = this[path];\n\n    if (val instanceof Embedded) {\n      seed.push(val);\n    }\n    if (val && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(docReducer.bind(val._doc), seed);\n      seed.push(val);\n    }\n    if (val && val.isMongooseDocumentArray) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n        seed = Object.keys(doc._doc).reduce(docReducer.bind(doc._doc), seed);\n      });\n    } else if (val instanceof Document && val.$__isNested) {\n      if (val) {\n        seed = Object.keys(val).reduce(docReducer.bind(val), seed);\n      }\n    }\n    return seed;\n  }\n\n  var subDocs = Object.keys(this._doc).reduce(docReducer.bind(this), []);\n\n  return subDocs;\n}',
  removeListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  '$__original_save': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  '$__getArrayPathsToValidate': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  // validate all document arrays.\n  return this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return this.getValue(i);\n  }.bind(this))\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  }).reduce(function(seed, array) {\n    return seed.concat(array);\n  }, [])\n  .filter(function(doc) {\n    return doc;\n  });\n}',
  schema: '[object Object]',
  removeAllListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  save: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  isDirectSelected: 'function isDirectSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  removePost: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , posts = proto._posts || (proto._posts || {});\n    if (!posts[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all post callbacks for hook `name`\n      posts[name].length = 0;\n    } else {\n      posts[name] = posts[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  _lazySetupHooks: 'function (proto, methodName, errorCb) {\n    if (\'undefined\' === typeof proto[methodName].numAsyncPres) {\n      this.$hook(methodName, proto[methodName], errorCb);\n    }\n  }',
  toBSON: 'function () {\n  return this.toObject({\n    transform: false,\n    virtuals: false,\n    _skipDepopulateTopLevel: true,\n    depopulate: true,\n    flattenDecimals: false\n  });\n}',
  markModified: 'function (path) {\n  this.$__.activePaths.modify(path);\n}',
  on: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  increment: 'function increment() {\n  this.$__.version = VERSION_ALL;\n  return this;\n}',
  validate: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populated: 'function (path, val, options) {\n  // val and options are internal\n\n  if (val === null || val === void 0) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    var v = this.$__.populated[path];\n    if (v) {\n      return v.value;\n    }\n    return undefined;\n  }\n\n  // internal\n\n  if (val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    return this.$__.populated[path];\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = {value: val, options: options};\n  return val;\n}',
  update: 'function update() {\n  var args = utils.args(arguments);\n  args.unshift({_id: this._id});\n  return this.constructor.update.apply(this.constructor, args);\n}',
  id: '5902b753c5756d72945d90b3',
  '$__setSchema': 'function (schema) {\n  compile(schema.tree, this, undefined, schema.options);\n  this.schema = schema;\n}',
  isInit: 'function (path) {\n  return (path in this.$__.activePaths.states.init);\n}',
  '$__validate': 'function (callback) {\n  var _this = this;\n  var _complete = function() {\n    var err = _this.$__.validationError;\n    _this.$__.validationError = undefined;\n    _this.emit(\'validate\', _this);\n    _this.constructor.emit(\'validate\', _this);\n    if (err) {\n      for (var key in err.errors) {\n        // Make sure cast errors persist\n        if (!_this.__parent && err.errors[key] instanceof MongooseError.CastError) {\n          _this.invalidate(key, err.errors[key]);\n        }\n      }\n\n      return err;\n    }\n  };\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (paths.length === 0) {\n    process.nextTick(function() {\n      var error = _complete();\n      if (error) {\n        return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n          callback(error);\n        });\n      }\n      callback();\n    });\n  }\n\n  var validating = {},\n      total = 0;\n\n  var complete = function() {\n    var error = _complete();\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n    callback();\n  };\n\n  var validatePath = function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n    total++;\n\n    process.nextTick(function() {\n      var p = _this.schema.path(path);\n      if (!p) {\n        return --total || complete();\n      }\n\n      // If user marked as invalid or there was a cast error, don\'t validate\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      var val = _this.getValue(path);\n      p.doValidate(val, function(err) {\n        if (err) {\n          _this.invalidate(path, err, undefined, true);\n        }\n        --total || complete();\n      }, _this);\n    });\n  };\n\n  paths.forEach(validatePath);\n}',
  username: '222',
  db: '[object Object]',
  '$__original_validate': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  discriminators: 'undefined',
  isModified: 'function (paths) {\n  if (paths) {\n    if (!Array.isArray(paths)) {\n      paths = paths.split(\' \');\n    }\n    var modified = this.modifiedPaths();\n    var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n    var isModifiedChild = paths.some(function(path) {\n      return !!~modified.indexOf(path);\n    });\n    return isModifiedChild || paths.some(function(path) {\n      return directModifiedPaths.some(function(mod) {\n        return mod === path || path.indexOf(mod + \'.\') === 0;\n      });\n    });\n  }\n  return this.$__.activePaths.some(\'modify\');\n}',
  '$pre': 'function (name, isAsync, fn, errorCb) {\n    if (\'boolean\' !== typeof arguments[1]) {\n      errorCb = fn;\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {};\n\n    this._lazySetupHooks(proto, name, errorCb);\n\n    if (fn.isAsync = isAsync) {\n      proto[name].numAsyncPres++;\n    }\n\n    (pres[name] = pres[name] || []).push(fn);\n    return this;\n  }',
  toObject: 'function (options) {\n  return this.$toObject(options);\n}',
  '$markValid': 'function (path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n}',
  '$__buildDoc': 'function (obj, fields, skipId) {\n  var doc = {};\n  var exclude = null;\n  var keys;\n  var ki;\n  var _this = this;\n\n  // determine if this doc is a result of a query with\n  // excluded fields\n\n  if (fields && utils.getFunctionName(fields.constructor) === \'Object\') {\n    keys = Object.keys(fields);\n    ki = keys.length;\n\n    if (ki === 1 && keys[0] === \'_id\') {\n      exclude = !!fields[keys[ki]];\n    } else {\n      while (ki--) {\n        if (keys[ki] !== \'_id\' &&\n            (!fields[keys[ki]] || typeof fields[keys[ki]] !== \'object\')) {\n          exclude = !fields[keys[ki]];\n          break;\n        }\n      }\n    }\n  }\n\n  var paths = Object.keys(this.schema.paths);\n  var plen = paths.length;\n  var ii = 0;\n\n  var hasIncludedChildren = {};\n  if (exclude === false && fields) {\n    keys = Object.keys(fields);\n    for (var j = 0; j < keys.length; ++j) {\n      var parts = keys[j].split(\'.\');\n      var c = [];\n      for (var k = 0; k < parts.length; ++k) {\n        c.push(parts[k]);\n        hasIncludedChildren[c.join(\'.\')] = 1;\n      }\n    }\n  }\n\n  for (; ii < plen; ++ii) {\n    var p = paths[ii];\n\n    if (p === \'_id\') {\n      if (skipId) {\n        continue;\n      }\n      if (obj && \'_id\' in obj) {\n        continue;\n      }\n    }\n\n    var type = this.schema.paths[p];\n    var path = p.split(\'.\');\n    var len = path.length;\n    var last = len - 1;\n    var curPath = \'\';\n    var doc_ = doc;\n    var i = 0;\n    var included = false;\n\n    for (; i < len; ++i) {\n      var piece = path[i],\n          def;\n\n      curPath += (!curPath.length ? \'\' : \'.\') + piece;\n\n      // support excluding intermediary levels\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i === last) {\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          } else if (included) {\n            // selected field\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          }\n        } else {\n          def = type.getDefault(_this, false);\n          if (typeof def !== \'undefined\') {\n            doc_[piece] = def;\n            _this.$__.activePaths.default(p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  return doc;\n}',
  getValue: 'function (path) {\n  return utils.getValue(path, this._doc);\n}',
  collection: '[object Object]',
  createdAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  '$isValid': 'function (path) {\n  return !this.$__.validationError || !this.$__.validationError.errors[path];\n}',
  '$__version': 'function (where, delta) {\n  var key = this.schema.options.versionKey;\n\n  if (where === true) {\n    // this is an insert\n    if (key) this.setValue(key, delta[key] = 0);\n    return;\n  }\n\n  // updates\n\n  // only apply versioning if our versionKey was selected. else\n  // there is no way to select the correct version. we could fail\n  // fast here and force them to include the versionKey but\n  // thats a bit intrusive. can we do this automatically?\n  if (!this.isSelected(key)) {\n    return;\n  }\n\n  // $push $addToSet don\'t need the where clause set\n  if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {\n    where[key] = this.getValue(key);\n  }\n\n  if (VERSION_INC === (VERSION_INC & this.$__.version)) {\n    if (!delta.$set || typeof delta.$set[key] === \'undefined\') {\n      delta.$inc || (delta.$inc = {});\n      delta.$inc[key] = 1;\n    }\n  }\n}',
  isDirectModified: 'function (path) {\n  return (path in this.$__.activePaths.states.modify);\n}',
  '$isMongooseModelPrototype': 'true',
  modifiedPaths: 'function () {\n  var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n  return directModifiedPaths.reduce(function(list, path) {\n    var parts = path.split(\'.\');\n    return list.concat(parts.reduce(function(chains, part, i) {\n      return chains.concat(parts.slice(0, i).concat(part).join(\'.\'));\n    }, []).filter(function(chain) {\n      return (list.indexOf(chain) === -1);\n    }));\n  }, []);\n}',
  updatedAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  get: 'function (path, type) {\n  var adhoc;\n  if (type) {\n    adhoc = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  var schema = this.$__path(path) || this.schema.virtualpath(path),\n      pieces = path.split(\'.\'),\n      obj = this._doc;\n\n  for (var i = 0, l = pieces.length; i < l; i++) {\n    obj = obj === null || obj === void 0\n        ? undefined\n        : obj[pieces[i]];\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  // Check if this path is populated - don\'t apply getters if it is,\n  // because otherwise its a nested object. See gh-3357\n  if (schema && !this.populated(path)) {\n    obj = schema.applyGetters(obj, this);\n  }\n\n  return obj;\n}',
  '$__path': 'function (path) {\n  var adhocs = this.$__.adhocPaths,\n      adhocType = adhocs && adhocs[path];\n\n  if (adhocType) {\n    return adhocType;\n  }\n  return this.schema.path(path);\n}',
  listeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  '$__storeShard': 'function () {\n  // backwards compat\n  var key = this.schema.options.shardKey || this.schema.options.shardkey;\n  if (!(key && utils.getFunctionName(key.constructor) === \'Object\')) {\n    return;\n  }\n\n  var orig = this.$__.shardval = {},\n      paths = Object.keys(key),\n      len = paths.length,\n      val;\n\n  for (var i = 0; i < len; ++i) {\n    val = this.getValue(paths[i]);\n    if (isMongooseObject(val)) {\n      orig[paths[i]] = val.toObject({depopulate: true, _isNested: true});\n    } else if (val !== null && val !== undefined && val.valueOf &&\n          // Explicitly don\'t take value of dates\n        (!val.constructor || utils.getFunctionName(val.constructor) !== \'Date\')) {\n      orig[paths[i]] = val.valueOf();\n    } else {\n      orig[paths[i]] = val;\n    }\n  }\n}',
  '$__dirty': 'function () {\n  var _this = this;\n\n  var all = this.$__.activePaths.map(\'modify\', function(path) {\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  });\n\n  // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n  all = all.concat(this.$__.activePaths.map(\'default\', function(path) {\n    if (path === \'_id\' || !_this.getValue(path)) {\n      return;\n    }\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n\n  // Sort dirty paths in a flat hierarchy.\n  all.sort(function(a, b) {\n    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));\n  });\n\n  // Ignore "foo.a" if "foo" is dirty already.\n  var minimal = [],\n      lastPath,\n      top;\n\n  all.forEach(function(item) {\n    if (!item) {\n      return;\n    }\n    if (item.path.indexOf(lastPath) !== 0) {\n      lastPath = item.path + \'.\';\n      minimal.push(item);\n      top = item;\n    } else {\n      // special case for top level MongooseArrays\n      if (top.value && top.value._atomics && top.value.hasAtomics()) {\n        // the `top` array itself and a sub path of `top` are being modified.\n        // the only way to honor all of both modifications is through a $set\n        // of entire array.\n        top.value._atomics = {};\n        top.value._atomics.$set = top.value;\n      }\n    }\n  });\n\n  top = lastPath = null;\n  return minimal;\n}',
  model: 'function model(name) {\n  return this.db.model(name);\n}',
  '$isDefault': 'function (path) {\n  return (path in this.$__.activePaths.states.default);\n}',
  '$__original_remove': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  remove: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populate: 'function populate() {\n  if (arguments.length === 0) {\n    return this;\n  }\n\n  var pop = this.$__.populate || (this.$__.populate = {});\n  var args = utils.args(arguments);\n  var fn;\n\n  if (typeof args[args.length - 1] === \'function\') {\n    fn = args.pop();\n  }\n\n  // allow `doc.populate(callback)`\n  if (args.length) {\n    // use hash to remove duplicate paths\n    var res = utils.populate.apply(null, args);\n    for (var i = 0; i < res.length; ++i) {\n      pop[res[i].path] = res[i];\n    }\n  }\n\n  if (fn) {\n    var paths = utils.object.vals(pop);\n    this.$__.populate = undefined;\n    paths.__noPromise = true;\n    this.constructor.populate(this, paths, fn);\n  }\n\n  return this;\n}',
  '$__shouldModify': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  if (this.isNew) {\n    return true;\n  }\n\n  if (undefined === val && !this.isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (undefined === val && path in this.$__.activePaths.states.default) {\n    // we\'re just unsetting the default value which was never saved\n    return false;\n  }\n\n  // gh-3992: if setting a populated field to a doc, don\'t mark modified\n  // if they have the same _id\n  if (this.populated(path) &&\n      val instanceof Document &&\n      deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal || this.get(path))) {\n    return true;\n  }\n\n  if (!constructing &&\n      val !== null &&\n      val !== undefined &&\n      path in this.$__.activePaths.states.default &&\n      deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n  return false;\n}',
  '$__': '[object Object]',
  '$__fullPath': 'function (path) {\n  // overridden in SubDocuments\n  return path || \'\';\n}',
  _pres: '[object Object]',
  inspect: 'function (options) {\n  var isPOJO = options &&\n    utils.getFunctionName(options.constructor) === \'Object\';\n  var opts;\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n    opts.retainKeyOrder = true;\n  }\n  return this.toObject(opts);\n}',
  '$__reset': 'function reset() {\n  var _this = this;\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return _this.getValue(i);\n  })\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  })\n  .forEach(function(array) {\n    var i = array.length;\n    while (i--) {\n      var doc = array[i];\n      if (!doc) {\n        continue;\n      }\n      doc.$__reset();\n    }\n  });\n\n  // clear atomics\n  this.$__dirty().forEach(function(dirt) {\n    var type = dirt.value;\n    if (type && type._atomics) {\n      type._atomics = {};\n    }\n  });\n\n  // Clear \'dirty\' cache\n  this.$__.activePaths.clear(\'modify\');\n  this.$__.activePaths.clear(\'default\');\n  this.$__.validationError = undefined;\n  this.errors = undefined;\n  _this = this;\n  this.schema.requiredPaths().forEach(function(path) {\n    _this.$__.activePaths.require(path);\n  });\n\n  return this;\n}',
  init: 'function (doc, opts, fn) {\n  // do not prefix this method with $__ since its\n  // used by public hooks\n\n  if (typeof opts === \'function\') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.isNew = false;\n\n  // handle docs with populated paths\n  // If doc._id is not null or undefined\n  if (doc._id !== null && doc._id !== undefined &&\n    opts && opts.populated && opts.populated.length) {\n    var id = String(doc._id);\n    for (var i = 0; i < opts.populated.length; ++i) {\n      var item = opts.populated[i];\n      if (item.isVirtual) {\n        this.populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.populated(item.path, item._docs[id], item);\n      }\n    }\n  }\n\n  init(this, doc, this._doc);\n  this.$__storeShard();\n\n  this.emit(\'init\', this);\n  this.constructor.emit(\'init\', this);\n\n  if (fn) {\n    fn(null);\n  }\n  return this;\n}',
  setMaxListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  initializeTimestamps: 'function () {\n      if (!this.get(createdAt)) {\n        this.set(createdAt, new Date());\n      }\n      if (!this.get(updatedAt)) {\n        this.set(updatedAt, new Date());\n      }\n      return this;\n    }',
  once: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  __v: '0',
  '$toObject': 'function (options, json) {\n  var defaultOptions = {\n    transform: true,\n    json: json,\n    retainKeyOrder: this.schema.options.retainKeyOrder,\n    flattenDecimals: true\n  };\n\n  // _isNested will only be true if this is not the top level document, we\n  // should never depopulate\n  if (options && options.depopulate && options._isNested && this.$__.wasPopulated) {\n    // populated paths that we set to a document\n    return clone(this._id, options);\n  }\n\n  // When internally saving this document we always pass options,\n  // bypassing the custom schema options.\n  if (!(options && utils.getFunctionName(options.constructor) === \'Object\') ||\n      (options && options._useSchemaOptions)) {\n    if (json) {\n      options = this.schema.options.toJSON ?\n        clone(this.schema.options.toJSON) :\n        {};\n      options.json = true;\n      options._useSchemaOptions = true;\n    } else {\n      options = this.schema.options.toObject ?\n        clone(this.schema.options.toObject) :\n        {};\n      options.json = false;\n      options._useSchemaOptions = true;\n    }\n  }\n\n  for (var key in defaultOptions) {\n    if (options[key] === undefined) {\n      options[key] = defaultOptions[key];\n    }\n  }\n\n  (\'minimize\' in options) || (options.minimize = this.schema.options.minimize);\n\n  // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n  var originalTransform = options.transform;\n\n  options._isNested = true;\n\n  var ret = clone(this._doc, options) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, \'paths\', options);\n    // applyGetters for paths will add nested empty objects;\n    // if minimize is set, we need to remove them.\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || options.getters && options.virtuals !== false) {\n    applyGetters(this, ret, \'virtuals\', options);\n  }\n\n  if (options.versionKey === false && this.schema.options.versionKey) {\n    delete ret[this.schema.options.versionKey];\n  }\n\n  var transform = options.transform;\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema\'s transform and\n  // not the parent schema\'s\n  if (transform === true ||\n      (this.schema.options.toObject && transform)) {\n    var opts = options.json ? this.schema.options.toJSON : this.schema.options.toObject;\n\n    if (opts) {\n      transform = (typeof options.transform === \'function\' ? options.transform : opts.transform);\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === \'function\') {\n    var xformed = transform(this, ret, options);\n    if (typeof xformed !== \'undefined\') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n}',
  '$hook': 'function (name, fn, errorCb) {\n    if (arguments.length === 1 && typeof name === \'object\') {\n      for (var k in name) { // `name` is a hash of hookName->hookFn\n        this.$hook(k, name[k]);\n      }\n      return;\n    }\n\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {}\n      , posts = proto._posts = proto._posts || {};\n    pres[name] = pres[name] || [];\n    posts[name] = posts[name] || [];\n\n    proto[name] = function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    };\n    \n    proto[name].numAsyncPres = 0;\n\n    return this;\n  }',
  '$__set': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  var shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts,\n    schema, val, priorVal);\n  var _this = this;\n\n  if (shouldModify) {\n    this.markModified(pathToMark, val);\n\n    // handle directly setting arrays (gh-1126)\n    MongooseArray || (MongooseArray = require(\'./types/array\'));\n    if (val && val.isMongooseArray) {\n      val._registerAtomic(\'$set\', val);\n\n      // Update embedded document parent references (gh-5189)\n      if (val.isMongooseDocumentArray) {\n        val.forEach(function(item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      }\n\n      // Small hack for gh-1638: if we\'re overwriting the entire array, ignore\n      // paths that were modified before the array overwrite\n      this.$__.activePaths.forEach(function(modifiedPath) {\n        if (modifiedPath.indexOf(path + \'.\') === 0) {\n          _this.$__.activePaths.ignore(modifiedPath);\n        }\n      });\n    }\n  }\n\n  var obj = this._doc;\n  var i = 0;\n  var l = parts.length;\n  var cur = \'\';\n\n  for (; i < l; i++) {\n    var next = i + 1;\n    var last = next === l;\n    cur += (cur ? \'.\' + parts[i] : parts[i]);\n\n    if (last) {\n      obj[parts[i]] = val;\n    } else {\n      if (obj[parts[i]] && utils.getFunctionName(obj[parts[i]].constructor) === \'Object\') {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        this.set(cur, {});\n        obj = obj[parts[i]];\n      }\n    }\n  }\n}',
  isNew: 'false',
  unmarkModified: 'function (path) {\n  this.$__.activePaths.init(path);\n}',
  validateSync: 'function (pathsToValidate) {\n  var _this = this;\n\n  if (typeof pathsToValidate === \'string\') {\n    pathsToValidate = pathsToValidate.split(\' \');\n  }\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (pathsToValidate && pathsToValidate.length) {\n    var tmp = [];\n    for (var i = 0; i < paths.length; ++i) {\n      if (pathsToValidate.indexOf(paths[i]) !== -1) {\n        tmp.push(paths[i]);\n      }\n    }\n    paths = tmp;\n  }\n\n  var validating = {};\n\n  paths.forEach(function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n\n    var p = _this.schema.path(path);\n    if (!p) {\n      return;\n    }\n    if (!_this.$isValid(path)) {\n      return;\n    }\n\n    var val = _this.getValue(path);\n    var err = p.doValidateSync(val, _this);\n    if (err) {\n      _this.invalidate(path, err, undefined, true);\n    }\n  });\n\n  var err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n  _this.emit(\'validate\', _this);\n  _this.constructor.emit(\'validate\', _this);\n\n  if (err) {\n    for (var key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n}',
  errors: 'undefined',
  addListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  setValue: 'function (path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n}',
  '$__where': 'function _where(where) {\n  where || (where = {});\n\n  var paths,\n      len;\n\n  if (!where._id) {\n    where._id = this._doc._id;\n  }\n\n  if (this.$__.shardval) {\n    paths = Object.keys(this.$__.shardval);\n    len = paths.length;\n\n    for (var i = 0; i < len; ++i) {\n      where[paths[i]] = this.$__.shardval[paths[i]];\n    }\n  }\n\n  if (this._doc._id == null) {\n    return new Error(\'No _id found on document!\');\n  }\n\n  return where;\n}',
  invalidate: 'function (path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === \'string\') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || \'user defined\',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.errors[path] = err;\n  return this.$__.validationError;\n}',
  _doc: '[object Object]',
  execPopulate: 'function () {\n  var Promise = PromiseProvider.get();\n  var _this = this;\n  return new Promise.ES6(function(resolve, reject) {\n    _this.populate(function(error, res) {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(res);\n      }\n    });\n  });\n}',
  isSelected: 'function isSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    i = paths.length;\n    var pathDot = path + \'.\';\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n\n      if (cur.indexOf(pathDot) === 0) {\n        return inclusive || cur !== pathDot;\n      }\n\n      if (pathDot.indexOf(cur + \'.\') === 0) {\n        return inclusive;\n      }\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  _id: '5902b753c5756d72945d90b3',
  toString: 'function () {\n  return inspect(this.inspect());\n}',
  '$post': 'function (name, isAsync, fn) {\n    if (arguments.length === 2) {\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , posts = proto._posts = proto._posts || {};\n    \n    this._lazySetupHooks(proto, name);\n    (posts[name] = posts[name] || []).push(fn);\n    return this;\n  }',
  '$__handleSave': 'function (options, callback) {\n  var _this = this;\n  var i;\n  var keys;\n  var len;\n  if (!options.safe && this.schema.options.safe) {\n    options.safe = this.schema.options.safe;\n  }\n  if (typeof options.safe === \'boolean\') {\n    options.safe = null;\n  }\n\n  if (this.isNew) {\n    // send entire doc\n    var toObjectOptions = {};\n\n    toObjectOptions.retainKeyOrder = this.schema.options.retainKeyOrder;\n    toObjectOptions.depopulate = 1;\n    toObjectOptions._skipDepopulateTopLevel = true;\n    toObjectOptions.transform = false;\n    toObjectOptions.flattenDecimals = false;\n\n    var obj = this.toObject(toObjectOptions);\n\n    if (!utils.object.hasOwnProperty(obj || {}, \'_id\')) {\n      // documents must have an _id else mongoose won\'t know\n      // what to update later if more changes are made. the user\n      // wouldn\'t know what _id was generated by mongodb either\n      // nor would the ObjectId generated my mongodb necessarily\n      // match the schema definition.\n      setTimeout(function() {\n        callback(new Error(\'document must have an _id before saving\'));\n      }, 0);\n      return;\n    }\n\n    this.$__version(true, obj);\n    this.collection.insert(obj, options.safe, function(err, ret) {\n      if (err) {\n        _this.isNew = true;\n        _this.emit(\'isNew\', true);\n        _this.constructor.emit(\'isNew\', true);\n\n        callback(err);\n        return;\n      }\n\n      callback(null, ret);\n    });\n    this.$__reset();\n    this.isNew = false;\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n    // Make it possible to retry the insert\n    this.$__.inserting = true;\n  } else {\n    // Make sure we don\'t treat it as a new object on error,\n    // since it already exists\n    this.$__.inserting = false;\n\n    var delta = this.$__delta();\n\n    if (delta) {\n      if (delta instanceof Error) {\n        callback(delta);\n        return;\n      }\n\n      var where = this.$__where(delta[0]);\n      if (where instanceof Error) {\n        callback(where);\n        return;\n      }\n\n      if (this.$where) {\n        keys = Object.keys(this.$where);\n        len = keys.length;\n        for (i = 0; i < len; ++i) {\n          where[keys[i]] = this.$where[keys[i]];\n        }\n      }\n\n      this.collection.update(where, delta[1], options.safe, function(err, ret) {\n        if (err) {\n          callback(err);\n          return;\n        }\n        ret.$where = where;\n        callback(null, ret);\n      });\n    } else {\n      this.$__reset();\n      callback();\n      return;\n    }\n\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n  }\n}',
  '$ignore': 'function (path) {\n  this.$__.activePaths.ignore(path);\n}',
  emit: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  removePre: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , pres = proto._pres || (proto._pres || {});\n    if (!pres[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all pre callbacks for hook `name`\n      pres[name].length = 0;\n    } else {\n      pres[name] = pres[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  toJSON: 'function (options) {\n  return this.$toObject(options, true);\n}',
  '$__handleReject': 'function handleReject(err) {\n  // emit on the Model if listening\n  if (this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  } else if (this.constructor.listeners && this.constructor.listeners(\'error\').length) {\n    this.constructor.emit(\'error\', err);\n  } else if (this.listeners && this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  }\n}',
  set: 'function (path, val, type, options) {\n  if (type && utils.getFunctionName(type.constructor) === \'Object\') {\n    options = type;\n    type = undefined;\n  }\n\n  var merge = options && options.merge,\n      adhoc = type && type !== true,\n      constructing = type === true,\n      adhocs;\n\n  var strict = options && \'strict\' in options\n      ? options.strict\n      : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  if (typeof path !== \'string\') {\n    // new Document({ key: val })\n\n    if (path === null || path === void 0) {\n      var _ = path;\n      path = val;\n      val = _;\n    } else {\n      var prefix = val\n          ? val + \'.\'\n          : \'\';\n\n      if (path instanceof Document) {\n        if (path.$__isNested) {\n          path = path.toObject();\n        } else {\n          path = path._doc;\n        }\n      }\n\n      var keys = Object.keys(path);\n      var len = keys.length;\n      var i = 0;\n      var pathtype;\n      var key;\n\n      if (len === 0 && !this.schema.options.minimize) {\n        if (val) {\n          this.set(val, {});\n        }\n        return this;\n      }\n\n      if (this.schema.options.retainKeyOrder) {\n        while (i < len) {\n          _handleIndex.call(this, i++);\n        }\n      } else {\n        while (len--) {\n          _handleIndex.call(this, len);\n        }\n      }\n\n      return this;\n    }\n  }\n\n  function _handleIndex(i) {\n    key = keys[i];\n    var pathName = prefix + key;\n    pathtype = this.schema.pathType(pathName);\n\n    if (path[key] !== null\n        && path[key] !== void 0\n          // need to know if plain object - no Buffer, ObjectId, ref, etc\n        && utils.isObject(path[key])\n        && (!path[key].constructor || utils.getFunctionName(path[key].constructor) === \'Object\')\n        && pathtype !== \'virtual\'\n        && pathtype !== \'real\'\n        && !(this.$__path(pathName) instanceof MixedSchema)\n        && !(this.schema.paths[pathName] &&\n        this.schema.paths[pathName].options &&\n        this.schema.paths[pathName].options.ref)) {\n      this.set(path[key], prefix + key, constructing);\n    } else if (strict) {\n      // Don\'t overwrite defaults with undefined keys (gh-3981)\n      if (constructing && path[key] === void 0 &&\n          this.get(key) !== void 0) {\n        return;\n      }\n\n      if (pathtype === \'real\' || pathtype === \'virtual\') {\n        // Check for setting single embedded schema to document (gh-3535)\n        var p = path[key];\n        if (this.schema.paths[pathName] &&\n            this.schema.paths[pathName].$isSingleNested &&\n            path[key] instanceof Document) {\n          p = p.toObject({ virtuals: false, transform: false });\n        }\n        this.set(prefix + key, p, constructing);\n      } else if (pathtype === \'nested\' && path[key] instanceof Document) {\n        this.set(prefix + key,\n            path[key].toObject({transform: false}), constructing);\n      } else if (strict === \'throw\') {\n        if (pathtype === \'nested\') {\n          throw new ObjectExpectedError(key, path[key]);\n        } else {\n          throw new StrictModeError(key);\n        }\n      }\n    } else if (path[key] !== void 0) {\n      this.set(prefix + key, path[key], constructing);\n    }\n  }\n\n  var pathType = this.schema.pathType(path);\n  if (pathType === \'nested\' && val) {\n    if (utils.isObject(val) &&\n        (!val.constructor || utils.getFunctionName(val.constructor) === \'Object\')) {\n      if (!merge) {\n        this.setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      }\n\n      if (Object.keys(val).length === 0) {\n        this.setValue(path, {});\n        this.markModified(path);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        this.set(val, path, constructing);\n      }\n      return this;\n    }\n    this.invalidate(path, new MongooseError.CastError(\'Object\', val, path));\n    return this;\n  }\n\n  var schema;\n  var parts = path.split(\'.\');\n\n  if (pathType === \'adhocOrUndefined\' && strict) {\n    // check for roots that are Mixed types\n    var mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      var subpath = parts.slice(0, i + 1).join(\'.\');\n      schema = this.schema.path(subpath);\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n\n      // If path is underneath a virtual, bypass everything and just set it.\n      if (i + 1 < parts.length && this.schema.pathType(subpath) === \'virtual\') {\n        mpath.set(path, val, this);\n        return this;\n      }\n    }\n\n    if (!mixed) {\n      if (strict === \'throw\') {\n        throw new StrictModeError(path);\n      }\n      return this;\n    }\n  } else if (pathType === \'virtual\') {\n    schema = this.schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  var pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: "LEFT_SUBFIELD only supports Object"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    for (i = 0; i < parts.length; ++i) {\n      subpath = parts.slice(0, i + 1).join(\'.\');\n      if (this.isDirectModified(subpath) // earlier prefixes that are already\n            // marked as dirty have precedence\n          || this.get(subpath) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n\n  // if this doc is being constructed we should not trigger getters\n  var priorVal = constructing\n      ? undefined\n      : this.getValue(path);\n\n  if (!schema) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n    return this;\n  }\n\n  var shouldSet = true;\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    var didPopulate = false;\n    if (schema.options &&\n        schema.options.ref &&\n        val instanceof Document &&\n        (schema.options.ref === val.constructor.modelName || schema.options.ref === val.constructor.baseModelName)) {\n      if (this.ownerDocument) {\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val._id, {model: val.constructor});\n      } else {\n        this.populated(path, val._id, {model: val.constructor});\n      }\n      didPopulate = true;\n    }\n\n    var popOpts;\n    if (schema.options &&\n        Array.isArray(schema.options.type) &&\n        schema.options.type.length &&\n        schema.options.type[0].ref &&\n        Array.isArray(val) &&\n        val.length > 0 &&\n        val[0] instanceof Document &&\n        val[0].constructor.modelName &&\n        (schema.options.type[0].ref === val[0].constructor.baseModelName || schema.options.type[0].ref === val[0].constructor.modelName)) {\n      if (this.ownerDocument) {\n        popOpts = { model: val[0].constructor };\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val.map(function(v) { return v._id; }), popOpts);\n      } else {\n        popOpts = { model: val[0].constructor };\n        this.populated(path, val.map(function(v) { return v._id; }), popOpts);\n      }\n      didPopulate = true;\n    }\n    val = schema.applySetters(val, this, false, priorVal);\n\n    if (!didPopulate && this.$__.populated) {\n      delete this.$__.populated[path];\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    this.invalidate(path,\n      new MongooseError.CastError(schema.instance, val, path, e));\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n}',
  '$__delta': 'function () {\n  var dirty = this.$__dirty();\n  if (!dirty.length && VERSION_ALL !== this.$__.version) return;\n\n  var where = {},\n      delta = {},\n      len = dirty.length,\n      divergent = [],\n      d = 0;\n\n  where._id = this._doc._id;\n  if (where._id.toObject) {\n    where._id = where._id.toObject({ transform: false, depopulate: true });\n  }\n\n  for (; d < len; ++d) {\n    var data = dirty[d];\n    var value = data.value;\n\n    var match = checkDivergentArray(this, data.path, value);\n    if (match) {\n      divergent.push(match);\n      continue;\n    }\n\n    var pop = this.populated(data.path, true);\n    if (!pop && this.$__.selected) {\n      // If any array was selected using an $elemMatch projection, we alter the path and where clause\n      // NOTE: MongoDB only supports projected $elemMatch on top level array.\n      var pathSplit = data.path.split(\'.\');\n      var top = pathSplit[0];\n      if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {\n        // If the selected array entry was modified\n        if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === \'undefined\') {\n          where[top] = this.$__.selected[top];\n          pathSplit[1] = \'$\';\n          data.path = pathSplit.join(\'.\');\n        }\n        // if the selected array was modified in any other way throw an error\n        else {\n          divergent.push(data.path);\n          continue;\n        }\n      }\n    }\n\n    if (divergent.length) continue;\n\n    if (undefined === value) {\n      operand(this, where, delta, data, 1, \'$unset\');\n    } else if (value === null) {\n      operand(this, where, delta, data, null);\n    } else if (value._path && value._atomics) {\n      // arrays and other custom types (support plugins etc)\n      handleAtomics(this, where, delta, data, value);\n    } else if (value._path && Buffer.isBuffer(value)) {\n      // MongooseBuffer\n      value = value.toObject();\n      operand(this, where, delta, data, value);\n    } else {\n      value = utils.clone(value, {depopulate: 1, _isNested: true});\n      operand(this, where, delta, data, value);\n    }\n  }\n\n  if (divergent.length) {\n    return new DivergentArrayError(divergent);\n  }\n\n  if (this.$__.version) {\n    this.$__version(where, delta);\n  }\n\n  return [where, delta];\n}',
  '$__save': 'function (options, callback) {\n  var _this = this;\n\n  _this.$__handleSave(options, function(error, result) {\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.$__reset();\n    _this.$__storeShard();\n\n    var numAffected = 0;\n    if (result) {\n      if (Array.isArray(result)) {\n        numAffected = result.length;\n      } else if (result.result && result.result.n !== undefined) {\n        numAffected = result.result.n;\n      } else if (result.result && result.result.nModified !== undefined) {\n        numAffected = result.result.nModified;\n      } else {\n        numAffected = result;\n      }\n    }\n\n    // was this an update that required a version bump?\n    if (_this.$__.version && !_this.$__.inserting) {\n      var doIncrement = VERSION_INC === (VERSION_INC & _this.$__.version);\n      _this.$__.version = undefined;\n\n      if (numAffected <= 0) {\n        // the update failed. pass an error back\n        var err = new VersionError(_this);\n        return callback(err);\n      }\n\n      // increment version if was successful\n      if (doIncrement) {\n        var key = _this.schema.options.versionKey;\n        var version = _this.getValue(key) | 0;\n        _this.setValue(key, version + 1);\n      }\n    }\n\n    if (_this.schema.options &&\n        _this.schema.options.saveErrorIfNotFound &&\n        numAffected <= 0) {\n      error = new DocumentNotFoundError(result.$where);\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.emit(\'save\', _this, numAffected);\n    _this.constructor.emit(\'save\', _this, numAffected);\n    callback(null, _this, numAffected);\n  });\n}' }
[2017-05-04 15:41:42.146] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:41:42.158] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:41:42.161] [INFO] app - Redis client default is ready {}
[2017-05-04 15:41:42.313] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:42:05.061] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:42:05.078] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:42:05.085] [INFO] app - Redis client default is ready {}
[2017-05-04 15:42:05.271] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:42:07.111] [DEBUG] app - 2017-5-4 15:42:07 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:42:07.119] [WARN] console - this is a logger middleware.
[2017-05-04 15:42:07.141] [WARN] console - { depopulate: 'function (path) {\n  var populatedIds = this.populated(path);\n  if (!populatedIds) {\n    return;\n  }\n  delete this.$__.populated[path];\n  this.set(path, populatedIds);\n  return this;\n}',
  equals: 'function (doc) {\n  if (!doc) {\n    return false;\n  }\n\n  var tid = this.get(\'_id\');\n  var docid = doc.get ? doc.get(\'_id\') : doc;\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals\n      ? tid.equals(docid)\n      : tid === docid;\n}',
  _posts: '[object Object]',
  '$__getAllSubdocs': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  function docReducer(seed, path) {\n    var val = this[path];\n\n    if (val instanceof Embedded) {\n      seed.push(val);\n    }\n    if (val && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(docReducer.bind(val._doc), seed);\n      seed.push(val);\n    }\n    if (val && val.isMongooseDocumentArray) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n        seed = Object.keys(doc._doc).reduce(docReducer.bind(doc._doc), seed);\n      });\n    } else if (val instanceof Document && val.$__isNested) {\n      if (val) {\n        seed = Object.keys(val).reduce(docReducer.bind(val), seed);\n      }\n    }\n    return seed;\n  }\n\n  var subDocs = Object.keys(this._doc).reduce(docReducer.bind(this), []);\n\n  return subDocs;\n}',
  removeListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  '$__original_save': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  '$__getArrayPathsToValidate': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  // validate all document arrays.\n  return this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return this.getValue(i);\n  }.bind(this))\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  }).reduce(function(seed, array) {\n    return seed.concat(array);\n  }, [])\n  .filter(function(doc) {\n    return doc;\n  });\n}',
  schema: '[object Object]',
  removeAllListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  save: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  isDirectSelected: 'function isDirectSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  removePost: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , posts = proto._posts || (proto._posts || {});\n    if (!posts[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all post callbacks for hook `name`\n      posts[name].length = 0;\n    } else {\n      posts[name] = posts[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  _lazySetupHooks: 'function (proto, methodName, errorCb) {\n    if (\'undefined\' === typeof proto[methodName].numAsyncPres) {\n      this.$hook(methodName, proto[methodName], errorCb);\n    }\n  }',
  toBSON: 'function () {\n  return this.toObject({\n    transform: false,\n    virtuals: false,\n    _skipDepopulateTopLevel: true,\n    depopulate: true,\n    flattenDecimals: false\n  });\n}',
  markModified: 'function (path) {\n  this.$__.activePaths.modify(path);\n}',
  on: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  increment: 'function increment() {\n  this.$__.version = VERSION_ALL;\n  return this;\n}',
  validate: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populated: 'function (path, val, options) {\n  // val and options are internal\n\n  if (val === null || val === void 0) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    var v = this.$__.populated[path];\n    if (v) {\n      return v.value;\n    }\n    return undefined;\n  }\n\n  // internal\n\n  if (val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    return this.$__.populated[path];\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = {value: val, options: options};\n  return val;\n}',
  update: 'function update() {\n  var args = utils.args(arguments);\n  args.unshift({_id: this._id});\n  return this.constructor.update.apply(this.constructor, args);\n}',
  id: '5902b753c5756d72945d90b3',
  '$__setSchema': 'function (schema) {\n  compile(schema.tree, this, undefined, schema.options);\n  this.schema = schema;\n}',
  isInit: 'function (path) {\n  return (path in this.$__.activePaths.states.init);\n}',
  '$__validate': 'function (callback) {\n  var _this = this;\n  var _complete = function() {\n    var err = _this.$__.validationError;\n    _this.$__.validationError = undefined;\n    _this.emit(\'validate\', _this);\n    _this.constructor.emit(\'validate\', _this);\n    if (err) {\n      for (var key in err.errors) {\n        // Make sure cast errors persist\n        if (!_this.__parent && err.errors[key] instanceof MongooseError.CastError) {\n          _this.invalidate(key, err.errors[key]);\n        }\n      }\n\n      return err;\n    }\n  };\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (paths.length === 0) {\n    process.nextTick(function() {\n      var error = _complete();\n      if (error) {\n        return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n          callback(error);\n        });\n      }\n      callback();\n    });\n  }\n\n  var validating = {},\n      total = 0;\n\n  var complete = function() {\n    var error = _complete();\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n    callback();\n  };\n\n  var validatePath = function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n    total++;\n\n    process.nextTick(function() {\n      var p = _this.schema.path(path);\n      if (!p) {\n        return --total || complete();\n      }\n\n      // If user marked as invalid or there was a cast error, don\'t validate\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      var val = _this.getValue(path);\n      p.doValidate(val, function(err) {\n        if (err) {\n          _this.invalidate(path, err, undefined, true);\n        }\n        --total || complete();\n      }, _this);\n    });\n  };\n\n  paths.forEach(validatePath);\n}',
  username: '222',
  db: '[object Object]',
  '$__original_validate': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  discriminators: 'undefined',
  isModified: 'function (paths) {\n  if (paths) {\n    if (!Array.isArray(paths)) {\n      paths = paths.split(\' \');\n    }\n    var modified = this.modifiedPaths();\n    var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n    var isModifiedChild = paths.some(function(path) {\n      return !!~modified.indexOf(path);\n    });\n    return isModifiedChild || paths.some(function(path) {\n      return directModifiedPaths.some(function(mod) {\n        return mod === path || path.indexOf(mod + \'.\') === 0;\n      });\n    });\n  }\n  return this.$__.activePaths.some(\'modify\');\n}',
  '$pre': 'function (name, isAsync, fn, errorCb) {\n    if (\'boolean\' !== typeof arguments[1]) {\n      errorCb = fn;\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {};\n\n    this._lazySetupHooks(proto, name, errorCb);\n\n    if (fn.isAsync = isAsync) {\n      proto[name].numAsyncPres++;\n    }\n\n    (pres[name] = pres[name] || []).push(fn);\n    return this;\n  }',
  toObject: 'function (options) {\n  return this.$toObject(options);\n}',
  '$markValid': 'function (path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n}',
  '$__buildDoc': 'function (obj, fields, skipId) {\n  var doc = {};\n  var exclude = null;\n  var keys;\n  var ki;\n  var _this = this;\n\n  // determine if this doc is a result of a query with\n  // excluded fields\n\n  if (fields && utils.getFunctionName(fields.constructor) === \'Object\') {\n    keys = Object.keys(fields);\n    ki = keys.length;\n\n    if (ki === 1 && keys[0] === \'_id\') {\n      exclude = !!fields[keys[ki]];\n    } else {\n      while (ki--) {\n        if (keys[ki] !== \'_id\' &&\n            (!fields[keys[ki]] || typeof fields[keys[ki]] !== \'object\')) {\n          exclude = !fields[keys[ki]];\n          break;\n        }\n      }\n    }\n  }\n\n  var paths = Object.keys(this.schema.paths);\n  var plen = paths.length;\n  var ii = 0;\n\n  var hasIncludedChildren = {};\n  if (exclude === false && fields) {\n    keys = Object.keys(fields);\n    for (var j = 0; j < keys.length; ++j) {\n      var parts = keys[j].split(\'.\');\n      var c = [];\n      for (var k = 0; k < parts.length; ++k) {\n        c.push(parts[k]);\n        hasIncludedChildren[c.join(\'.\')] = 1;\n      }\n    }\n  }\n\n  for (; ii < plen; ++ii) {\n    var p = paths[ii];\n\n    if (p === \'_id\') {\n      if (skipId) {\n        continue;\n      }\n      if (obj && \'_id\' in obj) {\n        continue;\n      }\n    }\n\n    var type = this.schema.paths[p];\n    var path = p.split(\'.\');\n    var len = path.length;\n    var last = len - 1;\n    var curPath = \'\';\n    var doc_ = doc;\n    var i = 0;\n    var included = false;\n\n    for (; i < len; ++i) {\n      var piece = path[i],\n          def;\n\n      curPath += (!curPath.length ? \'\' : \'.\') + piece;\n\n      // support excluding intermediary levels\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i === last) {\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          } else if (included) {\n            // selected field\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          }\n        } else {\n          def = type.getDefault(_this, false);\n          if (typeof def !== \'undefined\') {\n            doc_[piece] = def;\n            _this.$__.activePaths.default(p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  return doc;\n}',
  getValue: 'function (path) {\n  return utils.getValue(path, this._doc);\n}',
  collection: '[object Object]',
  createdAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  '$isValid': 'function (path) {\n  return !this.$__.validationError || !this.$__.validationError.errors[path];\n}',
  '$__version': 'function (where, delta) {\n  var key = this.schema.options.versionKey;\n\n  if (where === true) {\n    // this is an insert\n    if (key) this.setValue(key, delta[key] = 0);\n    return;\n  }\n\n  // updates\n\n  // only apply versioning if our versionKey was selected. else\n  // there is no way to select the correct version. we could fail\n  // fast here and force them to include the versionKey but\n  // thats a bit intrusive. can we do this automatically?\n  if (!this.isSelected(key)) {\n    return;\n  }\n\n  // $push $addToSet don\'t need the where clause set\n  if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {\n    where[key] = this.getValue(key);\n  }\n\n  if (VERSION_INC === (VERSION_INC & this.$__.version)) {\n    if (!delta.$set || typeof delta.$set[key] === \'undefined\') {\n      delta.$inc || (delta.$inc = {});\n      delta.$inc[key] = 1;\n    }\n  }\n}',
  isDirectModified: 'function (path) {\n  return (path in this.$__.activePaths.states.modify);\n}',
  '$isMongooseModelPrototype': 'true',
  modifiedPaths: 'function () {\n  var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n  return directModifiedPaths.reduce(function(list, path) {\n    var parts = path.split(\'.\');\n    return list.concat(parts.reduce(function(chains, part, i) {\n      return chains.concat(parts.slice(0, i).concat(part).join(\'.\'));\n    }, []).filter(function(chain) {\n      return (list.indexOf(chain) === -1);\n    }));\n  }, []);\n}',
  updatedAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  get: 'function (path, type) {\n  var adhoc;\n  if (type) {\n    adhoc = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  var schema = this.$__path(path) || this.schema.virtualpath(path),\n      pieces = path.split(\'.\'),\n      obj = this._doc;\n\n  for (var i = 0, l = pieces.length; i < l; i++) {\n    obj = obj === null || obj === void 0\n        ? undefined\n        : obj[pieces[i]];\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  // Check if this path is populated - don\'t apply getters if it is,\n  // because otherwise its a nested object. See gh-3357\n  if (schema && !this.populated(path)) {\n    obj = schema.applyGetters(obj, this);\n  }\n\n  return obj;\n}',
  '$__path': 'function (path) {\n  var adhocs = this.$__.adhocPaths,\n      adhocType = adhocs && adhocs[path];\n\n  if (adhocType) {\n    return adhocType;\n  }\n  return this.schema.path(path);\n}',
  listeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  '$__storeShard': 'function () {\n  // backwards compat\n  var key = this.schema.options.shardKey || this.schema.options.shardkey;\n  if (!(key && utils.getFunctionName(key.constructor) === \'Object\')) {\n    return;\n  }\n\n  var orig = this.$__.shardval = {},\n      paths = Object.keys(key),\n      len = paths.length,\n      val;\n\n  for (var i = 0; i < len; ++i) {\n    val = this.getValue(paths[i]);\n    if (isMongooseObject(val)) {\n      orig[paths[i]] = val.toObject({depopulate: true, _isNested: true});\n    } else if (val !== null && val !== undefined && val.valueOf &&\n          // Explicitly don\'t take value of dates\n        (!val.constructor || utils.getFunctionName(val.constructor) !== \'Date\')) {\n      orig[paths[i]] = val.valueOf();\n    } else {\n      orig[paths[i]] = val;\n    }\n  }\n}',
  '$__dirty': 'function () {\n  var _this = this;\n\n  var all = this.$__.activePaths.map(\'modify\', function(path) {\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  });\n\n  // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n  all = all.concat(this.$__.activePaths.map(\'default\', function(path) {\n    if (path === \'_id\' || !_this.getValue(path)) {\n      return;\n    }\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n\n  // Sort dirty paths in a flat hierarchy.\n  all.sort(function(a, b) {\n    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));\n  });\n\n  // Ignore "foo.a" if "foo" is dirty already.\n  var minimal = [],\n      lastPath,\n      top;\n\n  all.forEach(function(item) {\n    if (!item) {\n      return;\n    }\n    if (item.path.indexOf(lastPath) !== 0) {\n      lastPath = item.path + \'.\';\n      minimal.push(item);\n      top = item;\n    } else {\n      // special case for top level MongooseArrays\n      if (top.value && top.value._atomics && top.value.hasAtomics()) {\n        // the `top` array itself and a sub path of `top` are being modified.\n        // the only way to honor all of both modifications is through a $set\n        // of entire array.\n        top.value._atomics = {};\n        top.value._atomics.$set = top.value;\n      }\n    }\n  });\n\n  top = lastPath = null;\n  return minimal;\n}',
  model: 'function model(name) {\n  return this.db.model(name);\n}',
  '$isDefault': 'function (path) {\n  return (path in this.$__.activePaths.states.default);\n}',
  '$__original_remove': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  remove: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populate: 'function populate() {\n  if (arguments.length === 0) {\n    return this;\n  }\n\n  var pop = this.$__.populate || (this.$__.populate = {});\n  var args = utils.args(arguments);\n  var fn;\n\n  if (typeof args[args.length - 1] === \'function\') {\n    fn = args.pop();\n  }\n\n  // allow `doc.populate(callback)`\n  if (args.length) {\n    // use hash to remove duplicate paths\n    var res = utils.populate.apply(null, args);\n    for (var i = 0; i < res.length; ++i) {\n      pop[res[i].path] = res[i];\n    }\n  }\n\n  if (fn) {\n    var paths = utils.object.vals(pop);\n    this.$__.populate = undefined;\n    paths.__noPromise = true;\n    this.constructor.populate(this, paths, fn);\n  }\n\n  return this;\n}',
  '$__shouldModify': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  if (this.isNew) {\n    return true;\n  }\n\n  if (undefined === val && !this.isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (undefined === val && path in this.$__.activePaths.states.default) {\n    // we\'re just unsetting the default value which was never saved\n    return false;\n  }\n\n  // gh-3992: if setting a populated field to a doc, don\'t mark modified\n  // if they have the same _id\n  if (this.populated(path) &&\n      val instanceof Document &&\n      deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal || this.get(path))) {\n    return true;\n  }\n\n  if (!constructing &&\n      val !== null &&\n      val !== undefined &&\n      path in this.$__.activePaths.states.default &&\n      deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n  return false;\n}',
  '$__': '[object Object]',
  '$__fullPath': 'function (path) {\n  // overridden in SubDocuments\n  return path || \'\';\n}',
  _pres: '[object Object]',
  inspect: 'function (options) {\n  var isPOJO = options &&\n    utils.getFunctionName(options.constructor) === \'Object\';\n  var opts;\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n    opts.retainKeyOrder = true;\n  }\n  return this.toObject(opts);\n}',
  '$__reset': 'function reset() {\n  var _this = this;\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return _this.getValue(i);\n  })\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  })\n  .forEach(function(array) {\n    var i = array.length;\n    while (i--) {\n      var doc = array[i];\n      if (!doc) {\n        continue;\n      }\n      doc.$__reset();\n    }\n  });\n\n  // clear atomics\n  this.$__dirty().forEach(function(dirt) {\n    var type = dirt.value;\n    if (type && type._atomics) {\n      type._atomics = {};\n    }\n  });\n\n  // Clear \'dirty\' cache\n  this.$__.activePaths.clear(\'modify\');\n  this.$__.activePaths.clear(\'default\');\n  this.$__.validationError = undefined;\n  this.errors = undefined;\n  _this = this;\n  this.schema.requiredPaths().forEach(function(path) {\n    _this.$__.activePaths.require(path);\n  });\n\n  return this;\n}',
  init: 'function (doc, opts, fn) {\n  // do not prefix this method with $__ since its\n  // used by public hooks\n\n  if (typeof opts === \'function\') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.isNew = false;\n\n  // handle docs with populated paths\n  // If doc._id is not null or undefined\n  if (doc._id !== null && doc._id !== undefined &&\n    opts && opts.populated && opts.populated.length) {\n    var id = String(doc._id);\n    for (var i = 0; i < opts.populated.length; ++i) {\n      var item = opts.populated[i];\n      if (item.isVirtual) {\n        this.populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.populated(item.path, item._docs[id], item);\n      }\n    }\n  }\n\n  init(this, doc, this._doc);\n  this.$__storeShard();\n\n  this.emit(\'init\', this);\n  this.constructor.emit(\'init\', this);\n\n  if (fn) {\n    fn(null);\n  }\n  return this;\n}',
  setMaxListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  initializeTimestamps: 'function () {\n      if (!this.get(createdAt)) {\n        this.set(createdAt, new Date());\n      }\n      if (!this.get(updatedAt)) {\n        this.set(updatedAt, new Date());\n      }\n      return this;\n    }',
  once: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  __v: '0',
  '$toObject': 'function (options, json) {\n  var defaultOptions = {\n    transform: true,\n    json: json,\n    retainKeyOrder: this.schema.options.retainKeyOrder,\n    flattenDecimals: true\n  };\n\n  // _isNested will only be true if this is not the top level document, we\n  // should never depopulate\n  if (options && options.depopulate && options._isNested && this.$__.wasPopulated) {\n    // populated paths that we set to a document\n    return clone(this._id, options);\n  }\n\n  // When internally saving this document we always pass options,\n  // bypassing the custom schema options.\n  if (!(options && utils.getFunctionName(options.constructor) === \'Object\') ||\n      (options && options._useSchemaOptions)) {\n    if (json) {\n      options = this.schema.options.toJSON ?\n        clone(this.schema.options.toJSON) :\n        {};\n      options.json = true;\n      options._useSchemaOptions = true;\n    } else {\n      options = this.schema.options.toObject ?\n        clone(this.schema.options.toObject) :\n        {};\n      options.json = false;\n      options._useSchemaOptions = true;\n    }\n  }\n\n  for (var key in defaultOptions) {\n    if (options[key] === undefined) {\n      options[key] = defaultOptions[key];\n    }\n  }\n\n  (\'minimize\' in options) || (options.minimize = this.schema.options.minimize);\n\n  // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n  var originalTransform = options.transform;\n\n  options._isNested = true;\n\n  var ret = clone(this._doc, options) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, \'paths\', options);\n    // applyGetters for paths will add nested empty objects;\n    // if minimize is set, we need to remove them.\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || options.getters && options.virtuals !== false) {\n    applyGetters(this, ret, \'virtuals\', options);\n  }\n\n  if (options.versionKey === false && this.schema.options.versionKey) {\n    delete ret[this.schema.options.versionKey];\n  }\n\n  var transform = options.transform;\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema\'s transform and\n  // not the parent schema\'s\n  if (transform === true ||\n      (this.schema.options.toObject && transform)) {\n    var opts = options.json ? this.schema.options.toJSON : this.schema.options.toObject;\n\n    if (opts) {\n      transform = (typeof options.transform === \'function\' ? options.transform : opts.transform);\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === \'function\') {\n    var xformed = transform(this, ret, options);\n    if (typeof xformed !== \'undefined\') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n}',
  '$hook': 'function (name, fn, errorCb) {\n    if (arguments.length === 1 && typeof name === \'object\') {\n      for (var k in name) { // `name` is a hash of hookName->hookFn\n        this.$hook(k, name[k]);\n      }\n      return;\n    }\n\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {}\n      , posts = proto._posts = proto._posts || {};\n    pres[name] = pres[name] || [];\n    posts[name] = posts[name] || [];\n\n    proto[name] = function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    };\n    \n    proto[name].numAsyncPres = 0;\n\n    return this;\n  }',
  '$__set': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  var shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts,\n    schema, val, priorVal);\n  var _this = this;\n\n  if (shouldModify) {\n    this.markModified(pathToMark, val);\n\n    // handle directly setting arrays (gh-1126)\n    MongooseArray || (MongooseArray = require(\'./types/array\'));\n    if (val && val.isMongooseArray) {\n      val._registerAtomic(\'$set\', val);\n\n      // Update embedded document parent references (gh-5189)\n      if (val.isMongooseDocumentArray) {\n        val.forEach(function(item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      }\n\n      // Small hack for gh-1638: if we\'re overwriting the entire array, ignore\n      // paths that were modified before the array overwrite\n      this.$__.activePaths.forEach(function(modifiedPath) {\n        if (modifiedPath.indexOf(path + \'.\') === 0) {\n          _this.$__.activePaths.ignore(modifiedPath);\n        }\n      });\n    }\n  }\n\n  var obj = this._doc;\n  var i = 0;\n  var l = parts.length;\n  var cur = \'\';\n\n  for (; i < l; i++) {\n    var next = i + 1;\n    var last = next === l;\n    cur += (cur ? \'.\' + parts[i] : parts[i]);\n\n    if (last) {\n      obj[parts[i]] = val;\n    } else {\n      if (obj[parts[i]] && utils.getFunctionName(obj[parts[i]].constructor) === \'Object\') {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        this.set(cur, {});\n        obj = obj[parts[i]];\n      }\n    }\n  }\n}',
  isNew: 'false',
  unmarkModified: 'function (path) {\n  this.$__.activePaths.init(path);\n}',
  validateSync: 'function (pathsToValidate) {\n  var _this = this;\n\n  if (typeof pathsToValidate === \'string\') {\n    pathsToValidate = pathsToValidate.split(\' \');\n  }\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (pathsToValidate && pathsToValidate.length) {\n    var tmp = [];\n    for (var i = 0; i < paths.length; ++i) {\n      if (pathsToValidate.indexOf(paths[i]) !== -1) {\n        tmp.push(paths[i]);\n      }\n    }\n    paths = tmp;\n  }\n\n  var validating = {};\n\n  paths.forEach(function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n\n    var p = _this.schema.path(path);\n    if (!p) {\n      return;\n    }\n    if (!_this.$isValid(path)) {\n      return;\n    }\n\n    var val = _this.getValue(path);\n    var err = p.doValidateSync(val, _this);\n    if (err) {\n      _this.invalidate(path, err, undefined, true);\n    }\n  });\n\n  var err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n  _this.emit(\'validate\', _this);\n  _this.constructor.emit(\'validate\', _this);\n\n  if (err) {\n    for (var key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n}',
  errors: 'undefined',
  addListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  setValue: 'function (path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n}',
  '$__where': 'function _where(where) {\n  where || (where = {});\n\n  var paths,\n      len;\n\n  if (!where._id) {\n    where._id = this._doc._id;\n  }\n\n  if (this.$__.shardval) {\n    paths = Object.keys(this.$__.shardval);\n    len = paths.length;\n\n    for (var i = 0; i < len; ++i) {\n      where[paths[i]] = this.$__.shardval[paths[i]];\n    }\n  }\n\n  if (this._doc._id == null) {\n    return new Error(\'No _id found on document!\');\n  }\n\n  return where;\n}',
  invalidate: 'function (path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === \'string\') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || \'user defined\',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.errors[path] = err;\n  return this.$__.validationError;\n}',
  _doc: '[object Object]',
  execPopulate: 'function () {\n  var Promise = PromiseProvider.get();\n  var _this = this;\n  return new Promise.ES6(function(resolve, reject) {\n    _this.populate(function(error, res) {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(res);\n      }\n    });\n  });\n}',
  isSelected: 'function isSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    i = paths.length;\n    var pathDot = path + \'.\';\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n\n      if (cur.indexOf(pathDot) === 0) {\n        return inclusive || cur !== pathDot;\n      }\n\n      if (pathDot.indexOf(cur + \'.\') === 0) {\n        return inclusive;\n      }\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  _id: '5902b753c5756d72945d90b3',
  toString: 'function () {\n  return inspect(this.inspect());\n}',
  '$post': 'function (name, isAsync, fn) {\n    if (arguments.length === 2) {\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , posts = proto._posts = proto._posts || {};\n    \n    this._lazySetupHooks(proto, name);\n    (posts[name] = posts[name] || []).push(fn);\n    return this;\n  }',
  '$__handleSave': 'function (options, callback) {\n  var _this = this;\n  var i;\n  var keys;\n  var len;\n  if (!options.safe && this.schema.options.safe) {\n    options.safe = this.schema.options.safe;\n  }\n  if (typeof options.safe === \'boolean\') {\n    options.safe = null;\n  }\n\n  if (this.isNew) {\n    // send entire doc\n    var toObjectOptions = {};\n\n    toObjectOptions.retainKeyOrder = this.schema.options.retainKeyOrder;\n    toObjectOptions.depopulate = 1;\n    toObjectOptions._skipDepopulateTopLevel = true;\n    toObjectOptions.transform = false;\n    toObjectOptions.flattenDecimals = false;\n\n    var obj = this.toObject(toObjectOptions);\n\n    if (!utils.object.hasOwnProperty(obj || {}, \'_id\')) {\n      // documents must have an _id else mongoose won\'t know\n      // what to update later if more changes are made. the user\n      // wouldn\'t know what _id was generated by mongodb either\n      // nor would the ObjectId generated my mongodb necessarily\n      // match the schema definition.\n      setTimeout(function() {\n        callback(new Error(\'document must have an _id before saving\'));\n      }, 0);\n      return;\n    }\n\n    this.$__version(true, obj);\n    this.collection.insert(obj, options.safe, function(err, ret) {\n      if (err) {\n        _this.isNew = true;\n        _this.emit(\'isNew\', true);\n        _this.constructor.emit(\'isNew\', true);\n\n        callback(err);\n        return;\n      }\n\n      callback(null, ret);\n    });\n    this.$__reset();\n    this.isNew = false;\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n    // Make it possible to retry the insert\n    this.$__.inserting = true;\n  } else {\n    // Make sure we don\'t treat it as a new object on error,\n    // since it already exists\n    this.$__.inserting = false;\n\n    var delta = this.$__delta();\n\n    if (delta) {\n      if (delta instanceof Error) {\n        callback(delta);\n        return;\n      }\n\n      var where = this.$__where(delta[0]);\n      if (where instanceof Error) {\n        callback(where);\n        return;\n      }\n\n      if (this.$where) {\n        keys = Object.keys(this.$where);\n        len = keys.length;\n        for (i = 0; i < len; ++i) {\n          where[keys[i]] = this.$where[keys[i]];\n        }\n      }\n\n      this.collection.update(where, delta[1], options.safe, function(err, ret) {\n        if (err) {\n          callback(err);\n          return;\n        }\n        ret.$where = where;\n        callback(null, ret);\n      });\n    } else {\n      this.$__reset();\n      callback();\n      return;\n    }\n\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n  }\n}',
  '$ignore': 'function (path) {\n  this.$__.activePaths.ignore(path);\n}',
  emit: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  removePre: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , pres = proto._pres || (proto._pres || {});\n    if (!pres[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all pre callbacks for hook `name`\n      pres[name].length = 0;\n    } else {\n      pres[name] = pres[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  toJSON: 'function (options) {\n  return this.$toObject(options, true);\n}',
  '$__handleReject': 'function handleReject(err) {\n  // emit on the Model if listening\n  if (this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  } else if (this.constructor.listeners && this.constructor.listeners(\'error\').length) {\n    this.constructor.emit(\'error\', err);\n  } else if (this.listeners && this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  }\n}',
  set: 'function (path, val, type, options) {\n  if (type && utils.getFunctionName(type.constructor) === \'Object\') {\n    options = type;\n    type = undefined;\n  }\n\n  var merge = options && options.merge,\n      adhoc = type && type !== true,\n      constructing = type === true,\n      adhocs;\n\n  var strict = options && \'strict\' in options\n      ? options.strict\n      : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  if (typeof path !== \'string\') {\n    // new Document({ key: val })\n\n    if (path === null || path === void 0) {\n      var _ = path;\n      path = val;\n      val = _;\n    } else {\n      var prefix = val\n          ? val + \'.\'\n          : \'\';\n\n      if (path instanceof Document) {\n        if (path.$__isNested) {\n          path = path.toObject();\n        } else {\n          path = path._doc;\n        }\n      }\n\n      var keys = Object.keys(path);\n      var len = keys.length;\n      var i = 0;\n      var pathtype;\n      var key;\n\n      if (len === 0 && !this.schema.options.minimize) {\n        if (val) {\n          this.set(val, {});\n        }\n        return this;\n      }\n\n      if (this.schema.options.retainKeyOrder) {\n        while (i < len) {\n          _handleIndex.call(this, i++);\n        }\n      } else {\n        while (len--) {\n          _handleIndex.call(this, len);\n        }\n      }\n\n      return this;\n    }\n  }\n\n  function _handleIndex(i) {\n    key = keys[i];\n    var pathName = prefix + key;\n    pathtype = this.schema.pathType(pathName);\n\n    if (path[key] !== null\n        && path[key] !== void 0\n          // need to know if plain object - no Buffer, ObjectId, ref, etc\n        && utils.isObject(path[key])\n        && (!path[key].constructor || utils.getFunctionName(path[key].constructor) === \'Object\')\n        && pathtype !== \'virtual\'\n        && pathtype !== \'real\'\n        && !(this.$__path(pathName) instanceof MixedSchema)\n        && !(this.schema.paths[pathName] &&\n        this.schema.paths[pathName].options &&\n        this.schema.paths[pathName].options.ref)) {\n      this.set(path[key], prefix + key, constructing);\n    } else if (strict) {\n      // Don\'t overwrite defaults with undefined keys (gh-3981)\n      if (constructing && path[key] === void 0 &&\n          this.get(key) !== void 0) {\n        return;\n      }\n\n      if (pathtype === \'real\' || pathtype === \'virtual\') {\n        // Check for setting single embedded schema to document (gh-3535)\n        var p = path[key];\n        if (this.schema.paths[pathName] &&\n            this.schema.paths[pathName].$isSingleNested &&\n            path[key] instanceof Document) {\n          p = p.toObject({ virtuals: false, transform: false });\n        }\n        this.set(prefix + key, p, constructing);\n      } else if (pathtype === \'nested\' && path[key] instanceof Document) {\n        this.set(prefix + key,\n            path[key].toObject({transform: false}), constructing);\n      } else if (strict === \'throw\') {\n        if (pathtype === \'nested\') {\n          throw new ObjectExpectedError(key, path[key]);\n        } else {\n          throw new StrictModeError(key);\n        }\n      }\n    } else if (path[key] !== void 0) {\n      this.set(prefix + key, path[key], constructing);\n    }\n  }\n\n  var pathType = this.schema.pathType(path);\n  if (pathType === \'nested\' && val) {\n    if (utils.isObject(val) &&\n        (!val.constructor || utils.getFunctionName(val.constructor) === \'Object\')) {\n      if (!merge) {\n        this.setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      }\n\n      if (Object.keys(val).length === 0) {\n        this.setValue(path, {});\n        this.markModified(path);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        this.set(val, path, constructing);\n      }\n      return this;\n    }\n    this.invalidate(path, new MongooseError.CastError(\'Object\', val, path));\n    return this;\n  }\n\n  var schema;\n  var parts = path.split(\'.\');\n\n  if (pathType === \'adhocOrUndefined\' && strict) {\n    // check for roots that are Mixed types\n    var mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      var subpath = parts.slice(0, i + 1).join(\'.\');\n      schema = this.schema.path(subpath);\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n\n      // If path is underneath a virtual, bypass everything and just set it.\n      if (i + 1 < parts.length && this.schema.pathType(subpath) === \'virtual\') {\n        mpath.set(path, val, this);\n        return this;\n      }\n    }\n\n    if (!mixed) {\n      if (strict === \'throw\') {\n        throw new StrictModeError(path);\n      }\n      return this;\n    }\n  } else if (pathType === \'virtual\') {\n    schema = this.schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  var pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: "LEFT_SUBFIELD only supports Object"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    for (i = 0; i < parts.length; ++i) {\n      subpath = parts.slice(0, i + 1).join(\'.\');\n      if (this.isDirectModified(subpath) // earlier prefixes that are already\n            // marked as dirty have precedence\n          || this.get(subpath) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n\n  // if this doc is being constructed we should not trigger getters\n  var priorVal = constructing\n      ? undefined\n      : this.getValue(path);\n\n  if (!schema) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n    return this;\n  }\n\n  var shouldSet = true;\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    var didPopulate = false;\n    if (schema.options &&\n        schema.options.ref &&\n        val instanceof Document &&\n        (schema.options.ref === val.constructor.modelName || schema.options.ref === val.constructor.baseModelName)) {\n      if (this.ownerDocument) {\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val._id, {model: val.constructor});\n      } else {\n        this.populated(path, val._id, {model: val.constructor});\n      }\n      didPopulate = true;\n    }\n\n    var popOpts;\n    if (schema.options &&\n        Array.isArray(schema.options.type) &&\n        schema.options.type.length &&\n        schema.options.type[0].ref &&\n        Array.isArray(val) &&\n        val.length > 0 &&\n        val[0] instanceof Document &&\n        val[0].constructor.modelName &&\n        (schema.options.type[0].ref === val[0].constructor.baseModelName || schema.options.type[0].ref === val[0].constructor.modelName)) {\n      if (this.ownerDocument) {\n        popOpts = { model: val[0].constructor };\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val.map(function(v) { return v._id; }), popOpts);\n      } else {\n        popOpts = { model: val[0].constructor };\n        this.populated(path, val.map(function(v) { return v._id; }), popOpts);\n      }\n      didPopulate = true;\n    }\n    val = schema.applySetters(val, this, false, priorVal);\n\n    if (!didPopulate && this.$__.populated) {\n      delete this.$__.populated[path];\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    this.invalidate(path,\n      new MongooseError.CastError(schema.instance, val, path, e));\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n}',
  '$__delta': 'function () {\n  var dirty = this.$__dirty();\n  if (!dirty.length && VERSION_ALL !== this.$__.version) return;\n\n  var where = {},\n      delta = {},\n      len = dirty.length,\n      divergent = [],\n      d = 0;\n\n  where._id = this._doc._id;\n  if (where._id.toObject) {\n    where._id = where._id.toObject({ transform: false, depopulate: true });\n  }\n\n  for (; d < len; ++d) {\n    var data = dirty[d];\n    var value = data.value;\n\n    var match = checkDivergentArray(this, data.path, value);\n    if (match) {\n      divergent.push(match);\n      continue;\n    }\n\n    var pop = this.populated(data.path, true);\n    if (!pop && this.$__.selected) {\n      // If any array was selected using an $elemMatch projection, we alter the path and where clause\n      // NOTE: MongoDB only supports projected $elemMatch on top level array.\n      var pathSplit = data.path.split(\'.\');\n      var top = pathSplit[0];\n      if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {\n        // If the selected array entry was modified\n        if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === \'undefined\') {\n          where[top] = this.$__.selected[top];\n          pathSplit[1] = \'$\';\n          data.path = pathSplit.join(\'.\');\n        }\n        // if the selected array was modified in any other way throw an error\n        else {\n          divergent.push(data.path);\n          continue;\n        }\n      }\n    }\n\n    if (divergent.length) continue;\n\n    if (undefined === value) {\n      operand(this, where, delta, data, 1, \'$unset\');\n    } else if (value === null) {\n      operand(this, where, delta, data, null);\n    } else if (value._path && value._atomics) {\n      // arrays and other custom types (support plugins etc)\n      handleAtomics(this, where, delta, data, value);\n    } else if (value._path && Buffer.isBuffer(value)) {\n      // MongooseBuffer\n      value = value.toObject();\n      operand(this, where, delta, data, value);\n    } else {\n      value = utils.clone(value, {depopulate: 1, _isNested: true});\n      operand(this, where, delta, data, value);\n    }\n  }\n\n  if (divergent.length) {\n    return new DivergentArrayError(divergent);\n  }\n\n  if (this.$__.version) {\n    this.$__version(where, delta);\n  }\n\n  return [where, delta];\n}',
  '$__save': 'function (options, callback) {\n  var _this = this;\n\n  _this.$__handleSave(options, function(error, result) {\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.$__reset();\n    _this.$__storeShard();\n\n    var numAffected = 0;\n    if (result) {\n      if (Array.isArray(result)) {\n        numAffected = result.length;\n      } else if (result.result && result.result.n !== undefined) {\n        numAffected = result.result.n;\n      } else if (result.result && result.result.nModified !== undefined) {\n        numAffected = result.result.nModified;\n      } else {\n        numAffected = result;\n      }\n    }\n\n    // was this an update that required a version bump?\n    if (_this.$__.version && !_this.$__.inserting) {\n      var doIncrement = VERSION_INC === (VERSION_INC & _this.$__.version);\n      _this.$__.version = undefined;\n\n      if (numAffected <= 0) {\n        // the update failed. pass an error back\n        var err = new VersionError(_this);\n        return callback(err);\n      }\n\n      // increment version if was successful\n      if (doIncrement) {\n        var key = _this.schema.options.versionKey;\n        var version = _this.getValue(key) | 0;\n        _this.setValue(key, version + 1);\n      }\n    }\n\n    if (_this.schema.options &&\n        _this.schema.options.saveErrorIfNotFound &&\n        numAffected <= 0) {\n      error = new DocumentNotFoundError(result.$where);\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.emit(\'save\', _this, numAffected);\n    _this.constructor.emit(\'save\', _this, numAffected);\n    callback(null, _this, numAffected);\n  });\n}' }
[2017-05-04 15:42:10.977] [DEBUG] app - 2017-5-4 15:42:10 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:42:10.978] [WARN] console - this is a logger middleware.
[2017-05-04 15:42:10.984] [WARN] console - { depopulate: 'function (path) {\n  var populatedIds = this.populated(path);\n  if (!populatedIds) {\n    return;\n  }\n  delete this.$__.populated[path];\n  this.set(path, populatedIds);\n  return this;\n}',
  equals: 'function (doc) {\n  if (!doc) {\n    return false;\n  }\n\n  var tid = this.get(\'_id\');\n  var docid = doc.get ? doc.get(\'_id\') : doc;\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals\n      ? tid.equals(docid)\n      : tid === docid;\n}',
  _posts: '[object Object]',
  '$__getAllSubdocs': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  function docReducer(seed, path) {\n    var val = this[path];\n\n    if (val instanceof Embedded) {\n      seed.push(val);\n    }\n    if (val && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(docReducer.bind(val._doc), seed);\n      seed.push(val);\n    }\n    if (val && val.isMongooseDocumentArray) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n        seed = Object.keys(doc._doc).reduce(docReducer.bind(doc._doc), seed);\n      });\n    } else if (val instanceof Document && val.$__isNested) {\n      if (val) {\n        seed = Object.keys(val).reduce(docReducer.bind(val), seed);\n      }\n    }\n    return seed;\n  }\n\n  var subDocs = Object.keys(this._doc).reduce(docReducer.bind(this), []);\n\n  return subDocs;\n}',
  removeListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  '$__original_save': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  '$__getArrayPathsToValidate': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  // validate all document arrays.\n  return this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return this.getValue(i);\n  }.bind(this))\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  }).reduce(function(seed, array) {\n    return seed.concat(array);\n  }, [])\n  .filter(function(doc) {\n    return doc;\n  });\n}',
  schema: '[object Object]',
  removeAllListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  save: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  isDirectSelected: 'function isDirectSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  removePost: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , posts = proto._posts || (proto._posts || {});\n    if (!posts[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all post callbacks for hook `name`\n      posts[name].length = 0;\n    } else {\n      posts[name] = posts[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  _lazySetupHooks: 'function (proto, methodName, errorCb) {\n    if (\'undefined\' === typeof proto[methodName].numAsyncPres) {\n      this.$hook(methodName, proto[methodName], errorCb);\n    }\n  }',
  toBSON: 'function () {\n  return this.toObject({\n    transform: false,\n    virtuals: false,\n    _skipDepopulateTopLevel: true,\n    depopulate: true,\n    flattenDecimals: false\n  });\n}',
  markModified: 'function (path) {\n  this.$__.activePaths.modify(path);\n}',
  on: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  increment: 'function increment() {\n  this.$__.version = VERSION_ALL;\n  return this;\n}',
  validate: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populated: 'function (path, val, options) {\n  // val and options are internal\n\n  if (val === null || val === void 0) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    var v = this.$__.populated[path];\n    if (v) {\n      return v.value;\n    }\n    return undefined;\n  }\n\n  // internal\n\n  if (val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    return this.$__.populated[path];\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = {value: val, options: options};\n  return val;\n}',
  update: 'function update() {\n  var args = utils.args(arguments);\n  args.unshift({_id: this._id});\n  return this.constructor.update.apply(this.constructor, args);\n}',
  id: '5902b753c5756d72945d90b3',
  '$__setSchema': 'function (schema) {\n  compile(schema.tree, this, undefined, schema.options);\n  this.schema = schema;\n}',
  isInit: 'function (path) {\n  return (path in this.$__.activePaths.states.init);\n}',
  '$__validate': 'function (callback) {\n  var _this = this;\n  var _complete = function() {\n    var err = _this.$__.validationError;\n    _this.$__.validationError = undefined;\n    _this.emit(\'validate\', _this);\n    _this.constructor.emit(\'validate\', _this);\n    if (err) {\n      for (var key in err.errors) {\n        // Make sure cast errors persist\n        if (!_this.__parent && err.errors[key] instanceof MongooseError.CastError) {\n          _this.invalidate(key, err.errors[key]);\n        }\n      }\n\n      return err;\n    }\n  };\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (paths.length === 0) {\n    process.nextTick(function() {\n      var error = _complete();\n      if (error) {\n        return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n          callback(error);\n        });\n      }\n      callback();\n    });\n  }\n\n  var validating = {},\n      total = 0;\n\n  var complete = function() {\n    var error = _complete();\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n    callback();\n  };\n\n  var validatePath = function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n    total++;\n\n    process.nextTick(function() {\n      var p = _this.schema.path(path);\n      if (!p) {\n        return --total || complete();\n      }\n\n      // If user marked as invalid or there was a cast error, don\'t validate\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      var val = _this.getValue(path);\n      p.doValidate(val, function(err) {\n        if (err) {\n          _this.invalidate(path, err, undefined, true);\n        }\n        --total || complete();\n      }, _this);\n    });\n  };\n\n  paths.forEach(validatePath);\n}',
  username: '222',
  db: '[object Object]',
  '$__original_validate': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  discriminators: 'undefined',
  isModified: 'function (paths) {\n  if (paths) {\n    if (!Array.isArray(paths)) {\n      paths = paths.split(\' \');\n    }\n    var modified = this.modifiedPaths();\n    var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n    var isModifiedChild = paths.some(function(path) {\n      return !!~modified.indexOf(path);\n    });\n    return isModifiedChild || paths.some(function(path) {\n      return directModifiedPaths.some(function(mod) {\n        return mod === path || path.indexOf(mod + \'.\') === 0;\n      });\n    });\n  }\n  return this.$__.activePaths.some(\'modify\');\n}',
  '$pre': 'function (name, isAsync, fn, errorCb) {\n    if (\'boolean\' !== typeof arguments[1]) {\n      errorCb = fn;\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {};\n\n    this._lazySetupHooks(proto, name, errorCb);\n\n    if (fn.isAsync = isAsync) {\n      proto[name].numAsyncPres++;\n    }\n\n    (pres[name] = pres[name] || []).push(fn);\n    return this;\n  }',
  toObject: 'function (options) {\n  return this.$toObject(options);\n}',
  '$markValid': 'function (path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n}',
  '$__buildDoc': 'function (obj, fields, skipId) {\n  var doc = {};\n  var exclude = null;\n  var keys;\n  var ki;\n  var _this = this;\n\n  // determine if this doc is a result of a query with\n  // excluded fields\n\n  if (fields && utils.getFunctionName(fields.constructor) === \'Object\') {\n    keys = Object.keys(fields);\n    ki = keys.length;\n\n    if (ki === 1 && keys[0] === \'_id\') {\n      exclude = !!fields[keys[ki]];\n    } else {\n      while (ki--) {\n        if (keys[ki] !== \'_id\' &&\n            (!fields[keys[ki]] || typeof fields[keys[ki]] !== \'object\')) {\n          exclude = !fields[keys[ki]];\n          break;\n        }\n      }\n    }\n  }\n\n  var paths = Object.keys(this.schema.paths);\n  var plen = paths.length;\n  var ii = 0;\n\n  var hasIncludedChildren = {};\n  if (exclude === false && fields) {\n    keys = Object.keys(fields);\n    for (var j = 0; j < keys.length; ++j) {\n      var parts = keys[j].split(\'.\');\n      var c = [];\n      for (var k = 0; k < parts.length; ++k) {\n        c.push(parts[k]);\n        hasIncludedChildren[c.join(\'.\')] = 1;\n      }\n    }\n  }\n\n  for (; ii < plen; ++ii) {\n    var p = paths[ii];\n\n    if (p === \'_id\') {\n      if (skipId) {\n        continue;\n      }\n      if (obj && \'_id\' in obj) {\n        continue;\n      }\n    }\n\n    var type = this.schema.paths[p];\n    var path = p.split(\'.\');\n    var len = path.length;\n    var last = len - 1;\n    var curPath = \'\';\n    var doc_ = doc;\n    var i = 0;\n    var included = false;\n\n    for (; i < len; ++i) {\n      var piece = path[i],\n          def;\n\n      curPath += (!curPath.length ? \'\' : \'.\') + piece;\n\n      // support excluding intermediary levels\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i === last) {\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          } else if (included) {\n            // selected field\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          }\n        } else {\n          def = type.getDefault(_this, false);\n          if (typeof def !== \'undefined\') {\n            doc_[piece] = def;\n            _this.$__.activePaths.default(p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  return doc;\n}',
  getValue: 'function (path) {\n  return utils.getValue(path, this._doc);\n}',
  collection: '[object Object]',
  createdAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  '$isValid': 'function (path) {\n  return !this.$__.validationError || !this.$__.validationError.errors[path];\n}',
  '$__version': 'function (where, delta) {\n  var key = this.schema.options.versionKey;\n\n  if (where === true) {\n    // this is an insert\n    if (key) this.setValue(key, delta[key] = 0);\n    return;\n  }\n\n  // updates\n\n  // only apply versioning if our versionKey was selected. else\n  // there is no way to select the correct version. we could fail\n  // fast here and force them to include the versionKey but\n  // thats a bit intrusive. can we do this automatically?\n  if (!this.isSelected(key)) {\n    return;\n  }\n\n  // $push $addToSet don\'t need the where clause set\n  if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {\n    where[key] = this.getValue(key);\n  }\n\n  if (VERSION_INC === (VERSION_INC & this.$__.version)) {\n    if (!delta.$set || typeof delta.$set[key] === \'undefined\') {\n      delta.$inc || (delta.$inc = {});\n      delta.$inc[key] = 1;\n    }\n  }\n}',
  isDirectModified: 'function (path) {\n  return (path in this.$__.activePaths.states.modify);\n}',
  '$isMongooseModelPrototype': 'true',
  modifiedPaths: 'function () {\n  var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n  return directModifiedPaths.reduce(function(list, path) {\n    var parts = path.split(\'.\');\n    return list.concat(parts.reduce(function(chains, part, i) {\n      return chains.concat(parts.slice(0, i).concat(part).join(\'.\'));\n    }, []).filter(function(chain) {\n      return (list.indexOf(chain) === -1);\n    }));\n  }, []);\n}',
  updatedAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  get: 'function (path, type) {\n  var adhoc;\n  if (type) {\n    adhoc = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  var schema = this.$__path(path) || this.schema.virtualpath(path),\n      pieces = path.split(\'.\'),\n      obj = this._doc;\n\n  for (var i = 0, l = pieces.length; i < l; i++) {\n    obj = obj === null || obj === void 0\n        ? undefined\n        : obj[pieces[i]];\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  // Check if this path is populated - don\'t apply getters if it is,\n  // because otherwise its a nested object. See gh-3357\n  if (schema && !this.populated(path)) {\n    obj = schema.applyGetters(obj, this);\n  }\n\n  return obj;\n}',
  '$__path': 'function (path) {\n  var adhocs = this.$__.adhocPaths,\n      adhocType = adhocs && adhocs[path];\n\n  if (adhocType) {\n    return adhocType;\n  }\n  return this.schema.path(path);\n}',
  listeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  '$__storeShard': 'function () {\n  // backwards compat\n  var key = this.schema.options.shardKey || this.schema.options.shardkey;\n  if (!(key && utils.getFunctionName(key.constructor) === \'Object\')) {\n    return;\n  }\n\n  var orig = this.$__.shardval = {},\n      paths = Object.keys(key),\n      len = paths.length,\n      val;\n\n  for (var i = 0; i < len; ++i) {\n    val = this.getValue(paths[i]);\n    if (isMongooseObject(val)) {\n      orig[paths[i]] = val.toObject({depopulate: true, _isNested: true});\n    } else if (val !== null && val !== undefined && val.valueOf &&\n          // Explicitly don\'t take value of dates\n        (!val.constructor || utils.getFunctionName(val.constructor) !== \'Date\')) {\n      orig[paths[i]] = val.valueOf();\n    } else {\n      orig[paths[i]] = val;\n    }\n  }\n}',
  '$__dirty': 'function () {\n  var _this = this;\n\n  var all = this.$__.activePaths.map(\'modify\', function(path) {\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  });\n\n  // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n  all = all.concat(this.$__.activePaths.map(\'default\', function(path) {\n    if (path === \'_id\' || !_this.getValue(path)) {\n      return;\n    }\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n\n  // Sort dirty paths in a flat hierarchy.\n  all.sort(function(a, b) {\n    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));\n  });\n\n  // Ignore "foo.a" if "foo" is dirty already.\n  var minimal = [],\n      lastPath,\n      top;\n\n  all.forEach(function(item) {\n    if (!item) {\n      return;\n    }\n    if (item.path.indexOf(lastPath) !== 0) {\n      lastPath = item.path + \'.\';\n      minimal.push(item);\n      top = item;\n    } else {\n      // special case for top level MongooseArrays\n      if (top.value && top.value._atomics && top.value.hasAtomics()) {\n        // the `top` array itself and a sub path of `top` are being modified.\n        // the only way to honor all of both modifications is through a $set\n        // of entire array.\n        top.value._atomics = {};\n        top.value._atomics.$set = top.value;\n      }\n    }\n  });\n\n  top = lastPath = null;\n  return minimal;\n}',
  model: 'function model(name) {\n  return this.db.model(name);\n}',
  '$isDefault': 'function (path) {\n  return (path in this.$__.activePaths.states.default);\n}',
  '$__original_remove': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  remove: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populate: 'function populate() {\n  if (arguments.length === 0) {\n    return this;\n  }\n\n  var pop = this.$__.populate || (this.$__.populate = {});\n  var args = utils.args(arguments);\n  var fn;\n\n  if (typeof args[args.length - 1] === \'function\') {\n    fn = args.pop();\n  }\n\n  // allow `doc.populate(callback)`\n  if (args.length) {\n    // use hash to remove duplicate paths\n    var res = utils.populate.apply(null, args);\n    for (var i = 0; i < res.length; ++i) {\n      pop[res[i].path] = res[i];\n    }\n  }\n\n  if (fn) {\n    var paths = utils.object.vals(pop);\n    this.$__.populate = undefined;\n    paths.__noPromise = true;\n    this.constructor.populate(this, paths, fn);\n  }\n\n  return this;\n}',
  '$__shouldModify': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  if (this.isNew) {\n    return true;\n  }\n\n  if (undefined === val && !this.isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (undefined === val && path in this.$__.activePaths.states.default) {\n    // we\'re just unsetting the default value which was never saved\n    return false;\n  }\n\n  // gh-3992: if setting a populated field to a doc, don\'t mark modified\n  // if they have the same _id\n  if (this.populated(path) &&\n      val instanceof Document &&\n      deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal || this.get(path))) {\n    return true;\n  }\n\n  if (!constructing &&\n      val !== null &&\n      val !== undefined &&\n      path in this.$__.activePaths.states.default &&\n      deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n  return false;\n}',
  '$__': '[object Object]',
  '$__fullPath': 'function (path) {\n  // overridden in SubDocuments\n  return path || \'\';\n}',
  _pres: '[object Object]',
  inspect: 'function (options) {\n  var isPOJO = options &&\n    utils.getFunctionName(options.constructor) === \'Object\';\n  var opts;\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n    opts.retainKeyOrder = true;\n  }\n  return this.toObject(opts);\n}',
  '$__reset': 'function reset() {\n  var _this = this;\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return _this.getValue(i);\n  })\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  })\n  .forEach(function(array) {\n    var i = array.length;\n    while (i--) {\n      var doc = array[i];\n      if (!doc) {\n        continue;\n      }\n      doc.$__reset();\n    }\n  });\n\n  // clear atomics\n  this.$__dirty().forEach(function(dirt) {\n    var type = dirt.value;\n    if (type && type._atomics) {\n      type._atomics = {};\n    }\n  });\n\n  // Clear \'dirty\' cache\n  this.$__.activePaths.clear(\'modify\');\n  this.$__.activePaths.clear(\'default\');\n  this.$__.validationError = undefined;\n  this.errors = undefined;\n  _this = this;\n  this.schema.requiredPaths().forEach(function(path) {\n    _this.$__.activePaths.require(path);\n  });\n\n  return this;\n}',
  init: 'function (doc, opts, fn) {\n  // do not prefix this method with $__ since its\n  // used by public hooks\n\n  if (typeof opts === \'function\') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.isNew = false;\n\n  // handle docs with populated paths\n  // If doc._id is not null or undefined\n  if (doc._id !== null && doc._id !== undefined &&\n    opts && opts.populated && opts.populated.length) {\n    var id = String(doc._id);\n    for (var i = 0; i < opts.populated.length; ++i) {\n      var item = opts.populated[i];\n      if (item.isVirtual) {\n        this.populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.populated(item.path, item._docs[id], item);\n      }\n    }\n  }\n\n  init(this, doc, this._doc);\n  this.$__storeShard();\n\n  this.emit(\'init\', this);\n  this.constructor.emit(\'init\', this);\n\n  if (fn) {\n    fn(null);\n  }\n  return this;\n}',
  setMaxListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  initializeTimestamps: 'function () {\n      if (!this.get(createdAt)) {\n        this.set(createdAt, new Date());\n      }\n      if (!this.get(updatedAt)) {\n        this.set(updatedAt, new Date());\n      }\n      return this;\n    }',
  once: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  __v: '0',
  '$toObject': 'function (options, json) {\n  var defaultOptions = {\n    transform: true,\n    json: json,\n    retainKeyOrder: this.schema.options.retainKeyOrder,\n    flattenDecimals: true\n  };\n\n  // _isNested will only be true if this is not the top level document, we\n  // should never depopulate\n  if (options && options.depopulate && options._isNested && this.$__.wasPopulated) {\n    // populated paths that we set to a document\n    return clone(this._id, options);\n  }\n\n  // When internally saving this document we always pass options,\n  // bypassing the custom schema options.\n  if (!(options && utils.getFunctionName(options.constructor) === \'Object\') ||\n      (options && options._useSchemaOptions)) {\n    if (json) {\n      options = this.schema.options.toJSON ?\n        clone(this.schema.options.toJSON) :\n        {};\n      options.json = true;\n      options._useSchemaOptions = true;\n    } else {\n      options = this.schema.options.toObject ?\n        clone(this.schema.options.toObject) :\n        {};\n      options.json = false;\n      options._useSchemaOptions = true;\n    }\n  }\n\n  for (var key in defaultOptions) {\n    if (options[key] === undefined) {\n      options[key] = defaultOptions[key];\n    }\n  }\n\n  (\'minimize\' in options) || (options.minimize = this.schema.options.minimize);\n\n  // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n  var originalTransform = options.transform;\n\n  options._isNested = true;\n\n  var ret = clone(this._doc, options) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, \'paths\', options);\n    // applyGetters for paths will add nested empty objects;\n    // if minimize is set, we need to remove them.\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || options.getters && options.virtuals !== false) {\n    applyGetters(this, ret, \'virtuals\', options);\n  }\n\n  if (options.versionKey === false && this.schema.options.versionKey) {\n    delete ret[this.schema.options.versionKey];\n  }\n\n  var transform = options.transform;\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema\'s transform and\n  // not the parent schema\'s\n  if (transform === true ||\n      (this.schema.options.toObject && transform)) {\n    var opts = options.json ? this.schema.options.toJSON : this.schema.options.toObject;\n\n    if (opts) {\n      transform = (typeof options.transform === \'function\' ? options.transform : opts.transform);\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === \'function\') {\n    var xformed = transform(this, ret, options);\n    if (typeof xformed !== \'undefined\') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n}',
  '$hook': 'function (name, fn, errorCb) {\n    if (arguments.length === 1 && typeof name === \'object\') {\n      for (var k in name) { // `name` is a hash of hookName->hookFn\n        this.$hook(k, name[k]);\n      }\n      return;\n    }\n\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {}\n      , posts = proto._posts = proto._posts || {};\n    pres[name] = pres[name] || [];\n    posts[name] = posts[name] || [];\n\n    proto[name] = function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    };\n    \n    proto[name].numAsyncPres = 0;\n\n    return this;\n  }',
  '$__set': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  var shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts,\n    schema, val, priorVal);\n  var _this = this;\n\n  if (shouldModify) {\n    this.markModified(pathToMark, val);\n\n    // handle directly setting arrays (gh-1126)\n    MongooseArray || (MongooseArray = require(\'./types/array\'));\n    if (val && val.isMongooseArray) {\n      val._registerAtomic(\'$set\', val);\n\n      // Update embedded document parent references (gh-5189)\n      if (val.isMongooseDocumentArray) {\n        val.forEach(function(item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      }\n\n      // Small hack for gh-1638: if we\'re overwriting the entire array, ignore\n      // paths that were modified before the array overwrite\n      this.$__.activePaths.forEach(function(modifiedPath) {\n        if (modifiedPath.indexOf(path + \'.\') === 0) {\n          _this.$__.activePaths.ignore(modifiedPath);\n        }\n      });\n    }\n  }\n\n  var obj = this._doc;\n  var i = 0;\n  var l = parts.length;\n  var cur = \'\';\n\n  for (; i < l; i++) {\n    var next = i + 1;\n    var last = next === l;\n    cur += (cur ? \'.\' + parts[i] : parts[i]);\n\n    if (last) {\n      obj[parts[i]] = val;\n    } else {\n      if (obj[parts[i]] && utils.getFunctionName(obj[parts[i]].constructor) === \'Object\') {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        this.set(cur, {});\n        obj = obj[parts[i]];\n      }\n    }\n  }\n}',
  isNew: 'false',
  unmarkModified: 'function (path) {\n  this.$__.activePaths.init(path);\n}',
  validateSync: 'function (pathsToValidate) {\n  var _this = this;\n\n  if (typeof pathsToValidate === \'string\') {\n    pathsToValidate = pathsToValidate.split(\' \');\n  }\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (pathsToValidate && pathsToValidate.length) {\n    var tmp = [];\n    for (var i = 0; i < paths.length; ++i) {\n      if (pathsToValidate.indexOf(paths[i]) !== -1) {\n        tmp.push(paths[i]);\n      }\n    }\n    paths = tmp;\n  }\n\n  var validating = {};\n\n  paths.forEach(function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n\n    var p = _this.schema.path(path);\n    if (!p) {\n      return;\n    }\n    if (!_this.$isValid(path)) {\n      return;\n    }\n\n    var val = _this.getValue(path);\n    var err = p.doValidateSync(val, _this);\n    if (err) {\n      _this.invalidate(path, err, undefined, true);\n    }\n  });\n\n  var err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n  _this.emit(\'validate\', _this);\n  _this.constructor.emit(\'validate\', _this);\n\n  if (err) {\n    for (var key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n}',
  errors: 'undefined',
  addListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  setValue: 'function (path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n}',
  '$__where': 'function _where(where) {\n  where || (where = {});\n\n  var paths,\n      len;\n\n  if (!where._id) {\n    where._id = this._doc._id;\n  }\n\n  if (this.$__.shardval) {\n    paths = Object.keys(this.$__.shardval);\n    len = paths.length;\n\n    for (var i = 0; i < len; ++i) {\n      where[paths[i]] = this.$__.shardval[paths[i]];\n    }\n  }\n\n  if (this._doc._id == null) {\n    return new Error(\'No _id found on document!\');\n  }\n\n  return where;\n}',
  invalidate: 'function (path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === \'string\') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || \'user defined\',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.errors[path] = err;\n  return this.$__.validationError;\n}',
  _doc: '[object Object]',
  execPopulate: 'function () {\n  var Promise = PromiseProvider.get();\n  var _this = this;\n  return new Promise.ES6(function(resolve, reject) {\n    _this.populate(function(error, res) {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(res);\n      }\n    });\n  });\n}',
  isSelected: 'function isSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    i = paths.length;\n    var pathDot = path + \'.\';\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n\n      if (cur.indexOf(pathDot) === 0) {\n        return inclusive || cur !== pathDot;\n      }\n\n      if (pathDot.indexOf(cur + \'.\') === 0) {\n        return inclusive;\n      }\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  _id: '5902b753c5756d72945d90b3',
  toString: 'function () {\n  return inspect(this.inspect());\n}',
  '$post': 'function (name, isAsync, fn) {\n    if (arguments.length === 2) {\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , posts = proto._posts = proto._posts || {};\n    \n    this._lazySetupHooks(proto, name);\n    (posts[name] = posts[name] || []).push(fn);\n    return this;\n  }',
  '$__handleSave': 'function (options, callback) {\n  var _this = this;\n  var i;\n  var keys;\n  var len;\n  if (!options.safe && this.schema.options.safe) {\n    options.safe = this.schema.options.safe;\n  }\n  if (typeof options.safe === \'boolean\') {\n    options.safe = null;\n  }\n\n  if (this.isNew) {\n    // send entire doc\n    var toObjectOptions = {};\n\n    toObjectOptions.retainKeyOrder = this.schema.options.retainKeyOrder;\n    toObjectOptions.depopulate = 1;\n    toObjectOptions._skipDepopulateTopLevel = true;\n    toObjectOptions.transform = false;\n    toObjectOptions.flattenDecimals = false;\n\n    var obj = this.toObject(toObjectOptions);\n\n    if (!utils.object.hasOwnProperty(obj || {}, \'_id\')) {\n      // documents must have an _id else mongoose won\'t know\n      // what to update later if more changes are made. the user\n      // wouldn\'t know what _id was generated by mongodb either\n      // nor would the ObjectId generated my mongodb necessarily\n      // match the schema definition.\n      setTimeout(function() {\n        callback(new Error(\'document must have an _id before saving\'));\n      }, 0);\n      return;\n    }\n\n    this.$__version(true, obj);\n    this.collection.insert(obj, options.safe, function(err, ret) {\n      if (err) {\n        _this.isNew = true;\n        _this.emit(\'isNew\', true);\n        _this.constructor.emit(\'isNew\', true);\n\n        callback(err);\n        return;\n      }\n\n      callback(null, ret);\n    });\n    this.$__reset();\n    this.isNew = false;\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n    // Make it possible to retry the insert\n    this.$__.inserting = true;\n  } else {\n    // Make sure we don\'t treat it as a new object on error,\n    // since it already exists\n    this.$__.inserting = false;\n\n    var delta = this.$__delta();\n\n    if (delta) {\n      if (delta instanceof Error) {\n        callback(delta);\n        return;\n      }\n\n      var where = this.$__where(delta[0]);\n      if (where instanceof Error) {\n        callback(where);\n        return;\n      }\n\n      if (this.$where) {\n        keys = Object.keys(this.$where);\n        len = keys.length;\n        for (i = 0; i < len; ++i) {\n          where[keys[i]] = this.$where[keys[i]];\n        }\n      }\n\n      this.collection.update(where, delta[1], options.safe, function(err, ret) {\n        if (err) {\n          callback(err);\n          return;\n        }\n        ret.$where = where;\n        callback(null, ret);\n      });\n    } else {\n      this.$__reset();\n      callback();\n      return;\n    }\n\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n  }\n}',
  '$ignore': 'function (path) {\n  this.$__.activePaths.ignore(path);\n}',
  emit: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  removePre: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , pres = proto._pres || (proto._pres || {});\n    if (!pres[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all pre callbacks for hook `name`\n      pres[name].length = 0;\n    } else {\n      pres[name] = pres[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  toJSON: 'function (options) {\n  return this.$toObject(options, true);\n}',
  '$__handleReject': 'function handleReject(err) {\n  // emit on the Model if listening\n  if (this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  } else if (this.constructor.listeners && this.constructor.listeners(\'error\').length) {\n    this.constructor.emit(\'error\', err);\n  } else if (this.listeners && this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  }\n}',
  set: 'function (path, val, type, options) {\n  if (type && utils.getFunctionName(type.constructor) === \'Object\') {\n    options = type;\n    type = undefined;\n  }\n\n  var merge = options && options.merge,\n      adhoc = type && type !== true,\n      constructing = type === true,\n      adhocs;\n\n  var strict = options && \'strict\' in options\n      ? options.strict\n      : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  if (typeof path !== \'string\') {\n    // new Document({ key: val })\n\n    if (path === null || path === void 0) {\n      var _ = path;\n      path = val;\n      val = _;\n    } else {\n      var prefix = val\n          ? val + \'.\'\n          : \'\';\n\n      if (path instanceof Document) {\n        if (path.$__isNested) {\n          path = path.toObject();\n        } else {\n          path = path._doc;\n        }\n      }\n\n      var keys = Object.keys(path);\n      var len = keys.length;\n      var i = 0;\n      var pathtype;\n      var key;\n\n      if (len === 0 && !this.schema.options.minimize) {\n        if (val) {\n          this.set(val, {});\n        }\n        return this;\n      }\n\n      if (this.schema.options.retainKeyOrder) {\n        while (i < len) {\n          _handleIndex.call(this, i++);\n        }\n      } else {\n        while (len--) {\n          _handleIndex.call(this, len);\n        }\n      }\n\n      return this;\n    }\n  }\n\n  function _handleIndex(i) {\n    key = keys[i];\n    var pathName = prefix + key;\n    pathtype = this.schema.pathType(pathName);\n\n    if (path[key] !== null\n        && path[key] !== void 0\n          // need to know if plain object - no Buffer, ObjectId, ref, etc\n        && utils.isObject(path[key])\n        && (!path[key].constructor || utils.getFunctionName(path[key].constructor) === \'Object\')\n        && pathtype !== \'virtual\'\n        && pathtype !== \'real\'\n        && !(this.$__path(pathName) instanceof MixedSchema)\n        && !(this.schema.paths[pathName] &&\n        this.schema.paths[pathName].options &&\n        this.schema.paths[pathName].options.ref)) {\n      this.set(path[key], prefix + key, constructing);\n    } else if (strict) {\n      // Don\'t overwrite defaults with undefined keys (gh-3981)\n      if (constructing && path[key] === void 0 &&\n          this.get(key) !== void 0) {\n        return;\n      }\n\n      if (pathtype === \'real\' || pathtype === \'virtual\') {\n        // Check for setting single embedded schema to document (gh-3535)\n        var p = path[key];\n        if (this.schema.paths[pathName] &&\n            this.schema.paths[pathName].$isSingleNested &&\n            path[key] instanceof Document) {\n          p = p.toObject({ virtuals: false, transform: false });\n        }\n        this.set(prefix + key, p, constructing);\n      } else if (pathtype === \'nested\' && path[key] instanceof Document) {\n        this.set(prefix + key,\n            path[key].toObject({transform: false}), constructing);\n      } else if (strict === \'throw\') {\n        if (pathtype === \'nested\') {\n          throw new ObjectExpectedError(key, path[key]);\n        } else {\n          throw new StrictModeError(key);\n        }\n      }\n    } else if (path[key] !== void 0) {\n      this.set(prefix + key, path[key], constructing);\n    }\n  }\n\n  var pathType = this.schema.pathType(path);\n  if (pathType === \'nested\' && val) {\n    if (utils.isObject(val) &&\n        (!val.constructor || utils.getFunctionName(val.constructor) === \'Object\')) {\n      if (!merge) {\n        this.setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      }\n\n      if (Object.keys(val).length === 0) {\n        this.setValue(path, {});\n        this.markModified(path);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        this.set(val, path, constructing);\n      }\n      return this;\n    }\n    this.invalidate(path, new MongooseError.CastError(\'Object\', val, path));\n    return this;\n  }\n\n  var schema;\n  var parts = path.split(\'.\');\n\n  if (pathType === \'adhocOrUndefined\' && strict) {\n    // check for roots that are Mixed types\n    var mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      var subpath = parts.slice(0, i + 1).join(\'.\');\n      schema = this.schema.path(subpath);\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n\n      // If path is underneath a virtual, bypass everything and just set it.\n      if (i + 1 < parts.length && this.schema.pathType(subpath) === \'virtual\') {\n        mpath.set(path, val, this);\n        return this;\n      }\n    }\n\n    if (!mixed) {\n      if (strict === \'throw\') {\n        throw new StrictModeError(path);\n      }\n      return this;\n    }\n  } else if (pathType === \'virtual\') {\n    schema = this.schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  var pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: "LEFT_SUBFIELD only supports Object"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    for (i = 0; i < parts.length; ++i) {\n      subpath = parts.slice(0, i + 1).join(\'.\');\n      if (this.isDirectModified(subpath) // earlier prefixes that are already\n            // marked as dirty have precedence\n          || this.get(subpath) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n\n  // if this doc is being constructed we should not trigger getters\n  var priorVal = constructing\n      ? undefined\n      : this.getValue(path);\n\n  if (!schema) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n    return this;\n  }\n\n  var shouldSet = true;\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    var didPopulate = false;\n    if (schema.options &&\n        schema.options.ref &&\n        val instanceof Document &&\n        (schema.options.ref === val.constructor.modelName || schema.options.ref === val.constructor.baseModelName)) {\n      if (this.ownerDocument) {\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val._id, {model: val.constructor});\n      } else {\n        this.populated(path, val._id, {model: val.constructor});\n      }\n      didPopulate = true;\n    }\n\n    var popOpts;\n    if (schema.options &&\n        Array.isArray(schema.options.type) &&\n        schema.options.type.length &&\n        schema.options.type[0].ref &&\n        Array.isArray(val) &&\n        val.length > 0 &&\n        val[0] instanceof Document &&\n        val[0].constructor.modelName &&\n        (schema.options.type[0].ref === val[0].constructor.baseModelName || schema.options.type[0].ref === val[0].constructor.modelName)) {\n      if (this.ownerDocument) {\n        popOpts = { model: val[0].constructor };\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val.map(function(v) { return v._id; }), popOpts);\n      } else {\n        popOpts = { model: val[0].constructor };\n        this.populated(path, val.map(function(v) { return v._id; }), popOpts);\n      }\n      didPopulate = true;\n    }\n    val = schema.applySetters(val, this, false, priorVal);\n\n    if (!didPopulate && this.$__.populated) {\n      delete this.$__.populated[path];\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    this.invalidate(path,\n      new MongooseError.CastError(schema.instance, val, path, e));\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n}',
  '$__delta': 'function () {\n  var dirty = this.$__dirty();\n  if (!dirty.length && VERSION_ALL !== this.$__.version) return;\n\n  var where = {},\n      delta = {},\n      len = dirty.length,\n      divergent = [],\n      d = 0;\n\n  where._id = this._doc._id;\n  if (where._id.toObject) {\n    where._id = where._id.toObject({ transform: false, depopulate: true });\n  }\n\n  for (; d < len; ++d) {\n    var data = dirty[d];\n    var value = data.value;\n\n    var match = checkDivergentArray(this, data.path, value);\n    if (match) {\n      divergent.push(match);\n      continue;\n    }\n\n    var pop = this.populated(data.path, true);\n    if (!pop && this.$__.selected) {\n      // If any array was selected using an $elemMatch projection, we alter the path and where clause\n      // NOTE: MongoDB only supports projected $elemMatch on top level array.\n      var pathSplit = data.path.split(\'.\');\n      var top = pathSplit[0];\n      if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {\n        // If the selected array entry was modified\n        if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === \'undefined\') {\n          where[top] = this.$__.selected[top];\n          pathSplit[1] = \'$\';\n          data.path = pathSplit.join(\'.\');\n        }\n        // if the selected array was modified in any other way throw an error\n        else {\n          divergent.push(data.path);\n          continue;\n        }\n      }\n    }\n\n    if (divergent.length) continue;\n\n    if (undefined === value) {\n      operand(this, where, delta, data, 1, \'$unset\');\n    } else if (value === null) {\n      operand(this, where, delta, data, null);\n    } else if (value._path && value._atomics) {\n      // arrays and other custom types (support plugins etc)\n      handleAtomics(this, where, delta, data, value);\n    } else if (value._path && Buffer.isBuffer(value)) {\n      // MongooseBuffer\n      value = value.toObject();\n      operand(this, where, delta, data, value);\n    } else {\n      value = utils.clone(value, {depopulate: 1, _isNested: true});\n      operand(this, where, delta, data, value);\n    }\n  }\n\n  if (divergent.length) {\n    return new DivergentArrayError(divergent);\n  }\n\n  if (this.$__.version) {\n    this.$__version(where, delta);\n  }\n\n  return [where, delta];\n}',
  '$__save': 'function (options, callback) {\n  var _this = this;\n\n  _this.$__handleSave(options, function(error, result) {\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.$__reset();\n    _this.$__storeShard();\n\n    var numAffected = 0;\n    if (result) {\n      if (Array.isArray(result)) {\n        numAffected = result.length;\n      } else if (result.result && result.result.n !== undefined) {\n        numAffected = result.result.n;\n      } else if (result.result && result.result.nModified !== undefined) {\n        numAffected = result.result.nModified;\n      } else {\n        numAffected = result;\n      }\n    }\n\n    // was this an update that required a version bump?\n    if (_this.$__.version && !_this.$__.inserting) {\n      var doIncrement = VERSION_INC === (VERSION_INC & _this.$__.version);\n      _this.$__.version = undefined;\n\n      if (numAffected <= 0) {\n        // the update failed. pass an error back\n        var err = new VersionError(_this);\n        return callback(err);\n      }\n\n      // increment version if was successful\n      if (doIncrement) {\n        var key = _this.schema.options.versionKey;\n        var version = _this.getValue(key) | 0;\n        _this.setValue(key, version + 1);\n      }\n    }\n\n    if (_this.schema.options &&\n        _this.schema.options.saveErrorIfNotFound &&\n        numAffected <= 0) {\n      error = new DocumentNotFoundError(result.$where);\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.emit(\'save\', _this, numAffected);\n    _this.constructor.emit(\'save\', _this, numAffected);\n    callback(null, _this, numAffected);\n  });\n}' }
[2017-05-04 15:42:14.488] [DEBUG] app - 2017-5-4 15:42:14 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:42:14.489] [WARN] console - this is a logger middleware.
[2017-05-04 15:42:14.492] [WARN] console - { depopulate: 'function (path) {\n  var populatedIds = this.populated(path);\n  if (!populatedIds) {\n    return;\n  }\n  delete this.$__.populated[path];\n  this.set(path, populatedIds);\n  return this;\n}',
  equals: 'function (doc) {\n  if (!doc) {\n    return false;\n  }\n\n  var tid = this.get(\'_id\');\n  var docid = doc.get ? doc.get(\'_id\') : doc;\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals\n      ? tid.equals(docid)\n      : tid === docid;\n}',
  _posts: '[object Object]',
  '$__getAllSubdocs': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  function docReducer(seed, path) {\n    var val = this[path];\n\n    if (val instanceof Embedded) {\n      seed.push(val);\n    }\n    if (val && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(docReducer.bind(val._doc), seed);\n      seed.push(val);\n    }\n    if (val && val.isMongooseDocumentArray) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n        seed = Object.keys(doc._doc).reduce(docReducer.bind(doc._doc), seed);\n      });\n    } else if (val instanceof Document && val.$__isNested) {\n      if (val) {\n        seed = Object.keys(val).reduce(docReducer.bind(val), seed);\n      }\n    }\n    return seed;\n  }\n\n  var subDocs = Object.keys(this._doc).reduce(docReducer.bind(this), []);\n\n  return subDocs;\n}',
  removeListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  '$__original_save': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  '$__getArrayPathsToValidate': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  // validate all document arrays.\n  return this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return this.getValue(i);\n  }.bind(this))\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  }).reduce(function(seed, array) {\n    return seed.concat(array);\n  }, [])\n  .filter(function(doc) {\n    return doc;\n  });\n}',
  schema: '[object Object]',
  removeAllListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  save: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  isDirectSelected: 'function isDirectSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  removePost: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , posts = proto._posts || (proto._posts || {});\n    if (!posts[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all post callbacks for hook `name`\n      posts[name].length = 0;\n    } else {\n      posts[name] = posts[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  _lazySetupHooks: 'function (proto, methodName, errorCb) {\n    if (\'undefined\' === typeof proto[methodName].numAsyncPres) {\n      this.$hook(methodName, proto[methodName], errorCb);\n    }\n  }',
  toBSON: 'function () {\n  return this.toObject({\n    transform: false,\n    virtuals: false,\n    _skipDepopulateTopLevel: true,\n    depopulate: true,\n    flattenDecimals: false\n  });\n}',
  markModified: 'function (path) {\n  this.$__.activePaths.modify(path);\n}',
  on: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  increment: 'function increment() {\n  this.$__.version = VERSION_ALL;\n  return this;\n}',
  validate: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populated: 'function (path, val, options) {\n  // val and options are internal\n\n  if (val === null || val === void 0) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    var v = this.$__.populated[path];\n    if (v) {\n      return v.value;\n    }\n    return undefined;\n  }\n\n  // internal\n\n  if (val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    return this.$__.populated[path];\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = {value: val, options: options};\n  return val;\n}',
  update: 'function update() {\n  var args = utils.args(arguments);\n  args.unshift({_id: this._id});\n  return this.constructor.update.apply(this.constructor, args);\n}',
  id: '5902b753c5756d72945d90b3',
  '$__setSchema': 'function (schema) {\n  compile(schema.tree, this, undefined, schema.options);\n  this.schema = schema;\n}',
  isInit: 'function (path) {\n  return (path in this.$__.activePaths.states.init);\n}',
  '$__validate': 'function (callback) {\n  var _this = this;\n  var _complete = function() {\n    var err = _this.$__.validationError;\n    _this.$__.validationError = undefined;\n    _this.emit(\'validate\', _this);\n    _this.constructor.emit(\'validate\', _this);\n    if (err) {\n      for (var key in err.errors) {\n        // Make sure cast errors persist\n        if (!_this.__parent && err.errors[key] instanceof MongooseError.CastError) {\n          _this.invalidate(key, err.errors[key]);\n        }\n      }\n\n      return err;\n    }\n  };\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (paths.length === 0) {\n    process.nextTick(function() {\n      var error = _complete();\n      if (error) {\n        return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n          callback(error);\n        });\n      }\n      callback();\n    });\n  }\n\n  var validating = {},\n      total = 0;\n\n  var complete = function() {\n    var error = _complete();\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n    callback();\n  };\n\n  var validatePath = function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n    total++;\n\n    process.nextTick(function() {\n      var p = _this.schema.path(path);\n      if (!p) {\n        return --total || complete();\n      }\n\n      // If user marked as invalid or there was a cast error, don\'t validate\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      var val = _this.getValue(path);\n      p.doValidate(val, function(err) {\n        if (err) {\n          _this.invalidate(path, err, undefined, true);\n        }\n        --total || complete();\n      }, _this);\n    });\n  };\n\n  paths.forEach(validatePath);\n}',
  username: '222',
  db: '[object Object]',
  '$__original_validate': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  discriminators: 'undefined',
  isModified: 'function (paths) {\n  if (paths) {\n    if (!Array.isArray(paths)) {\n      paths = paths.split(\' \');\n    }\n    var modified = this.modifiedPaths();\n    var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n    var isModifiedChild = paths.some(function(path) {\n      return !!~modified.indexOf(path);\n    });\n    return isModifiedChild || paths.some(function(path) {\n      return directModifiedPaths.some(function(mod) {\n        return mod === path || path.indexOf(mod + \'.\') === 0;\n      });\n    });\n  }\n  return this.$__.activePaths.some(\'modify\');\n}',
  '$pre': 'function (name, isAsync, fn, errorCb) {\n    if (\'boolean\' !== typeof arguments[1]) {\n      errorCb = fn;\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {};\n\n    this._lazySetupHooks(proto, name, errorCb);\n\n    if (fn.isAsync = isAsync) {\n      proto[name].numAsyncPres++;\n    }\n\n    (pres[name] = pres[name] || []).push(fn);\n    return this;\n  }',
  toObject: 'function (options) {\n  return this.$toObject(options);\n}',
  '$markValid': 'function (path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n}',
  '$__buildDoc': 'function (obj, fields, skipId) {\n  var doc = {};\n  var exclude = null;\n  var keys;\n  var ki;\n  var _this = this;\n\n  // determine if this doc is a result of a query with\n  // excluded fields\n\n  if (fields && utils.getFunctionName(fields.constructor) === \'Object\') {\n    keys = Object.keys(fields);\n    ki = keys.length;\n\n    if (ki === 1 && keys[0] === \'_id\') {\n      exclude = !!fields[keys[ki]];\n    } else {\n      while (ki--) {\n        if (keys[ki] !== \'_id\' &&\n            (!fields[keys[ki]] || typeof fields[keys[ki]] !== \'object\')) {\n          exclude = !fields[keys[ki]];\n          break;\n        }\n      }\n    }\n  }\n\n  var paths = Object.keys(this.schema.paths);\n  var plen = paths.length;\n  var ii = 0;\n\n  var hasIncludedChildren = {};\n  if (exclude === false && fields) {\n    keys = Object.keys(fields);\n    for (var j = 0; j < keys.length; ++j) {\n      var parts = keys[j].split(\'.\');\n      var c = [];\n      for (var k = 0; k < parts.length; ++k) {\n        c.push(parts[k]);\n        hasIncludedChildren[c.join(\'.\')] = 1;\n      }\n    }\n  }\n\n  for (; ii < plen; ++ii) {\n    var p = paths[ii];\n\n    if (p === \'_id\') {\n      if (skipId) {\n        continue;\n      }\n      if (obj && \'_id\' in obj) {\n        continue;\n      }\n    }\n\n    var type = this.schema.paths[p];\n    var path = p.split(\'.\');\n    var len = path.length;\n    var last = len - 1;\n    var curPath = \'\';\n    var doc_ = doc;\n    var i = 0;\n    var included = false;\n\n    for (; i < len; ++i) {\n      var piece = path[i],\n          def;\n\n      curPath += (!curPath.length ? \'\' : \'.\') + piece;\n\n      // support excluding intermediary levels\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i === last) {\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          } else if (included) {\n            // selected field\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          }\n        } else {\n          def = type.getDefault(_this, false);\n          if (typeof def !== \'undefined\') {\n            doc_[piece] = def;\n            _this.$__.activePaths.default(p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  return doc;\n}',
  getValue: 'function (path) {\n  return utils.getValue(path, this._doc);\n}',
  collection: '[object Object]',
  createdAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  '$isValid': 'function (path) {\n  return !this.$__.validationError || !this.$__.validationError.errors[path];\n}',
  '$__version': 'function (where, delta) {\n  var key = this.schema.options.versionKey;\n\n  if (where === true) {\n    // this is an insert\n    if (key) this.setValue(key, delta[key] = 0);\n    return;\n  }\n\n  // updates\n\n  // only apply versioning if our versionKey was selected. else\n  // there is no way to select the correct version. we could fail\n  // fast here and force them to include the versionKey but\n  // thats a bit intrusive. can we do this automatically?\n  if (!this.isSelected(key)) {\n    return;\n  }\n\n  // $push $addToSet don\'t need the where clause set\n  if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {\n    where[key] = this.getValue(key);\n  }\n\n  if (VERSION_INC === (VERSION_INC & this.$__.version)) {\n    if (!delta.$set || typeof delta.$set[key] === \'undefined\') {\n      delta.$inc || (delta.$inc = {});\n      delta.$inc[key] = 1;\n    }\n  }\n}',
  isDirectModified: 'function (path) {\n  return (path in this.$__.activePaths.states.modify);\n}',
  '$isMongooseModelPrototype': 'true',
  modifiedPaths: 'function () {\n  var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n  return directModifiedPaths.reduce(function(list, path) {\n    var parts = path.split(\'.\');\n    return list.concat(parts.reduce(function(chains, part, i) {\n      return chains.concat(parts.slice(0, i).concat(part).join(\'.\'));\n    }, []).filter(function(chain) {\n      return (list.indexOf(chain) === -1);\n    }));\n  }, []);\n}',
  updatedAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  get: 'function (path, type) {\n  var adhoc;\n  if (type) {\n    adhoc = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  var schema = this.$__path(path) || this.schema.virtualpath(path),\n      pieces = path.split(\'.\'),\n      obj = this._doc;\n\n  for (var i = 0, l = pieces.length; i < l; i++) {\n    obj = obj === null || obj === void 0\n        ? undefined\n        : obj[pieces[i]];\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  // Check if this path is populated - don\'t apply getters if it is,\n  // because otherwise its a nested object. See gh-3357\n  if (schema && !this.populated(path)) {\n    obj = schema.applyGetters(obj, this);\n  }\n\n  return obj;\n}',
  '$__path': 'function (path) {\n  var adhocs = this.$__.adhocPaths,\n      adhocType = adhocs && adhocs[path];\n\n  if (adhocType) {\n    return adhocType;\n  }\n  return this.schema.path(path);\n}',
  listeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  '$__storeShard': 'function () {\n  // backwards compat\n  var key = this.schema.options.shardKey || this.schema.options.shardkey;\n  if (!(key && utils.getFunctionName(key.constructor) === \'Object\')) {\n    return;\n  }\n\n  var orig = this.$__.shardval = {},\n      paths = Object.keys(key),\n      len = paths.length,\n      val;\n\n  for (var i = 0; i < len; ++i) {\n    val = this.getValue(paths[i]);\n    if (isMongooseObject(val)) {\n      orig[paths[i]] = val.toObject({depopulate: true, _isNested: true});\n    } else if (val !== null && val !== undefined && val.valueOf &&\n          // Explicitly don\'t take value of dates\n        (!val.constructor || utils.getFunctionName(val.constructor) !== \'Date\')) {\n      orig[paths[i]] = val.valueOf();\n    } else {\n      orig[paths[i]] = val;\n    }\n  }\n}',
  '$__dirty': 'function () {\n  var _this = this;\n\n  var all = this.$__.activePaths.map(\'modify\', function(path) {\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  });\n\n  // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n  all = all.concat(this.$__.activePaths.map(\'default\', function(path) {\n    if (path === \'_id\' || !_this.getValue(path)) {\n      return;\n    }\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n\n  // Sort dirty paths in a flat hierarchy.\n  all.sort(function(a, b) {\n    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));\n  });\n\n  // Ignore "foo.a" if "foo" is dirty already.\n  var minimal = [],\n      lastPath,\n      top;\n\n  all.forEach(function(item) {\n    if (!item) {\n      return;\n    }\n    if (item.path.indexOf(lastPath) !== 0) {\n      lastPath = item.path + \'.\';\n      minimal.push(item);\n      top = item;\n    } else {\n      // special case for top level MongooseArrays\n      if (top.value && top.value._atomics && top.value.hasAtomics()) {\n        // the `top` array itself and a sub path of `top` are being modified.\n        // the only way to honor all of both modifications is through a $set\n        // of entire array.\n        top.value._atomics = {};\n        top.value._atomics.$set = top.value;\n      }\n    }\n  });\n\n  top = lastPath = null;\n  return minimal;\n}',
  model: 'function model(name) {\n  return this.db.model(name);\n}',
  '$isDefault': 'function (path) {\n  return (path in this.$__.activePaths.states.default);\n}',
  '$__original_remove': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  remove: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populate: 'function populate() {\n  if (arguments.length === 0) {\n    return this;\n  }\n\n  var pop = this.$__.populate || (this.$__.populate = {});\n  var args = utils.args(arguments);\n  var fn;\n\n  if (typeof args[args.length - 1] === \'function\') {\n    fn = args.pop();\n  }\n\n  // allow `doc.populate(callback)`\n  if (args.length) {\n    // use hash to remove duplicate paths\n    var res = utils.populate.apply(null, args);\n    for (var i = 0; i < res.length; ++i) {\n      pop[res[i].path] = res[i];\n    }\n  }\n\n  if (fn) {\n    var paths = utils.object.vals(pop);\n    this.$__.populate = undefined;\n    paths.__noPromise = true;\n    this.constructor.populate(this, paths, fn);\n  }\n\n  return this;\n}',
  '$__shouldModify': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  if (this.isNew) {\n    return true;\n  }\n\n  if (undefined === val && !this.isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (undefined === val && path in this.$__.activePaths.states.default) {\n    // we\'re just unsetting the default value which was never saved\n    return false;\n  }\n\n  // gh-3992: if setting a populated field to a doc, don\'t mark modified\n  // if they have the same _id\n  if (this.populated(path) &&\n      val instanceof Document &&\n      deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal || this.get(path))) {\n    return true;\n  }\n\n  if (!constructing &&\n      val !== null &&\n      val !== undefined &&\n      path in this.$__.activePaths.states.default &&\n      deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n  return false;\n}',
  '$__': '[object Object]',
  '$__fullPath': 'function (path) {\n  // overridden in SubDocuments\n  return path || \'\';\n}',
  _pres: '[object Object]',
  inspect: 'function (options) {\n  var isPOJO = options &&\n    utils.getFunctionName(options.constructor) === \'Object\';\n  var opts;\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n    opts.retainKeyOrder = true;\n  }\n  return this.toObject(opts);\n}',
  '$__reset': 'function reset() {\n  var _this = this;\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return _this.getValue(i);\n  })\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  })\n  .forEach(function(array) {\n    var i = array.length;\n    while (i--) {\n      var doc = array[i];\n      if (!doc) {\n        continue;\n      }\n      doc.$__reset();\n    }\n  });\n\n  // clear atomics\n  this.$__dirty().forEach(function(dirt) {\n    var type = dirt.value;\n    if (type && type._atomics) {\n      type._atomics = {};\n    }\n  });\n\n  // Clear \'dirty\' cache\n  this.$__.activePaths.clear(\'modify\');\n  this.$__.activePaths.clear(\'default\');\n  this.$__.validationError = undefined;\n  this.errors = undefined;\n  _this = this;\n  this.schema.requiredPaths().forEach(function(path) {\n    _this.$__.activePaths.require(path);\n  });\n\n  return this;\n}',
  init: 'function (doc, opts, fn) {\n  // do not prefix this method with $__ since its\n  // used by public hooks\n\n  if (typeof opts === \'function\') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.isNew = false;\n\n  // handle docs with populated paths\n  // If doc._id is not null or undefined\n  if (doc._id !== null && doc._id !== undefined &&\n    opts && opts.populated && opts.populated.length) {\n    var id = String(doc._id);\n    for (var i = 0; i < opts.populated.length; ++i) {\n      var item = opts.populated[i];\n      if (item.isVirtual) {\n        this.populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.populated(item.path, item._docs[id], item);\n      }\n    }\n  }\n\n  init(this, doc, this._doc);\n  this.$__storeShard();\n\n  this.emit(\'init\', this);\n  this.constructor.emit(\'init\', this);\n\n  if (fn) {\n    fn(null);\n  }\n  return this;\n}',
  setMaxListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  initializeTimestamps: 'function () {\n      if (!this.get(createdAt)) {\n        this.set(createdAt, new Date());\n      }\n      if (!this.get(updatedAt)) {\n        this.set(updatedAt, new Date());\n      }\n      return this;\n    }',
  once: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  __v: '0',
  '$toObject': 'function (options, json) {\n  var defaultOptions = {\n    transform: true,\n    json: json,\n    retainKeyOrder: this.schema.options.retainKeyOrder,\n    flattenDecimals: true\n  };\n\n  // _isNested will only be true if this is not the top level document, we\n  // should never depopulate\n  if (options && options.depopulate && options._isNested && this.$__.wasPopulated) {\n    // populated paths that we set to a document\n    return clone(this._id, options);\n  }\n\n  // When internally saving this document we always pass options,\n  // bypassing the custom schema options.\n  if (!(options && utils.getFunctionName(options.constructor) === \'Object\') ||\n      (options && options._useSchemaOptions)) {\n    if (json) {\n      options = this.schema.options.toJSON ?\n        clone(this.schema.options.toJSON) :\n        {};\n      options.json = true;\n      options._useSchemaOptions = true;\n    } else {\n      options = this.schema.options.toObject ?\n        clone(this.schema.options.toObject) :\n        {};\n      options.json = false;\n      options._useSchemaOptions = true;\n    }\n  }\n\n  for (var key in defaultOptions) {\n    if (options[key] === undefined) {\n      options[key] = defaultOptions[key];\n    }\n  }\n\n  (\'minimize\' in options) || (options.minimize = this.schema.options.minimize);\n\n  // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n  var originalTransform = options.transform;\n\n  options._isNested = true;\n\n  var ret = clone(this._doc, options) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, \'paths\', options);\n    // applyGetters for paths will add nested empty objects;\n    // if minimize is set, we need to remove them.\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || options.getters && options.virtuals !== false) {\n    applyGetters(this, ret, \'virtuals\', options);\n  }\n\n  if (options.versionKey === false && this.schema.options.versionKey) {\n    delete ret[this.schema.options.versionKey];\n  }\n\n  var transform = options.transform;\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema\'s transform and\n  // not the parent schema\'s\n  if (transform === true ||\n      (this.schema.options.toObject && transform)) {\n    var opts = options.json ? this.schema.options.toJSON : this.schema.options.toObject;\n\n    if (opts) {\n      transform = (typeof options.transform === \'function\' ? options.transform : opts.transform);\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === \'function\') {\n    var xformed = transform(this, ret, options);\n    if (typeof xformed !== \'undefined\') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n}',
  '$hook': 'function (name, fn, errorCb) {\n    if (arguments.length === 1 && typeof name === \'object\') {\n      for (var k in name) { // `name` is a hash of hookName->hookFn\n        this.$hook(k, name[k]);\n      }\n      return;\n    }\n\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {}\n      , posts = proto._posts = proto._posts || {};\n    pres[name] = pres[name] || [];\n    posts[name] = posts[name] || [];\n\n    proto[name] = function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    };\n    \n    proto[name].numAsyncPres = 0;\n\n    return this;\n  }',
  '$__set': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  var shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts,\n    schema, val, priorVal);\n  var _this = this;\n\n  if (shouldModify) {\n    this.markModified(pathToMark, val);\n\n    // handle directly setting arrays (gh-1126)\n    MongooseArray || (MongooseArray = require(\'./types/array\'));\n    if (val && val.isMongooseArray) {\n      val._registerAtomic(\'$set\', val);\n\n      // Update embedded document parent references (gh-5189)\n      if (val.isMongooseDocumentArray) {\n        val.forEach(function(item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      }\n\n      // Small hack for gh-1638: if we\'re overwriting the entire array, ignore\n      // paths that were modified before the array overwrite\n      this.$__.activePaths.forEach(function(modifiedPath) {\n        if (modifiedPath.indexOf(path + \'.\') === 0) {\n          _this.$__.activePaths.ignore(modifiedPath);\n        }\n      });\n    }\n  }\n\n  var obj = this._doc;\n  var i = 0;\n  var l = parts.length;\n  var cur = \'\';\n\n  for (; i < l; i++) {\n    var next = i + 1;\n    var last = next === l;\n    cur += (cur ? \'.\' + parts[i] : parts[i]);\n\n    if (last) {\n      obj[parts[i]] = val;\n    } else {\n      if (obj[parts[i]] && utils.getFunctionName(obj[parts[i]].constructor) === \'Object\') {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        this.set(cur, {});\n        obj = obj[parts[i]];\n      }\n    }\n  }\n}',
  isNew: 'false',
  unmarkModified: 'function (path) {\n  this.$__.activePaths.init(path);\n}',
  validateSync: 'function (pathsToValidate) {\n  var _this = this;\n\n  if (typeof pathsToValidate === \'string\') {\n    pathsToValidate = pathsToValidate.split(\' \');\n  }\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (pathsToValidate && pathsToValidate.length) {\n    var tmp = [];\n    for (var i = 0; i < paths.length; ++i) {\n      if (pathsToValidate.indexOf(paths[i]) !== -1) {\n        tmp.push(paths[i]);\n      }\n    }\n    paths = tmp;\n  }\n\n  var validating = {};\n\n  paths.forEach(function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n\n    var p = _this.schema.path(path);\n    if (!p) {\n      return;\n    }\n    if (!_this.$isValid(path)) {\n      return;\n    }\n\n    var val = _this.getValue(path);\n    var err = p.doValidateSync(val, _this);\n    if (err) {\n      _this.invalidate(path, err, undefined, true);\n    }\n  });\n\n  var err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n  _this.emit(\'validate\', _this);\n  _this.constructor.emit(\'validate\', _this);\n\n  if (err) {\n    for (var key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n}',
  errors: 'undefined',
  addListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  setValue: 'function (path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n}',
  '$__where': 'function _where(where) {\n  where || (where = {});\n\n  var paths,\n      len;\n\n  if (!where._id) {\n    where._id = this._doc._id;\n  }\n\n  if (this.$__.shardval) {\n    paths = Object.keys(this.$__.shardval);\n    len = paths.length;\n\n    for (var i = 0; i < len; ++i) {\n      where[paths[i]] = this.$__.shardval[paths[i]];\n    }\n  }\n\n  if (this._doc._id == null) {\n    return new Error(\'No _id found on document!\');\n  }\n\n  return where;\n}',
  invalidate: 'function (path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === \'string\') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || \'user defined\',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.errors[path] = err;\n  return this.$__.validationError;\n}',
  _doc: '[object Object]',
  execPopulate: 'function () {\n  var Promise = PromiseProvider.get();\n  var _this = this;\n  return new Promise.ES6(function(resolve, reject) {\n    _this.populate(function(error, res) {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(res);\n      }\n    });\n  });\n}',
  isSelected: 'function isSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    i = paths.length;\n    var pathDot = path + \'.\';\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n\n      if (cur.indexOf(pathDot) === 0) {\n        return inclusive || cur !== pathDot;\n      }\n\n      if (pathDot.indexOf(cur + \'.\') === 0) {\n        return inclusive;\n      }\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  _id: '5902b753c5756d72945d90b3',
  toString: 'function () {\n  return inspect(this.inspect());\n}',
  '$post': 'function (name, isAsync, fn) {\n    if (arguments.length === 2) {\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , posts = proto._posts = proto._posts || {};\n    \n    this._lazySetupHooks(proto, name);\n    (posts[name] = posts[name] || []).push(fn);\n    return this;\n  }',
  '$__handleSave': 'function (options, callback) {\n  var _this = this;\n  var i;\n  var keys;\n  var len;\n  if (!options.safe && this.schema.options.safe) {\n    options.safe = this.schema.options.safe;\n  }\n  if (typeof options.safe === \'boolean\') {\n    options.safe = null;\n  }\n\n  if (this.isNew) {\n    // send entire doc\n    var toObjectOptions = {};\n\n    toObjectOptions.retainKeyOrder = this.schema.options.retainKeyOrder;\n    toObjectOptions.depopulate = 1;\n    toObjectOptions._skipDepopulateTopLevel = true;\n    toObjectOptions.transform = false;\n    toObjectOptions.flattenDecimals = false;\n\n    var obj = this.toObject(toObjectOptions);\n\n    if (!utils.object.hasOwnProperty(obj || {}, \'_id\')) {\n      // documents must have an _id else mongoose won\'t know\n      // what to update later if more changes are made. the user\n      // wouldn\'t know what _id was generated by mongodb either\n      // nor would the ObjectId generated my mongodb necessarily\n      // match the schema definition.\n      setTimeout(function() {\n        callback(new Error(\'document must have an _id before saving\'));\n      }, 0);\n      return;\n    }\n\n    this.$__version(true, obj);\n    this.collection.insert(obj, options.safe, function(err, ret) {\n      if (err) {\n        _this.isNew = true;\n        _this.emit(\'isNew\', true);\n        _this.constructor.emit(\'isNew\', true);\n\n        callback(err);\n        return;\n      }\n\n      callback(null, ret);\n    });\n    this.$__reset();\n    this.isNew = false;\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n    // Make it possible to retry the insert\n    this.$__.inserting = true;\n  } else {\n    // Make sure we don\'t treat it as a new object on error,\n    // since it already exists\n    this.$__.inserting = false;\n\n    var delta = this.$__delta();\n\n    if (delta) {\n      if (delta instanceof Error) {\n        callback(delta);\n        return;\n      }\n\n      var where = this.$__where(delta[0]);\n      if (where instanceof Error) {\n        callback(where);\n        return;\n      }\n\n      if (this.$where) {\n        keys = Object.keys(this.$where);\n        len = keys.length;\n        for (i = 0; i < len; ++i) {\n          where[keys[i]] = this.$where[keys[i]];\n        }\n      }\n\n      this.collection.update(where, delta[1], options.safe, function(err, ret) {\n        if (err) {\n          callback(err);\n          return;\n        }\n        ret.$where = where;\n        callback(null, ret);\n      });\n    } else {\n      this.$__reset();\n      callback();\n      return;\n    }\n\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n  }\n}',
  '$ignore': 'function (path) {\n  this.$__.activePaths.ignore(path);\n}',
  emit: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  removePre: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , pres = proto._pres || (proto._pres || {});\n    if (!pres[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all pre callbacks for hook `name`\n      pres[name].length = 0;\n    } else {\n      pres[name] = pres[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  toJSON: 'function (options) {\n  return this.$toObject(options, true);\n}',
  '$__handleReject': 'function handleReject(err) {\n  // emit on the Model if listening\n  if (this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  } else if (this.constructor.listeners && this.constructor.listeners(\'error\').length) {\n    this.constructor.emit(\'error\', err);\n  } else if (this.listeners && this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  }\n}',
  set: 'function (path, val, type, options) {\n  if (type && utils.getFunctionName(type.constructor) === \'Object\') {\n    options = type;\n    type = undefined;\n  }\n\n  var merge = options && options.merge,\n      adhoc = type && type !== true,\n      constructing = type === true,\n      adhocs;\n\n  var strict = options && \'strict\' in options\n      ? options.strict\n      : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  if (typeof path !== \'string\') {\n    // new Document({ key: val })\n\n    if (path === null || path === void 0) {\n      var _ = path;\n      path = val;\n      val = _;\n    } else {\n      var prefix = val\n          ? val + \'.\'\n          : \'\';\n\n      if (path instanceof Document) {\n        if (path.$__isNested) {\n          path = path.toObject();\n        } else {\n          path = path._doc;\n        }\n      }\n\n      var keys = Object.keys(path);\n      var len = keys.length;\n      var i = 0;\n      var pathtype;\n      var key;\n\n      if (len === 0 && !this.schema.options.minimize) {\n        if (val) {\n          this.set(val, {});\n        }\n        return this;\n      }\n\n      if (this.schema.options.retainKeyOrder) {\n        while (i < len) {\n          _handleIndex.call(this, i++);\n        }\n      } else {\n        while (len--) {\n          _handleIndex.call(this, len);\n        }\n      }\n\n      return this;\n    }\n  }\n\n  function _handleIndex(i) {\n    key = keys[i];\n    var pathName = prefix + key;\n    pathtype = this.schema.pathType(pathName);\n\n    if (path[key] !== null\n        && path[key] !== void 0\n          // need to know if plain object - no Buffer, ObjectId, ref, etc\n        && utils.isObject(path[key])\n        && (!path[key].constructor || utils.getFunctionName(path[key].constructor) === \'Object\')\n        && pathtype !== \'virtual\'\n        && pathtype !== \'real\'\n        && !(this.$__path(pathName) instanceof MixedSchema)\n        && !(this.schema.paths[pathName] &&\n        this.schema.paths[pathName].options &&\n        this.schema.paths[pathName].options.ref)) {\n      this.set(path[key], prefix + key, constructing);\n    } else if (strict) {\n      // Don\'t overwrite defaults with undefined keys (gh-3981)\n      if (constructing && path[key] === void 0 &&\n          this.get(key) !== void 0) {\n        return;\n      }\n\n      if (pathtype === \'real\' || pathtype === \'virtual\') {\n        // Check for setting single embedded schema to document (gh-3535)\n        var p = path[key];\n        if (this.schema.paths[pathName] &&\n            this.schema.paths[pathName].$isSingleNested &&\n            path[key] instanceof Document) {\n          p = p.toObject({ virtuals: false, transform: false });\n        }\n        this.set(prefix + key, p, constructing);\n      } else if (pathtype === \'nested\' && path[key] instanceof Document) {\n        this.set(prefix + key,\n            path[key].toObject({transform: false}), constructing);\n      } else if (strict === \'throw\') {\n        if (pathtype === \'nested\') {\n          throw new ObjectExpectedError(key, path[key]);\n        } else {\n          throw new StrictModeError(key);\n        }\n      }\n    } else if (path[key] !== void 0) {\n      this.set(prefix + key, path[key], constructing);\n    }\n  }\n\n  var pathType = this.schema.pathType(path);\n  if (pathType === \'nested\' && val) {\n    if (utils.isObject(val) &&\n        (!val.constructor || utils.getFunctionName(val.constructor) === \'Object\')) {\n      if (!merge) {\n        this.setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      }\n\n      if (Object.keys(val).length === 0) {\n        this.setValue(path, {});\n        this.markModified(path);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        this.set(val, path, constructing);\n      }\n      return this;\n    }\n    this.invalidate(path, new MongooseError.CastError(\'Object\', val, path));\n    return this;\n  }\n\n  var schema;\n  var parts = path.split(\'.\');\n\n  if (pathType === \'adhocOrUndefined\' && strict) {\n    // check for roots that are Mixed types\n    var mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      var subpath = parts.slice(0, i + 1).join(\'.\');\n      schema = this.schema.path(subpath);\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n\n      // If path is underneath a virtual, bypass everything and just set it.\n      if (i + 1 < parts.length && this.schema.pathType(subpath) === \'virtual\') {\n        mpath.set(path, val, this);\n        return this;\n      }\n    }\n\n    if (!mixed) {\n      if (strict === \'throw\') {\n        throw new StrictModeError(path);\n      }\n      return this;\n    }\n  } else if (pathType === \'virtual\') {\n    schema = this.schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  var pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: "LEFT_SUBFIELD only supports Object"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    for (i = 0; i < parts.length; ++i) {\n      subpath = parts.slice(0, i + 1).join(\'.\');\n      if (this.isDirectModified(subpath) // earlier prefixes that are already\n            // marked as dirty have precedence\n          || this.get(subpath) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n\n  // if this doc is being constructed we should not trigger getters\n  var priorVal = constructing\n      ? undefined\n      : this.getValue(path);\n\n  if (!schema) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n    return this;\n  }\n\n  var shouldSet = true;\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    var didPopulate = false;\n    if (schema.options &&\n        schema.options.ref &&\n        val instanceof Document &&\n        (schema.options.ref === val.constructor.modelName || schema.options.ref === val.constructor.baseModelName)) {\n      if (this.ownerDocument) {\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val._id, {model: val.constructor});\n      } else {\n        this.populated(path, val._id, {model: val.constructor});\n      }\n      didPopulate = true;\n    }\n\n    var popOpts;\n    if (schema.options &&\n        Array.isArray(schema.options.type) &&\n        schema.options.type.length &&\n        schema.options.type[0].ref &&\n        Array.isArray(val) &&\n        val.length > 0 &&\n        val[0] instanceof Document &&\n        val[0].constructor.modelName &&\n        (schema.options.type[0].ref === val[0].constructor.baseModelName || schema.options.type[0].ref === val[0].constructor.modelName)) {\n      if (this.ownerDocument) {\n        popOpts = { model: val[0].constructor };\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val.map(function(v) { return v._id; }), popOpts);\n      } else {\n        popOpts = { model: val[0].constructor };\n        this.populated(path, val.map(function(v) { return v._id; }), popOpts);\n      }\n      didPopulate = true;\n    }\n    val = schema.applySetters(val, this, false, priorVal);\n\n    if (!didPopulate && this.$__.populated) {\n      delete this.$__.populated[path];\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    this.invalidate(path,\n      new MongooseError.CastError(schema.instance, val, path, e));\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n}',
  '$__delta': 'function () {\n  var dirty = this.$__dirty();\n  if (!dirty.length && VERSION_ALL !== this.$__.version) return;\n\n  var where = {},\n      delta = {},\n      len = dirty.length,\n      divergent = [],\n      d = 0;\n\n  where._id = this._doc._id;\n  if (where._id.toObject) {\n    where._id = where._id.toObject({ transform: false, depopulate: true });\n  }\n\n  for (; d < len; ++d) {\n    var data = dirty[d];\n    var value = data.value;\n\n    var match = checkDivergentArray(this, data.path, value);\n    if (match) {\n      divergent.push(match);\n      continue;\n    }\n\n    var pop = this.populated(data.path, true);\n    if (!pop && this.$__.selected) {\n      // If any array was selected using an $elemMatch projection, we alter the path and where clause\n      // NOTE: MongoDB only supports projected $elemMatch on top level array.\n      var pathSplit = data.path.split(\'.\');\n      var top = pathSplit[0];\n      if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {\n        // If the selected array entry was modified\n        if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === \'undefined\') {\n          where[top] = this.$__.selected[top];\n          pathSplit[1] = \'$\';\n          data.path = pathSplit.join(\'.\');\n        }\n        // if the selected array was modified in any other way throw an error\n        else {\n          divergent.push(data.path);\n          continue;\n        }\n      }\n    }\n\n    if (divergent.length) continue;\n\n    if (undefined === value) {\n      operand(this, where, delta, data, 1, \'$unset\');\n    } else if (value === null) {\n      operand(this, where, delta, data, null);\n    } else if (value._path && value._atomics) {\n      // arrays and other custom types (support plugins etc)\n      handleAtomics(this, where, delta, data, value);\n    } else if (value._path && Buffer.isBuffer(value)) {\n      // MongooseBuffer\n      value = value.toObject();\n      operand(this, where, delta, data, value);\n    } else {\n      value = utils.clone(value, {depopulate: 1, _isNested: true});\n      operand(this, where, delta, data, value);\n    }\n  }\n\n  if (divergent.length) {\n    return new DivergentArrayError(divergent);\n  }\n\n  if (this.$__.version) {\n    this.$__version(where, delta);\n  }\n\n  return [where, delta];\n}',
  '$__save': 'function (options, callback) {\n  var _this = this;\n\n  _this.$__handleSave(options, function(error, result) {\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.$__reset();\n    _this.$__storeShard();\n\n    var numAffected = 0;\n    if (result) {\n      if (Array.isArray(result)) {\n        numAffected = result.length;\n      } else if (result.result && result.result.n !== undefined) {\n        numAffected = result.result.n;\n      } else if (result.result && result.result.nModified !== undefined) {\n        numAffected = result.result.nModified;\n      } else {\n        numAffected = result;\n      }\n    }\n\n    // was this an update that required a version bump?\n    if (_this.$__.version && !_this.$__.inserting) {\n      var doIncrement = VERSION_INC === (VERSION_INC & _this.$__.version);\n      _this.$__.version = undefined;\n\n      if (numAffected <= 0) {\n        // the update failed. pass an error back\n        var err = new VersionError(_this);\n        return callback(err);\n      }\n\n      // increment version if was successful\n      if (doIncrement) {\n        var key = _this.schema.options.versionKey;\n        var version = _this.getValue(key) | 0;\n        _this.setValue(key, version + 1);\n      }\n    }\n\n    if (_this.schema.options &&\n        _this.schema.options.saveErrorIfNotFound &&\n        numAffected <= 0) {\n      error = new DocumentNotFoundError(result.$where);\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.emit(\'save\', _this, numAffected);\n    _this.constructor.emit(\'save\', _this, numAffected);\n    callback(null, _this, numAffected);\n  });\n}' }
[2017-05-04 15:42:35.131] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:42:35.147] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:42:35.152] [INFO] app - Redis client default is ready {}
[2017-05-04 15:42:35.338] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:42:36.141] [DEBUG] app - 2017-5-4 15:42:36 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:42:36.146] [WARN] console - this is a logger middleware.
[2017-05-04 15:42:36.165] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:42:52.043] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:42:52.057] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:42:52.060] [INFO] app - Redis client default is ready {}
[2017-05-04 15:42:52.250] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:42:52.992] [DEBUG] app - 2017-5-4 15:42:52 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:42:52.995] [WARN] console - this is a logger middleware.
[2017-05-04 15:42:53.018] [WARN] console - { depopulate: 'function (path) {\n  var populatedIds = this.populated(path);\n  if (!populatedIds) {\n    return;\n  }\n  delete this.$__.populated[path];\n  this.set(path, populatedIds);\n  return this;\n}',
  equals: 'function (doc) {\n  if (!doc) {\n    return false;\n  }\n\n  var tid = this.get(\'_id\');\n  var docid = doc.get ? doc.get(\'_id\') : doc;\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals\n      ? tid.equals(docid)\n      : tid === docid;\n}',
  _posts: '[object Object]',
  '$__getAllSubdocs': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  function docReducer(seed, path) {\n    var val = this[path];\n\n    if (val instanceof Embedded) {\n      seed.push(val);\n    }\n    if (val && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(docReducer.bind(val._doc), seed);\n      seed.push(val);\n    }\n    if (val && val.isMongooseDocumentArray) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n        seed = Object.keys(doc._doc).reduce(docReducer.bind(doc._doc), seed);\n      });\n    } else if (val instanceof Document && val.$__isNested) {\n      if (val) {\n        seed = Object.keys(val).reduce(docReducer.bind(val), seed);\n      }\n    }\n    return seed;\n  }\n\n  var subDocs = Object.keys(this._doc).reduce(docReducer.bind(this), []);\n\n  return subDocs;\n}',
  removeListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  '$__original_save': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  '$__getArrayPathsToValidate': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  // validate all document arrays.\n  return this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return this.getValue(i);\n  }.bind(this))\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  }).reduce(function(seed, array) {\n    return seed.concat(array);\n  }, [])\n  .filter(function(doc) {\n    return doc;\n  });\n}',
  schema: '[object Object]',
  removeAllListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  save: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  isDirectSelected: 'function isDirectSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  removePost: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , posts = proto._posts || (proto._posts || {});\n    if (!posts[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all post callbacks for hook `name`\n      posts[name].length = 0;\n    } else {\n      posts[name] = posts[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  _lazySetupHooks: 'function (proto, methodName, errorCb) {\n    if (\'undefined\' === typeof proto[methodName].numAsyncPres) {\n      this.$hook(methodName, proto[methodName], errorCb);\n    }\n  }',
  toBSON: 'function () {\n  return this.toObject({\n    transform: false,\n    virtuals: false,\n    _skipDepopulateTopLevel: true,\n    depopulate: true,\n    flattenDecimals: false\n  });\n}',
  markModified: 'function (path) {\n  this.$__.activePaths.modify(path);\n}',
  on: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  increment: 'function increment() {\n  this.$__.version = VERSION_ALL;\n  return this;\n}',
  validate: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populated: 'function (path, val, options) {\n  // val and options are internal\n\n  if (val === null || val === void 0) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    var v = this.$__.populated[path];\n    if (v) {\n      return v.value;\n    }\n    return undefined;\n  }\n\n  // internal\n\n  if (val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    return this.$__.populated[path];\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = {value: val, options: options};\n  return val;\n}',
  update: 'function update() {\n  var args = utils.args(arguments);\n  args.unshift({_id: this._id});\n  return this.constructor.update.apply(this.constructor, args);\n}',
  id: '5902b753c5756d72945d90b3',
  '$__setSchema': 'function (schema) {\n  compile(schema.tree, this, undefined, schema.options);\n  this.schema = schema;\n}',
  isInit: 'function (path) {\n  return (path in this.$__.activePaths.states.init);\n}',
  '$__validate': 'function (callback) {\n  var _this = this;\n  var _complete = function() {\n    var err = _this.$__.validationError;\n    _this.$__.validationError = undefined;\n    _this.emit(\'validate\', _this);\n    _this.constructor.emit(\'validate\', _this);\n    if (err) {\n      for (var key in err.errors) {\n        // Make sure cast errors persist\n        if (!_this.__parent && err.errors[key] instanceof MongooseError.CastError) {\n          _this.invalidate(key, err.errors[key]);\n        }\n      }\n\n      return err;\n    }\n  };\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (paths.length === 0) {\n    process.nextTick(function() {\n      var error = _complete();\n      if (error) {\n        return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n          callback(error);\n        });\n      }\n      callback();\n    });\n  }\n\n  var validating = {},\n      total = 0;\n\n  var complete = function() {\n    var error = _complete();\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n    callback();\n  };\n\n  var validatePath = function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n    total++;\n\n    process.nextTick(function() {\n      var p = _this.schema.path(path);\n      if (!p) {\n        return --total || complete();\n      }\n\n      // If user marked as invalid or there was a cast error, don\'t validate\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      var val = _this.getValue(path);\n      p.doValidate(val, function(err) {\n        if (err) {\n          _this.invalidate(path, err, undefined, true);\n        }\n        --total || complete();\n      }, _this);\n    });\n  };\n\n  paths.forEach(validatePath);\n}',
  username: '222',
  db: '[object Object]',
  '$__original_validate': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  discriminators: 'undefined',
  isModified: 'function (paths) {\n  if (paths) {\n    if (!Array.isArray(paths)) {\n      paths = paths.split(\' \');\n    }\n    var modified = this.modifiedPaths();\n    var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n    var isModifiedChild = paths.some(function(path) {\n      return !!~modified.indexOf(path);\n    });\n    return isModifiedChild || paths.some(function(path) {\n      return directModifiedPaths.some(function(mod) {\n        return mod === path || path.indexOf(mod + \'.\') === 0;\n      });\n    });\n  }\n  return this.$__.activePaths.some(\'modify\');\n}',
  '$pre': 'function (name, isAsync, fn, errorCb) {\n    if (\'boolean\' !== typeof arguments[1]) {\n      errorCb = fn;\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {};\n\n    this._lazySetupHooks(proto, name, errorCb);\n\n    if (fn.isAsync = isAsync) {\n      proto[name].numAsyncPres++;\n    }\n\n    (pres[name] = pres[name] || []).push(fn);\n    return this;\n  }',
  toObject: 'function (options) {\n  return this.$toObject(options);\n}',
  '$markValid': 'function (path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n}',
  '$__buildDoc': 'function (obj, fields, skipId) {\n  var doc = {};\n  var exclude = null;\n  var keys;\n  var ki;\n  var _this = this;\n\n  // determine if this doc is a result of a query with\n  // excluded fields\n\n  if (fields && utils.getFunctionName(fields.constructor) === \'Object\') {\n    keys = Object.keys(fields);\n    ki = keys.length;\n\n    if (ki === 1 && keys[0] === \'_id\') {\n      exclude = !!fields[keys[ki]];\n    } else {\n      while (ki--) {\n        if (keys[ki] !== \'_id\' &&\n            (!fields[keys[ki]] || typeof fields[keys[ki]] !== \'object\')) {\n          exclude = !fields[keys[ki]];\n          break;\n        }\n      }\n    }\n  }\n\n  var paths = Object.keys(this.schema.paths);\n  var plen = paths.length;\n  var ii = 0;\n\n  var hasIncludedChildren = {};\n  if (exclude === false && fields) {\n    keys = Object.keys(fields);\n    for (var j = 0; j < keys.length; ++j) {\n      var parts = keys[j].split(\'.\');\n      var c = [];\n      for (var k = 0; k < parts.length; ++k) {\n        c.push(parts[k]);\n        hasIncludedChildren[c.join(\'.\')] = 1;\n      }\n    }\n  }\n\n  for (; ii < plen; ++ii) {\n    var p = paths[ii];\n\n    if (p === \'_id\') {\n      if (skipId) {\n        continue;\n      }\n      if (obj && \'_id\' in obj) {\n        continue;\n      }\n    }\n\n    var type = this.schema.paths[p];\n    var path = p.split(\'.\');\n    var len = path.length;\n    var last = len - 1;\n    var curPath = \'\';\n    var doc_ = doc;\n    var i = 0;\n    var included = false;\n\n    for (; i < len; ++i) {\n      var piece = path[i],\n          def;\n\n      curPath += (!curPath.length ? \'\' : \'.\') + piece;\n\n      // support excluding intermediary levels\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i === last) {\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          } else if (included) {\n            // selected field\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          }\n        } else {\n          def = type.getDefault(_this, false);\n          if (typeof def !== \'undefined\') {\n            doc_[piece] = def;\n            _this.$__.activePaths.default(p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  return doc;\n}',
  getValue: 'function (path) {\n  return utils.getValue(path, this._doc);\n}',
  collection: '[object Object]',
  createdAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  '$isValid': 'function (path) {\n  return !this.$__.validationError || !this.$__.validationError.errors[path];\n}',
  '$__version': 'function (where, delta) {\n  var key = this.schema.options.versionKey;\n\n  if (where === true) {\n    // this is an insert\n    if (key) this.setValue(key, delta[key] = 0);\n    return;\n  }\n\n  // updates\n\n  // only apply versioning if our versionKey was selected. else\n  // there is no way to select the correct version. we could fail\n  // fast here and force them to include the versionKey but\n  // thats a bit intrusive. can we do this automatically?\n  if (!this.isSelected(key)) {\n    return;\n  }\n\n  // $push $addToSet don\'t need the where clause set\n  if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {\n    where[key] = this.getValue(key);\n  }\n\n  if (VERSION_INC === (VERSION_INC & this.$__.version)) {\n    if (!delta.$set || typeof delta.$set[key] === \'undefined\') {\n      delta.$inc || (delta.$inc = {});\n      delta.$inc[key] = 1;\n    }\n  }\n}',
  isDirectModified: 'function (path) {\n  return (path in this.$__.activePaths.states.modify);\n}',
  '$isMongooseModelPrototype': 'true',
  modifiedPaths: 'function () {\n  var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n  return directModifiedPaths.reduce(function(list, path) {\n    var parts = path.split(\'.\');\n    return list.concat(parts.reduce(function(chains, part, i) {\n      return chains.concat(parts.slice(0, i).concat(part).join(\'.\'));\n    }, []).filter(function(chain) {\n      return (list.indexOf(chain) === -1);\n    }));\n  }, []);\n}',
  updatedAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  get: 'function (path, type) {\n  var adhoc;\n  if (type) {\n    adhoc = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  var schema = this.$__path(path) || this.schema.virtualpath(path),\n      pieces = path.split(\'.\'),\n      obj = this._doc;\n\n  for (var i = 0, l = pieces.length; i < l; i++) {\n    obj = obj === null || obj === void 0\n        ? undefined\n        : obj[pieces[i]];\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  // Check if this path is populated - don\'t apply getters if it is,\n  // because otherwise its a nested object. See gh-3357\n  if (schema && !this.populated(path)) {\n    obj = schema.applyGetters(obj, this);\n  }\n\n  return obj;\n}',
  '$__path': 'function (path) {\n  var adhocs = this.$__.adhocPaths,\n      adhocType = adhocs && adhocs[path];\n\n  if (adhocType) {\n    return adhocType;\n  }\n  return this.schema.path(path);\n}',
  listeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  '$__storeShard': 'function () {\n  // backwards compat\n  var key = this.schema.options.shardKey || this.schema.options.shardkey;\n  if (!(key && utils.getFunctionName(key.constructor) === \'Object\')) {\n    return;\n  }\n\n  var orig = this.$__.shardval = {},\n      paths = Object.keys(key),\n      len = paths.length,\n      val;\n\n  for (var i = 0; i < len; ++i) {\n    val = this.getValue(paths[i]);\n    if (isMongooseObject(val)) {\n      orig[paths[i]] = val.toObject({depopulate: true, _isNested: true});\n    } else if (val !== null && val !== undefined && val.valueOf &&\n          // Explicitly don\'t take value of dates\n        (!val.constructor || utils.getFunctionName(val.constructor) !== \'Date\')) {\n      orig[paths[i]] = val.valueOf();\n    } else {\n      orig[paths[i]] = val;\n    }\n  }\n}',
  '$__dirty': 'function () {\n  var _this = this;\n\n  var all = this.$__.activePaths.map(\'modify\', function(path) {\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  });\n\n  // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n  all = all.concat(this.$__.activePaths.map(\'default\', function(path) {\n    if (path === \'_id\' || !_this.getValue(path)) {\n      return;\n    }\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n\n  // Sort dirty paths in a flat hierarchy.\n  all.sort(function(a, b) {\n    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));\n  });\n\n  // Ignore "foo.a" if "foo" is dirty already.\n  var minimal = [],\n      lastPath,\n      top;\n\n  all.forEach(function(item) {\n    if (!item) {\n      return;\n    }\n    if (item.path.indexOf(lastPath) !== 0) {\n      lastPath = item.path + \'.\';\n      minimal.push(item);\n      top = item;\n    } else {\n      // special case for top level MongooseArrays\n      if (top.value && top.value._atomics && top.value.hasAtomics()) {\n        // the `top` array itself and a sub path of `top` are being modified.\n        // the only way to honor all of both modifications is through a $set\n        // of entire array.\n        top.value._atomics = {};\n        top.value._atomics.$set = top.value;\n      }\n    }\n  });\n\n  top = lastPath = null;\n  return minimal;\n}',
  model: 'function model(name) {\n  return this.db.model(name);\n}',
  '$isDefault': 'function (path) {\n  return (path in this.$__.activePaths.states.default);\n}',
  '$__original_remove': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  remove: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populate: 'function populate() {\n  if (arguments.length === 0) {\n    return this;\n  }\n\n  var pop = this.$__.populate || (this.$__.populate = {});\n  var args = utils.args(arguments);\n  var fn;\n\n  if (typeof args[args.length - 1] === \'function\') {\n    fn = args.pop();\n  }\n\n  // allow `doc.populate(callback)`\n  if (args.length) {\n    // use hash to remove duplicate paths\n    var res = utils.populate.apply(null, args);\n    for (var i = 0; i < res.length; ++i) {\n      pop[res[i].path] = res[i];\n    }\n  }\n\n  if (fn) {\n    var paths = utils.object.vals(pop);\n    this.$__.populate = undefined;\n    paths.__noPromise = true;\n    this.constructor.populate(this, paths, fn);\n  }\n\n  return this;\n}',
  '$__shouldModify': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  if (this.isNew) {\n    return true;\n  }\n\n  if (undefined === val && !this.isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (undefined === val && path in this.$__.activePaths.states.default) {\n    // we\'re just unsetting the default value which was never saved\n    return false;\n  }\n\n  // gh-3992: if setting a populated field to a doc, don\'t mark modified\n  // if they have the same _id\n  if (this.populated(path) &&\n      val instanceof Document &&\n      deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal || this.get(path))) {\n    return true;\n  }\n\n  if (!constructing &&\n      val !== null &&\n      val !== undefined &&\n      path in this.$__.activePaths.states.default &&\n      deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n  return false;\n}',
  '$__': '[object Object]',
  '$__fullPath': 'function (path) {\n  // overridden in SubDocuments\n  return path || \'\';\n}',
  _pres: '[object Object]',
  inspect: 'function (options) {\n  var isPOJO = options &&\n    utils.getFunctionName(options.constructor) === \'Object\';\n  var opts;\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n    opts.retainKeyOrder = true;\n  }\n  return this.toObject(opts);\n}',
  '$__reset': 'function reset() {\n  var _this = this;\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return _this.getValue(i);\n  })\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  })\n  .forEach(function(array) {\n    var i = array.length;\n    while (i--) {\n      var doc = array[i];\n      if (!doc) {\n        continue;\n      }\n      doc.$__reset();\n    }\n  });\n\n  // clear atomics\n  this.$__dirty().forEach(function(dirt) {\n    var type = dirt.value;\n    if (type && type._atomics) {\n      type._atomics = {};\n    }\n  });\n\n  // Clear \'dirty\' cache\n  this.$__.activePaths.clear(\'modify\');\n  this.$__.activePaths.clear(\'default\');\n  this.$__.validationError = undefined;\n  this.errors = undefined;\n  _this = this;\n  this.schema.requiredPaths().forEach(function(path) {\n    _this.$__.activePaths.require(path);\n  });\n\n  return this;\n}',
  init: 'function (doc, opts, fn) {\n  // do not prefix this method with $__ since its\n  // used by public hooks\n\n  if (typeof opts === \'function\') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.isNew = false;\n\n  // handle docs with populated paths\n  // If doc._id is not null or undefined\n  if (doc._id !== null && doc._id !== undefined &&\n    opts && opts.populated && opts.populated.length) {\n    var id = String(doc._id);\n    for (var i = 0; i < opts.populated.length; ++i) {\n      var item = opts.populated[i];\n      if (item.isVirtual) {\n        this.populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.populated(item.path, item._docs[id], item);\n      }\n    }\n  }\n\n  init(this, doc, this._doc);\n  this.$__storeShard();\n\n  this.emit(\'init\', this);\n  this.constructor.emit(\'init\', this);\n\n  if (fn) {\n    fn(null);\n  }\n  return this;\n}',
  setMaxListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  initializeTimestamps: 'function () {\n      if (!this.get(createdAt)) {\n        this.set(createdAt, new Date());\n      }\n      if (!this.get(updatedAt)) {\n        this.set(updatedAt, new Date());\n      }\n      return this;\n    }',
  once: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  __v: '0',
  '$toObject': 'function (options, json) {\n  var defaultOptions = {\n    transform: true,\n    json: json,\n    retainKeyOrder: this.schema.options.retainKeyOrder,\n    flattenDecimals: true\n  };\n\n  // _isNested will only be true if this is not the top level document, we\n  // should never depopulate\n  if (options && options.depopulate && options._isNested && this.$__.wasPopulated) {\n    // populated paths that we set to a document\n    return clone(this._id, options);\n  }\n\n  // When internally saving this document we always pass options,\n  // bypassing the custom schema options.\n  if (!(options && utils.getFunctionName(options.constructor) === \'Object\') ||\n      (options && options._useSchemaOptions)) {\n    if (json) {\n      options = this.schema.options.toJSON ?\n        clone(this.schema.options.toJSON) :\n        {};\n      options.json = true;\n      options._useSchemaOptions = true;\n    } else {\n      options = this.schema.options.toObject ?\n        clone(this.schema.options.toObject) :\n        {};\n      options.json = false;\n      options._useSchemaOptions = true;\n    }\n  }\n\n  for (var key in defaultOptions) {\n    if (options[key] === undefined) {\n      options[key] = defaultOptions[key];\n    }\n  }\n\n  (\'minimize\' in options) || (options.minimize = this.schema.options.minimize);\n\n  // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n  var originalTransform = options.transform;\n\n  options._isNested = true;\n\n  var ret = clone(this._doc, options) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, \'paths\', options);\n    // applyGetters for paths will add nested empty objects;\n    // if minimize is set, we need to remove them.\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || options.getters && options.virtuals !== false) {\n    applyGetters(this, ret, \'virtuals\', options);\n  }\n\n  if (options.versionKey === false && this.schema.options.versionKey) {\n    delete ret[this.schema.options.versionKey];\n  }\n\n  var transform = options.transform;\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema\'s transform and\n  // not the parent schema\'s\n  if (transform === true ||\n      (this.schema.options.toObject && transform)) {\n    var opts = options.json ? this.schema.options.toJSON : this.schema.options.toObject;\n\n    if (opts) {\n      transform = (typeof options.transform === \'function\' ? options.transform : opts.transform);\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === \'function\') {\n    var xformed = transform(this, ret, options);\n    if (typeof xformed !== \'undefined\') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n}',
  '$hook': 'function (name, fn, errorCb) {\n    if (arguments.length === 1 && typeof name === \'object\') {\n      for (var k in name) { // `name` is a hash of hookName->hookFn\n        this.$hook(k, name[k]);\n      }\n      return;\n    }\n\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {}\n      , posts = proto._posts = proto._posts || {};\n    pres[name] = pres[name] || [];\n    posts[name] = posts[name] || [];\n\n    proto[name] = function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    };\n    \n    proto[name].numAsyncPres = 0;\n\n    return this;\n  }',
  '$__set': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  var shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts,\n    schema, val, priorVal);\n  var _this = this;\n\n  if (shouldModify) {\n    this.markModified(pathToMark, val);\n\n    // handle directly setting arrays (gh-1126)\n    MongooseArray || (MongooseArray = require(\'./types/array\'));\n    if (val && val.isMongooseArray) {\n      val._registerAtomic(\'$set\', val);\n\n      // Update embedded document parent references (gh-5189)\n      if (val.isMongooseDocumentArray) {\n        val.forEach(function(item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      }\n\n      // Small hack for gh-1638: if we\'re overwriting the entire array, ignore\n      // paths that were modified before the array overwrite\n      this.$__.activePaths.forEach(function(modifiedPath) {\n        if (modifiedPath.indexOf(path + \'.\') === 0) {\n          _this.$__.activePaths.ignore(modifiedPath);\n        }\n      });\n    }\n  }\n\n  var obj = this._doc;\n  var i = 0;\n  var l = parts.length;\n  var cur = \'\';\n\n  for (; i < l; i++) {\n    var next = i + 1;\n    var last = next === l;\n    cur += (cur ? \'.\' + parts[i] : parts[i]);\n\n    if (last) {\n      obj[parts[i]] = val;\n    } else {\n      if (obj[parts[i]] && utils.getFunctionName(obj[parts[i]].constructor) === \'Object\') {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        this.set(cur, {});\n        obj = obj[parts[i]];\n      }\n    }\n  }\n}',
  isNew: 'false',
  unmarkModified: 'function (path) {\n  this.$__.activePaths.init(path);\n}',
  validateSync: 'function (pathsToValidate) {\n  var _this = this;\n\n  if (typeof pathsToValidate === \'string\') {\n    pathsToValidate = pathsToValidate.split(\' \');\n  }\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (pathsToValidate && pathsToValidate.length) {\n    var tmp = [];\n    for (var i = 0; i < paths.length; ++i) {\n      if (pathsToValidate.indexOf(paths[i]) !== -1) {\n        tmp.push(paths[i]);\n      }\n    }\n    paths = tmp;\n  }\n\n  var validating = {};\n\n  paths.forEach(function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n\n    var p = _this.schema.path(path);\n    if (!p) {\n      return;\n    }\n    if (!_this.$isValid(path)) {\n      return;\n    }\n\n    var val = _this.getValue(path);\n    var err = p.doValidateSync(val, _this);\n    if (err) {\n      _this.invalidate(path, err, undefined, true);\n    }\n  });\n\n  var err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n  _this.emit(\'validate\', _this);\n  _this.constructor.emit(\'validate\', _this);\n\n  if (err) {\n    for (var key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n}',
  errors: 'undefined',
  addListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  setValue: 'function (path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n}',
  '$__where': 'function _where(where) {\n  where || (where = {});\n\n  var paths,\n      len;\n\n  if (!where._id) {\n    where._id = this._doc._id;\n  }\n\n  if (this.$__.shardval) {\n    paths = Object.keys(this.$__.shardval);\n    len = paths.length;\n\n    for (var i = 0; i < len; ++i) {\n      where[paths[i]] = this.$__.shardval[paths[i]];\n    }\n  }\n\n  if (this._doc._id == null) {\n    return new Error(\'No _id found on document!\');\n  }\n\n  return where;\n}',
  invalidate: 'function (path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === \'string\') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || \'user defined\',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.errors[path] = err;\n  return this.$__.validationError;\n}',
  _doc: '[object Object]',
  execPopulate: 'function () {\n  var Promise = PromiseProvider.get();\n  var _this = this;\n  return new Promise.ES6(function(resolve, reject) {\n    _this.populate(function(error, res) {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(res);\n      }\n    });\n  });\n}',
  isSelected: 'function isSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    i = paths.length;\n    var pathDot = path + \'.\';\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n\n      if (cur.indexOf(pathDot) === 0) {\n        return inclusive || cur !== pathDot;\n      }\n\n      if (pathDot.indexOf(cur + \'.\') === 0) {\n        return inclusive;\n      }\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  _id: '5902b753c5756d72945d90b3',
  toString: 'function () {\n  return inspect(this.inspect());\n}',
  '$post': 'function (name, isAsync, fn) {\n    if (arguments.length === 2) {\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , posts = proto._posts = proto._posts || {};\n    \n    this._lazySetupHooks(proto, name);\n    (posts[name] = posts[name] || []).push(fn);\n    return this;\n  }',
  '$__handleSave': 'function (options, callback) {\n  var _this = this;\n  var i;\n  var keys;\n  var len;\n  if (!options.safe && this.schema.options.safe) {\n    options.safe = this.schema.options.safe;\n  }\n  if (typeof options.safe === \'boolean\') {\n    options.safe = null;\n  }\n\n  if (this.isNew) {\n    // send entire doc\n    var toObjectOptions = {};\n\n    toObjectOptions.retainKeyOrder = this.schema.options.retainKeyOrder;\n    toObjectOptions.depopulate = 1;\n    toObjectOptions._skipDepopulateTopLevel = true;\n    toObjectOptions.transform = false;\n    toObjectOptions.flattenDecimals = false;\n\n    var obj = this.toObject(toObjectOptions);\n\n    if (!utils.object.hasOwnProperty(obj || {}, \'_id\')) {\n      // documents must have an _id else mongoose won\'t know\n      // what to update later if more changes are made. the user\n      // wouldn\'t know what _id was generated by mongodb either\n      // nor would the ObjectId generated my mongodb necessarily\n      // match the schema definition.\n      setTimeout(function() {\n        callback(new Error(\'document must have an _id before saving\'));\n      }, 0);\n      return;\n    }\n\n    this.$__version(true, obj);\n    this.collection.insert(obj, options.safe, function(err, ret) {\n      if (err) {\n        _this.isNew = true;\n        _this.emit(\'isNew\', true);\n        _this.constructor.emit(\'isNew\', true);\n\n        callback(err);\n        return;\n      }\n\n      callback(null, ret);\n    });\n    this.$__reset();\n    this.isNew = false;\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n    // Make it possible to retry the insert\n    this.$__.inserting = true;\n  } else {\n    // Make sure we don\'t treat it as a new object on error,\n    // since it already exists\n    this.$__.inserting = false;\n\n    var delta = this.$__delta();\n\n    if (delta) {\n      if (delta instanceof Error) {\n        callback(delta);\n        return;\n      }\n\n      var where = this.$__where(delta[0]);\n      if (where instanceof Error) {\n        callback(where);\n        return;\n      }\n\n      if (this.$where) {\n        keys = Object.keys(this.$where);\n        len = keys.length;\n        for (i = 0; i < len; ++i) {\n          where[keys[i]] = this.$where[keys[i]];\n        }\n      }\n\n      this.collection.update(where, delta[1], options.safe, function(err, ret) {\n        if (err) {\n          callback(err);\n          return;\n        }\n        ret.$where = where;\n        callback(null, ret);\n      });\n    } else {\n      this.$__reset();\n      callback();\n      return;\n    }\n\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n  }\n}',
  '$ignore': 'function (path) {\n  this.$__.activePaths.ignore(path);\n}',
  emit: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  removePre: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , pres = proto._pres || (proto._pres || {});\n    if (!pres[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all pre callbacks for hook `name`\n      pres[name].length = 0;\n    } else {\n      pres[name] = pres[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  toJSON: 'function (options) {\n  return this.$toObject(options, true);\n}',
  '$__handleReject': 'function handleReject(err) {\n  // emit on the Model if listening\n  if (this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  } else if (this.constructor.listeners && this.constructor.listeners(\'error\').length) {\n    this.constructor.emit(\'error\', err);\n  } else if (this.listeners && this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  }\n}',
  set: 'function (path, val, type, options) {\n  if (type && utils.getFunctionName(type.constructor) === \'Object\') {\n    options = type;\n    type = undefined;\n  }\n\n  var merge = options && options.merge,\n      adhoc = type && type !== true,\n      constructing = type === true,\n      adhocs;\n\n  var strict = options && \'strict\' in options\n      ? options.strict\n      : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  if (typeof path !== \'string\') {\n    // new Document({ key: val })\n\n    if (path === null || path === void 0) {\n      var _ = path;\n      path = val;\n      val = _;\n    } else {\n      var prefix = val\n          ? val + \'.\'\n          : \'\';\n\n      if (path instanceof Document) {\n        if (path.$__isNested) {\n          path = path.toObject();\n        } else {\n          path = path._doc;\n        }\n      }\n\n      var keys = Object.keys(path);\n      var len = keys.length;\n      var i = 0;\n      var pathtype;\n      var key;\n\n      if (len === 0 && !this.schema.options.minimize) {\n        if (val) {\n          this.set(val, {});\n        }\n        return this;\n      }\n\n      if (this.schema.options.retainKeyOrder) {\n        while (i < len) {\n          _handleIndex.call(this, i++);\n        }\n      } else {\n        while (len--) {\n          _handleIndex.call(this, len);\n        }\n      }\n\n      return this;\n    }\n  }\n\n  function _handleIndex(i) {\n    key = keys[i];\n    var pathName = prefix + key;\n    pathtype = this.schema.pathType(pathName);\n\n    if (path[key] !== null\n        && path[key] !== void 0\n          // need to know if plain object - no Buffer, ObjectId, ref, etc\n        && utils.isObject(path[key])\n        && (!path[key].constructor || utils.getFunctionName(path[key].constructor) === \'Object\')\n        && pathtype !== \'virtual\'\n        && pathtype !== \'real\'\n        && !(this.$__path(pathName) instanceof MixedSchema)\n        && !(this.schema.paths[pathName] &&\n        this.schema.paths[pathName].options &&\n        this.schema.paths[pathName].options.ref)) {\n      this.set(path[key], prefix + key, constructing);\n    } else if (strict) {\n      // Don\'t overwrite defaults with undefined keys (gh-3981)\n      if (constructing && path[key] === void 0 &&\n          this.get(key) !== void 0) {\n        return;\n      }\n\n      if (pathtype === \'real\' || pathtype === \'virtual\') {\n        // Check for setting single embedded schema to document (gh-3535)\n        var p = path[key];\n        if (this.schema.paths[pathName] &&\n            this.schema.paths[pathName].$isSingleNested &&\n            path[key] instanceof Document) {\n          p = p.toObject({ virtuals: false, transform: false });\n        }\n        this.set(prefix + key, p, constructing);\n      } else if (pathtype === \'nested\' && path[key] instanceof Document) {\n        this.set(prefix + key,\n            path[key].toObject({transform: false}), constructing);\n      } else if (strict === \'throw\') {\n        if (pathtype === \'nested\') {\n          throw new ObjectExpectedError(key, path[key]);\n        } else {\n          throw new StrictModeError(key);\n        }\n      }\n    } else if (path[key] !== void 0) {\n      this.set(prefix + key, path[key], constructing);\n    }\n  }\n\n  var pathType = this.schema.pathType(path);\n  if (pathType === \'nested\' && val) {\n    if (utils.isObject(val) &&\n        (!val.constructor || utils.getFunctionName(val.constructor) === \'Object\')) {\n      if (!merge) {\n        this.setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      }\n\n      if (Object.keys(val).length === 0) {\n        this.setValue(path, {});\n        this.markModified(path);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        this.set(val, path, constructing);\n      }\n      return this;\n    }\n    this.invalidate(path, new MongooseError.CastError(\'Object\', val, path));\n    return this;\n  }\n\n  var schema;\n  var parts = path.split(\'.\');\n\n  if (pathType === \'adhocOrUndefined\' && strict) {\n    // check for roots that are Mixed types\n    var mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      var subpath = parts.slice(0, i + 1).join(\'.\');\n      schema = this.schema.path(subpath);\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n\n      // If path is underneath a virtual, bypass everything and just set it.\n      if (i + 1 < parts.length && this.schema.pathType(subpath) === \'virtual\') {\n        mpath.set(path, val, this);\n        return this;\n      }\n    }\n\n    if (!mixed) {\n      if (strict === \'throw\') {\n        throw new StrictModeError(path);\n      }\n      return this;\n    }\n  } else if (pathType === \'virtual\') {\n    schema = this.schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  var pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: "LEFT_SUBFIELD only supports Object"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    for (i = 0; i < parts.length; ++i) {\n      subpath = parts.slice(0, i + 1).join(\'.\');\n      if (this.isDirectModified(subpath) // earlier prefixes that are already\n            // marked as dirty have precedence\n          || this.get(subpath) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n\n  // if this doc is being constructed we should not trigger getters\n  var priorVal = constructing\n      ? undefined\n      : this.getValue(path);\n\n  if (!schema) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n    return this;\n  }\n\n  var shouldSet = true;\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    var didPopulate = false;\n    if (schema.options &&\n        schema.options.ref &&\n        val instanceof Document &&\n        (schema.options.ref === val.constructor.modelName || schema.options.ref === val.constructor.baseModelName)) {\n      if (this.ownerDocument) {\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val._id, {model: val.constructor});\n      } else {\n        this.populated(path, val._id, {model: val.constructor});\n      }\n      didPopulate = true;\n    }\n\n    var popOpts;\n    if (schema.options &&\n        Array.isArray(schema.options.type) &&\n        schema.options.type.length &&\n        schema.options.type[0].ref &&\n        Array.isArray(val) &&\n        val.length > 0 &&\n        val[0] instanceof Document &&\n        val[0].constructor.modelName &&\n        (schema.options.type[0].ref === val[0].constructor.baseModelName || schema.options.type[0].ref === val[0].constructor.modelName)) {\n      if (this.ownerDocument) {\n        popOpts = { model: val[0].constructor };\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val.map(function(v) { return v._id; }), popOpts);\n      } else {\n        popOpts = { model: val[0].constructor };\n        this.populated(path, val.map(function(v) { return v._id; }), popOpts);\n      }\n      didPopulate = true;\n    }\n    val = schema.applySetters(val, this, false, priorVal);\n\n    if (!didPopulate && this.$__.populated) {\n      delete this.$__.populated[path];\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    this.invalidate(path,\n      new MongooseError.CastError(schema.instance, val, path, e));\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n}',
  '$__delta': 'function () {\n  var dirty = this.$__dirty();\n  if (!dirty.length && VERSION_ALL !== this.$__.version) return;\n\n  var where = {},\n      delta = {},\n      len = dirty.length,\n      divergent = [],\n      d = 0;\n\n  where._id = this._doc._id;\n  if (where._id.toObject) {\n    where._id = where._id.toObject({ transform: false, depopulate: true });\n  }\n\n  for (; d < len; ++d) {\n    var data = dirty[d];\n    var value = data.value;\n\n    var match = checkDivergentArray(this, data.path, value);\n    if (match) {\n      divergent.push(match);\n      continue;\n    }\n\n    var pop = this.populated(data.path, true);\n    if (!pop && this.$__.selected) {\n      // If any array was selected using an $elemMatch projection, we alter the path and where clause\n      // NOTE: MongoDB only supports projected $elemMatch on top level array.\n      var pathSplit = data.path.split(\'.\');\n      var top = pathSplit[0];\n      if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {\n        // If the selected array entry was modified\n        if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === \'undefined\') {\n          where[top] = this.$__.selected[top];\n          pathSplit[1] = \'$\';\n          data.path = pathSplit.join(\'.\');\n        }\n        // if the selected array was modified in any other way throw an error\n        else {\n          divergent.push(data.path);\n          continue;\n        }\n      }\n    }\n\n    if (divergent.length) continue;\n\n    if (undefined === value) {\n      operand(this, where, delta, data, 1, \'$unset\');\n    } else if (value === null) {\n      operand(this, where, delta, data, null);\n    } else if (value._path && value._atomics) {\n      // arrays and other custom types (support plugins etc)\n      handleAtomics(this, where, delta, data, value);\n    } else if (value._path && Buffer.isBuffer(value)) {\n      // MongooseBuffer\n      value = value.toObject();\n      operand(this, where, delta, data, value);\n    } else {\n      value = utils.clone(value, {depopulate: 1, _isNested: true});\n      operand(this, where, delta, data, value);\n    }\n  }\n\n  if (divergent.length) {\n    return new DivergentArrayError(divergent);\n  }\n\n  if (this.$__.version) {\n    this.$__version(where, delta);\n  }\n\n  return [where, delta];\n}',
  '$__save': 'function (options, callback) {\n  var _this = this;\n\n  _this.$__handleSave(options, function(error, result) {\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.$__reset();\n    _this.$__storeShard();\n\n    var numAffected = 0;\n    if (result) {\n      if (Array.isArray(result)) {\n        numAffected = result.length;\n      } else if (result.result && result.result.n !== undefined) {\n        numAffected = result.result.n;\n      } else if (result.result && result.result.nModified !== undefined) {\n        numAffected = result.result.nModified;\n      } else {\n        numAffected = result;\n      }\n    }\n\n    // was this an update that required a version bump?\n    if (_this.$__.version && !_this.$__.inserting) {\n      var doIncrement = VERSION_INC === (VERSION_INC & _this.$__.version);\n      _this.$__.version = undefined;\n\n      if (numAffected <= 0) {\n        // the update failed. pass an error back\n        var err = new VersionError(_this);\n        return callback(err);\n      }\n\n      // increment version if was successful\n      if (doIncrement) {\n        var key = _this.schema.options.versionKey;\n        var version = _this.getValue(key) | 0;\n        _this.setValue(key, version + 1);\n      }\n    }\n\n    if (_this.schema.options &&\n        _this.schema.options.saveErrorIfNotFound &&\n        numAffected <= 0) {\n      error = new DocumentNotFoundError(result.$where);\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.emit(\'save\', _this, numAffected);\n    _this.constructor.emit(\'save\', _this, numAffected);\n    callback(null, _this, numAffected);\n  });\n}' }
[2017-05-04 15:43:22.360] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:43:22.369] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:43:22.373] [INFO] app - Redis client default is ready {}
[2017-05-04 15:43:22.587] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:43:24.089] [DEBUG] app - 2017-5-4 15:43:24 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:43:24.093] [WARN] console - this is a logger middleware.
[2017-05-04 15:43:24.116] [WARN] console - { depopulate: 'function (path) {\n  var populatedIds = this.populated(path);\n  if (!populatedIds) {\n    return;\n  }\n  delete this.$__.populated[path];\n  this.set(path, populatedIds);\n  return this;\n}',
  equals: 'function (doc) {\n  if (!doc) {\n    return false;\n  }\n\n  var tid = this.get(\'_id\');\n  var docid = doc.get ? doc.get(\'_id\') : doc;\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals\n      ? tid.equals(docid)\n      : tid === docid;\n}',
  _posts: '[object Object]',
  '$__getAllSubdocs': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  function docReducer(seed, path) {\n    var val = this[path];\n\n    if (val instanceof Embedded) {\n      seed.push(val);\n    }\n    if (val && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(docReducer.bind(val._doc), seed);\n      seed.push(val);\n    }\n    if (val && val.isMongooseDocumentArray) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n        seed = Object.keys(doc._doc).reduce(docReducer.bind(doc._doc), seed);\n      });\n    } else if (val instanceof Document && val.$__isNested) {\n      if (val) {\n        seed = Object.keys(val).reduce(docReducer.bind(val), seed);\n      }\n    }\n    return seed;\n  }\n\n  var subDocs = Object.keys(this._doc).reduce(docReducer.bind(this), []);\n\n  return subDocs;\n}',
  removeListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  '$__original_save': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  '$__getArrayPathsToValidate': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  // validate all document arrays.\n  return this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return this.getValue(i);\n  }.bind(this))\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  }).reduce(function(seed, array) {\n    return seed.concat(array);\n  }, [])\n  .filter(function(doc) {\n    return doc;\n  });\n}',
  schema: '[object Object]',
  removeAllListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  save: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  isDirectSelected: 'function isDirectSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  removePost: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , posts = proto._posts || (proto._posts || {});\n    if (!posts[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all post callbacks for hook `name`\n      posts[name].length = 0;\n    } else {\n      posts[name] = posts[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  _lazySetupHooks: 'function (proto, methodName, errorCb) {\n    if (\'undefined\' === typeof proto[methodName].numAsyncPres) {\n      this.$hook(methodName, proto[methodName], errorCb);\n    }\n  }',
  toBSON: 'function () {\n  return this.toObject({\n    transform: false,\n    virtuals: false,\n    _skipDepopulateTopLevel: true,\n    depopulate: true,\n    flattenDecimals: false\n  });\n}',
  markModified: 'function (path) {\n  this.$__.activePaths.modify(path);\n}',
  on: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  increment: 'function increment() {\n  this.$__.version = VERSION_ALL;\n  return this;\n}',
  validate: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populated: 'function (path, val, options) {\n  // val and options are internal\n\n  if (val === null || val === void 0) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    var v = this.$__.populated[path];\n    if (v) {\n      return v.value;\n    }\n    return undefined;\n  }\n\n  // internal\n\n  if (val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    return this.$__.populated[path];\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = {value: val, options: options};\n  return val;\n}',
  update: 'function update() {\n  var args = utils.args(arguments);\n  args.unshift({_id: this._id});\n  return this.constructor.update.apply(this.constructor, args);\n}',
  id: '5902b753c5756d72945d90b3',
  '$__setSchema': 'function (schema) {\n  compile(schema.tree, this, undefined, schema.options);\n  this.schema = schema;\n}',
  isInit: 'function (path) {\n  return (path in this.$__.activePaths.states.init);\n}',
  '$__validate': 'function (callback) {\n  var _this = this;\n  var _complete = function() {\n    var err = _this.$__.validationError;\n    _this.$__.validationError = undefined;\n    _this.emit(\'validate\', _this);\n    _this.constructor.emit(\'validate\', _this);\n    if (err) {\n      for (var key in err.errors) {\n        // Make sure cast errors persist\n        if (!_this.__parent && err.errors[key] instanceof MongooseError.CastError) {\n          _this.invalidate(key, err.errors[key]);\n        }\n      }\n\n      return err;\n    }\n  };\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (paths.length === 0) {\n    process.nextTick(function() {\n      var error = _complete();\n      if (error) {\n        return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n          callback(error);\n        });\n      }\n      callback();\n    });\n  }\n\n  var validating = {},\n      total = 0;\n\n  var complete = function() {\n    var error = _complete();\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n    callback();\n  };\n\n  var validatePath = function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n    total++;\n\n    process.nextTick(function() {\n      var p = _this.schema.path(path);\n      if (!p) {\n        return --total || complete();\n      }\n\n      // If user marked as invalid or there was a cast error, don\'t validate\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      var val = _this.getValue(path);\n      p.doValidate(val, function(err) {\n        if (err) {\n          _this.invalidate(path, err, undefined, true);\n        }\n        --total || complete();\n      }, _this);\n    });\n  };\n\n  paths.forEach(validatePath);\n}',
  username: '222',
  db: '[object Object]',
  '$__original_validate': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  discriminators: 'undefined',
  isModified: 'function (paths) {\n  if (paths) {\n    if (!Array.isArray(paths)) {\n      paths = paths.split(\' \');\n    }\n    var modified = this.modifiedPaths();\n    var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n    var isModifiedChild = paths.some(function(path) {\n      return !!~modified.indexOf(path);\n    });\n    return isModifiedChild || paths.some(function(path) {\n      return directModifiedPaths.some(function(mod) {\n        return mod === path || path.indexOf(mod + \'.\') === 0;\n      });\n    });\n  }\n  return this.$__.activePaths.some(\'modify\');\n}',
  '$pre': 'function (name, isAsync, fn, errorCb) {\n    if (\'boolean\' !== typeof arguments[1]) {\n      errorCb = fn;\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {};\n\n    this._lazySetupHooks(proto, name, errorCb);\n\n    if (fn.isAsync = isAsync) {\n      proto[name].numAsyncPres++;\n    }\n\n    (pres[name] = pres[name] || []).push(fn);\n    return this;\n  }',
  toObject: 'function (options) {\n  return this.$toObject(options);\n}',
  '$markValid': 'function (path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n}',
  '$__buildDoc': 'function (obj, fields, skipId) {\n  var doc = {};\n  var exclude = null;\n  var keys;\n  var ki;\n  var _this = this;\n\n  // determine if this doc is a result of a query with\n  // excluded fields\n\n  if (fields && utils.getFunctionName(fields.constructor) === \'Object\') {\n    keys = Object.keys(fields);\n    ki = keys.length;\n\n    if (ki === 1 && keys[0] === \'_id\') {\n      exclude = !!fields[keys[ki]];\n    } else {\n      while (ki--) {\n        if (keys[ki] !== \'_id\' &&\n            (!fields[keys[ki]] || typeof fields[keys[ki]] !== \'object\')) {\n          exclude = !fields[keys[ki]];\n          break;\n        }\n      }\n    }\n  }\n\n  var paths = Object.keys(this.schema.paths);\n  var plen = paths.length;\n  var ii = 0;\n\n  var hasIncludedChildren = {};\n  if (exclude === false && fields) {\n    keys = Object.keys(fields);\n    for (var j = 0; j < keys.length; ++j) {\n      var parts = keys[j].split(\'.\');\n      var c = [];\n      for (var k = 0; k < parts.length; ++k) {\n        c.push(parts[k]);\n        hasIncludedChildren[c.join(\'.\')] = 1;\n      }\n    }\n  }\n\n  for (; ii < plen; ++ii) {\n    var p = paths[ii];\n\n    if (p === \'_id\') {\n      if (skipId) {\n        continue;\n      }\n      if (obj && \'_id\' in obj) {\n        continue;\n      }\n    }\n\n    var type = this.schema.paths[p];\n    var path = p.split(\'.\');\n    var len = path.length;\n    var last = len - 1;\n    var curPath = \'\';\n    var doc_ = doc;\n    var i = 0;\n    var included = false;\n\n    for (; i < len; ++i) {\n      var piece = path[i],\n          def;\n\n      curPath += (!curPath.length ? \'\' : \'.\') + piece;\n\n      // support excluding intermediary levels\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i === last) {\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          } else if (included) {\n            // selected field\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          }\n        } else {\n          def = type.getDefault(_this, false);\n          if (typeof def !== \'undefined\') {\n            doc_[piece] = def;\n            _this.$__.activePaths.default(p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  return doc;\n}',
  getValue: 'function (path) {\n  return utils.getValue(path, this._doc);\n}',
  collection: '[object Object]',
  createdAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  '$isValid': 'function (path) {\n  return !this.$__.validationError || !this.$__.validationError.errors[path];\n}',
  '$__version': 'function (where, delta) {\n  var key = this.schema.options.versionKey;\n\n  if (where === true) {\n    // this is an insert\n    if (key) this.setValue(key, delta[key] = 0);\n    return;\n  }\n\n  // updates\n\n  // only apply versioning if our versionKey was selected. else\n  // there is no way to select the correct version. we could fail\n  // fast here and force them to include the versionKey but\n  // thats a bit intrusive. can we do this automatically?\n  if (!this.isSelected(key)) {\n    return;\n  }\n\n  // $push $addToSet don\'t need the where clause set\n  if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {\n    where[key] = this.getValue(key);\n  }\n\n  if (VERSION_INC === (VERSION_INC & this.$__.version)) {\n    if (!delta.$set || typeof delta.$set[key] === \'undefined\') {\n      delta.$inc || (delta.$inc = {});\n      delta.$inc[key] = 1;\n    }\n  }\n}',
  isDirectModified: 'function (path) {\n  return (path in this.$__.activePaths.states.modify);\n}',
  '$isMongooseModelPrototype': 'true',
  modifiedPaths: 'function () {\n  var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n  return directModifiedPaths.reduce(function(list, path) {\n    var parts = path.split(\'.\');\n    return list.concat(parts.reduce(function(chains, part, i) {\n      return chains.concat(parts.slice(0, i).concat(part).join(\'.\'));\n    }, []).filter(function(chain) {\n      return (list.indexOf(chain) === -1);\n    }));\n  }, []);\n}',
  updatedAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  get: 'function (path, type) {\n  var adhoc;\n  if (type) {\n    adhoc = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  var schema = this.$__path(path) || this.schema.virtualpath(path),\n      pieces = path.split(\'.\'),\n      obj = this._doc;\n\n  for (var i = 0, l = pieces.length; i < l; i++) {\n    obj = obj === null || obj === void 0\n        ? undefined\n        : obj[pieces[i]];\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  // Check if this path is populated - don\'t apply getters if it is,\n  // because otherwise its a nested object. See gh-3357\n  if (schema && !this.populated(path)) {\n    obj = schema.applyGetters(obj, this);\n  }\n\n  return obj;\n}',
  '$__path': 'function (path) {\n  var adhocs = this.$__.adhocPaths,\n      adhocType = adhocs && adhocs[path];\n\n  if (adhocType) {\n    return adhocType;\n  }\n  return this.schema.path(path);\n}',
  listeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  '$__storeShard': 'function () {\n  // backwards compat\n  var key = this.schema.options.shardKey || this.schema.options.shardkey;\n  if (!(key && utils.getFunctionName(key.constructor) === \'Object\')) {\n    return;\n  }\n\n  var orig = this.$__.shardval = {},\n      paths = Object.keys(key),\n      len = paths.length,\n      val;\n\n  for (var i = 0; i < len; ++i) {\n    val = this.getValue(paths[i]);\n    if (isMongooseObject(val)) {\n      orig[paths[i]] = val.toObject({depopulate: true, _isNested: true});\n    } else if (val !== null && val !== undefined && val.valueOf &&\n          // Explicitly don\'t take value of dates\n        (!val.constructor || utils.getFunctionName(val.constructor) !== \'Date\')) {\n      orig[paths[i]] = val.valueOf();\n    } else {\n      orig[paths[i]] = val;\n    }\n  }\n}',
  '$__dirty': 'function () {\n  var _this = this;\n\n  var all = this.$__.activePaths.map(\'modify\', function(path) {\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  });\n\n  // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n  all = all.concat(this.$__.activePaths.map(\'default\', function(path) {\n    if (path === \'_id\' || !_this.getValue(path)) {\n      return;\n    }\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n\n  // Sort dirty paths in a flat hierarchy.\n  all.sort(function(a, b) {\n    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));\n  });\n\n  // Ignore "foo.a" if "foo" is dirty already.\n  var minimal = [],\n      lastPath,\n      top;\n\n  all.forEach(function(item) {\n    if (!item) {\n      return;\n    }\n    if (item.path.indexOf(lastPath) !== 0) {\n      lastPath = item.path + \'.\';\n      minimal.push(item);\n      top = item;\n    } else {\n      // special case for top level MongooseArrays\n      if (top.value && top.value._atomics && top.value.hasAtomics()) {\n        // the `top` array itself and a sub path of `top` are being modified.\n        // the only way to honor all of both modifications is through a $set\n        // of entire array.\n        top.value._atomics = {};\n        top.value._atomics.$set = top.value;\n      }\n    }\n  });\n\n  top = lastPath = null;\n  return minimal;\n}',
  model: 'function model(name) {\n  return this.db.model(name);\n}',
  '$isDefault': 'function (path) {\n  return (path in this.$__.activePaths.states.default);\n}',
  '$__original_remove': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  remove: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populate: 'function populate() {\n  if (arguments.length === 0) {\n    return this;\n  }\n\n  var pop = this.$__.populate || (this.$__.populate = {});\n  var args = utils.args(arguments);\n  var fn;\n\n  if (typeof args[args.length - 1] === \'function\') {\n    fn = args.pop();\n  }\n\n  // allow `doc.populate(callback)`\n  if (args.length) {\n    // use hash to remove duplicate paths\n    var res = utils.populate.apply(null, args);\n    for (var i = 0; i < res.length; ++i) {\n      pop[res[i].path] = res[i];\n    }\n  }\n\n  if (fn) {\n    var paths = utils.object.vals(pop);\n    this.$__.populate = undefined;\n    paths.__noPromise = true;\n    this.constructor.populate(this, paths, fn);\n  }\n\n  return this;\n}',
  '$__shouldModify': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  if (this.isNew) {\n    return true;\n  }\n\n  if (undefined === val && !this.isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (undefined === val && path in this.$__.activePaths.states.default) {\n    // we\'re just unsetting the default value which was never saved\n    return false;\n  }\n\n  // gh-3992: if setting a populated field to a doc, don\'t mark modified\n  // if they have the same _id\n  if (this.populated(path) &&\n      val instanceof Document &&\n      deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal || this.get(path))) {\n    return true;\n  }\n\n  if (!constructing &&\n      val !== null &&\n      val !== undefined &&\n      path in this.$__.activePaths.states.default &&\n      deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n  return false;\n}',
  '$__': '[object Object]',
  '$__fullPath': 'function (path) {\n  // overridden in SubDocuments\n  return path || \'\';\n}',
  _pres: '[object Object]',
  inspect: 'function (options) {\n  var isPOJO = options &&\n    utils.getFunctionName(options.constructor) === \'Object\';\n  var opts;\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n    opts.retainKeyOrder = true;\n  }\n  return this.toObject(opts);\n}',
  '$__reset': 'function reset() {\n  var _this = this;\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return _this.getValue(i);\n  })\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  })\n  .forEach(function(array) {\n    var i = array.length;\n    while (i--) {\n      var doc = array[i];\n      if (!doc) {\n        continue;\n      }\n      doc.$__reset();\n    }\n  });\n\n  // clear atomics\n  this.$__dirty().forEach(function(dirt) {\n    var type = dirt.value;\n    if (type && type._atomics) {\n      type._atomics = {};\n    }\n  });\n\n  // Clear \'dirty\' cache\n  this.$__.activePaths.clear(\'modify\');\n  this.$__.activePaths.clear(\'default\');\n  this.$__.validationError = undefined;\n  this.errors = undefined;\n  _this = this;\n  this.schema.requiredPaths().forEach(function(path) {\n    _this.$__.activePaths.require(path);\n  });\n\n  return this;\n}',
  init: 'function (doc, opts, fn) {\n  // do not prefix this method with $__ since its\n  // used by public hooks\n\n  if (typeof opts === \'function\') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.isNew = false;\n\n  // handle docs with populated paths\n  // If doc._id is not null or undefined\n  if (doc._id !== null && doc._id !== undefined &&\n    opts && opts.populated && opts.populated.length) {\n    var id = String(doc._id);\n    for (var i = 0; i < opts.populated.length; ++i) {\n      var item = opts.populated[i];\n      if (item.isVirtual) {\n        this.populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.populated(item.path, item._docs[id], item);\n      }\n    }\n  }\n\n  init(this, doc, this._doc);\n  this.$__storeShard();\n\n  this.emit(\'init\', this);\n  this.constructor.emit(\'init\', this);\n\n  if (fn) {\n    fn(null);\n  }\n  return this;\n}',
  setMaxListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  initializeTimestamps: 'function () {\n      if (!this.get(createdAt)) {\n        this.set(createdAt, new Date());\n      }\n      if (!this.get(updatedAt)) {\n        this.set(updatedAt, new Date());\n      }\n      return this;\n    }',
  once: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  __v: '0',
  '$toObject': 'function (options, json) {\n  var defaultOptions = {\n    transform: true,\n    json: json,\n    retainKeyOrder: this.schema.options.retainKeyOrder,\n    flattenDecimals: true\n  };\n\n  // _isNested will only be true if this is not the top level document, we\n  // should never depopulate\n  if (options && options.depopulate && options._isNested && this.$__.wasPopulated) {\n    // populated paths that we set to a document\n    return clone(this._id, options);\n  }\n\n  // When internally saving this document we always pass options,\n  // bypassing the custom schema options.\n  if (!(options && utils.getFunctionName(options.constructor) === \'Object\') ||\n      (options && options._useSchemaOptions)) {\n    if (json) {\n      options = this.schema.options.toJSON ?\n        clone(this.schema.options.toJSON) :\n        {};\n      options.json = true;\n      options._useSchemaOptions = true;\n    } else {\n      options = this.schema.options.toObject ?\n        clone(this.schema.options.toObject) :\n        {};\n      options.json = false;\n      options._useSchemaOptions = true;\n    }\n  }\n\n  for (var key in defaultOptions) {\n    if (options[key] === undefined) {\n      options[key] = defaultOptions[key];\n    }\n  }\n\n  (\'minimize\' in options) || (options.minimize = this.schema.options.minimize);\n\n  // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n  var originalTransform = options.transform;\n\n  options._isNested = true;\n\n  var ret = clone(this._doc, options) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, \'paths\', options);\n    // applyGetters for paths will add nested empty objects;\n    // if minimize is set, we need to remove them.\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || options.getters && options.virtuals !== false) {\n    applyGetters(this, ret, \'virtuals\', options);\n  }\n\n  if (options.versionKey === false && this.schema.options.versionKey) {\n    delete ret[this.schema.options.versionKey];\n  }\n\n  var transform = options.transform;\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema\'s transform and\n  // not the parent schema\'s\n  if (transform === true ||\n      (this.schema.options.toObject && transform)) {\n    var opts = options.json ? this.schema.options.toJSON : this.schema.options.toObject;\n\n    if (opts) {\n      transform = (typeof options.transform === \'function\' ? options.transform : opts.transform);\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === \'function\') {\n    var xformed = transform(this, ret, options);\n    if (typeof xformed !== \'undefined\') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n}',
  '$hook': 'function (name, fn, errorCb) {\n    if (arguments.length === 1 && typeof name === \'object\') {\n      for (var k in name) { // `name` is a hash of hookName->hookFn\n        this.$hook(k, name[k]);\n      }\n      return;\n    }\n\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {}\n      , posts = proto._posts = proto._posts || {};\n    pres[name] = pres[name] || [];\n    posts[name] = posts[name] || [];\n\n    proto[name] = function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    };\n    \n    proto[name].numAsyncPres = 0;\n\n    return this;\n  }',
  '$__set': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  var shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts,\n    schema, val, priorVal);\n  var _this = this;\n\n  if (shouldModify) {\n    this.markModified(pathToMark, val);\n\n    // handle directly setting arrays (gh-1126)\n    MongooseArray || (MongooseArray = require(\'./types/array\'));\n    if (val && val.isMongooseArray) {\n      val._registerAtomic(\'$set\', val);\n\n      // Update embedded document parent references (gh-5189)\n      if (val.isMongooseDocumentArray) {\n        val.forEach(function(item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      }\n\n      // Small hack for gh-1638: if we\'re overwriting the entire array, ignore\n      // paths that were modified before the array overwrite\n      this.$__.activePaths.forEach(function(modifiedPath) {\n        if (modifiedPath.indexOf(path + \'.\') === 0) {\n          _this.$__.activePaths.ignore(modifiedPath);\n        }\n      });\n    }\n  }\n\n  var obj = this._doc;\n  var i = 0;\n  var l = parts.length;\n  var cur = \'\';\n\n  for (; i < l; i++) {\n    var next = i + 1;\n    var last = next === l;\n    cur += (cur ? \'.\' + parts[i] : parts[i]);\n\n    if (last) {\n      obj[parts[i]] = val;\n    } else {\n      if (obj[parts[i]] && utils.getFunctionName(obj[parts[i]].constructor) === \'Object\') {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        this.set(cur, {});\n        obj = obj[parts[i]];\n      }\n    }\n  }\n}',
  isNew: 'false',
  unmarkModified: 'function (path) {\n  this.$__.activePaths.init(path);\n}',
  validateSync: 'function (pathsToValidate) {\n  var _this = this;\n\n  if (typeof pathsToValidate === \'string\') {\n    pathsToValidate = pathsToValidate.split(\' \');\n  }\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (pathsToValidate && pathsToValidate.length) {\n    var tmp = [];\n    for (var i = 0; i < paths.length; ++i) {\n      if (pathsToValidate.indexOf(paths[i]) !== -1) {\n        tmp.push(paths[i]);\n      }\n    }\n    paths = tmp;\n  }\n\n  var validating = {};\n\n  paths.forEach(function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n\n    var p = _this.schema.path(path);\n    if (!p) {\n      return;\n    }\n    if (!_this.$isValid(path)) {\n      return;\n    }\n\n    var val = _this.getValue(path);\n    var err = p.doValidateSync(val, _this);\n    if (err) {\n      _this.invalidate(path, err, undefined, true);\n    }\n  });\n\n  var err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n  _this.emit(\'validate\', _this);\n  _this.constructor.emit(\'validate\', _this);\n\n  if (err) {\n    for (var key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n}',
  errors: 'undefined',
  addListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  setValue: 'function (path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n}',
  '$__where': 'function _where(where) {\n  where || (where = {});\n\n  var paths,\n      len;\n\n  if (!where._id) {\n    where._id = this._doc._id;\n  }\n\n  if (this.$__.shardval) {\n    paths = Object.keys(this.$__.shardval);\n    len = paths.length;\n\n    for (var i = 0; i < len; ++i) {\n      where[paths[i]] = this.$__.shardval[paths[i]];\n    }\n  }\n\n  if (this._doc._id == null) {\n    return new Error(\'No _id found on document!\');\n  }\n\n  return where;\n}',
  invalidate: 'function (path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === \'string\') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || \'user defined\',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.errors[path] = err;\n  return this.$__.validationError;\n}',
  _doc: '[object Object]',
  execPopulate: 'function () {\n  var Promise = PromiseProvider.get();\n  var _this = this;\n  return new Promise.ES6(function(resolve, reject) {\n    _this.populate(function(error, res) {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(res);\n      }\n    });\n  });\n}',
  isSelected: 'function isSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    i = paths.length;\n    var pathDot = path + \'.\';\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n\n      if (cur.indexOf(pathDot) === 0) {\n        return inclusive || cur !== pathDot;\n      }\n\n      if (pathDot.indexOf(cur + \'.\') === 0) {\n        return inclusive;\n      }\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  _id: '5902b753c5756d72945d90b3',
  toString: 'function () {\n  return inspect(this.inspect());\n}',
  '$post': 'function (name, isAsync, fn) {\n    if (arguments.length === 2) {\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , posts = proto._posts = proto._posts || {};\n    \n    this._lazySetupHooks(proto, name);\n    (posts[name] = posts[name] || []).push(fn);\n    return this;\n  }',
  '$__handleSave': 'function (options, callback) {\n  var _this = this;\n  var i;\n  var keys;\n  var len;\n  if (!options.safe && this.schema.options.safe) {\n    options.safe = this.schema.options.safe;\n  }\n  if (typeof options.safe === \'boolean\') {\n    options.safe = null;\n  }\n\n  if (this.isNew) {\n    // send entire doc\n    var toObjectOptions = {};\n\n    toObjectOptions.retainKeyOrder = this.schema.options.retainKeyOrder;\n    toObjectOptions.depopulate = 1;\n    toObjectOptions._skipDepopulateTopLevel = true;\n    toObjectOptions.transform = false;\n    toObjectOptions.flattenDecimals = false;\n\n    var obj = this.toObject(toObjectOptions);\n\n    if (!utils.object.hasOwnProperty(obj || {}, \'_id\')) {\n      // documents must have an _id else mongoose won\'t know\n      // what to update later if more changes are made. the user\n      // wouldn\'t know what _id was generated by mongodb either\n      // nor would the ObjectId generated my mongodb necessarily\n      // match the schema definition.\n      setTimeout(function() {\n        callback(new Error(\'document must have an _id before saving\'));\n      }, 0);\n      return;\n    }\n\n    this.$__version(true, obj);\n    this.collection.insert(obj, options.safe, function(err, ret) {\n      if (err) {\n        _this.isNew = true;\n        _this.emit(\'isNew\', true);\n        _this.constructor.emit(\'isNew\', true);\n\n        callback(err);\n        return;\n      }\n\n      callback(null, ret);\n    });\n    this.$__reset();\n    this.isNew = false;\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n    // Make it possible to retry the insert\n    this.$__.inserting = true;\n  } else {\n    // Make sure we don\'t treat it as a new object on error,\n    // since it already exists\n    this.$__.inserting = false;\n\n    var delta = this.$__delta();\n\n    if (delta) {\n      if (delta instanceof Error) {\n        callback(delta);\n        return;\n      }\n\n      var where = this.$__where(delta[0]);\n      if (where instanceof Error) {\n        callback(where);\n        return;\n      }\n\n      if (this.$where) {\n        keys = Object.keys(this.$where);\n        len = keys.length;\n        for (i = 0; i < len; ++i) {\n          where[keys[i]] = this.$where[keys[i]];\n        }\n      }\n\n      this.collection.update(where, delta[1], options.safe, function(err, ret) {\n        if (err) {\n          callback(err);\n          return;\n        }\n        ret.$where = where;\n        callback(null, ret);\n      });\n    } else {\n      this.$__reset();\n      callback();\n      return;\n    }\n\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n  }\n}',
  '$ignore': 'function (path) {\n  this.$__.activePaths.ignore(path);\n}',
  emit: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  removePre: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , pres = proto._pres || (proto._pres || {});\n    if (!pres[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all pre callbacks for hook `name`\n      pres[name].length = 0;\n    } else {\n      pres[name] = pres[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  toJSON: 'function (options) {\n  return this.$toObject(options, true);\n}',
  '$__handleReject': 'function handleReject(err) {\n  // emit on the Model if listening\n  if (this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  } else if (this.constructor.listeners && this.constructor.listeners(\'error\').length) {\n    this.constructor.emit(\'error\', err);\n  } else if (this.listeners && this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  }\n}',
  set: 'function (path, val, type, options) {\n  if (type && utils.getFunctionName(type.constructor) === \'Object\') {\n    options = type;\n    type = undefined;\n  }\n\n  var merge = options && options.merge,\n      adhoc = type && type !== true,\n      constructing = type === true,\n      adhocs;\n\n  var strict = options && \'strict\' in options\n      ? options.strict\n      : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  if (typeof path !== \'string\') {\n    // new Document({ key: val })\n\n    if (path === null || path === void 0) {\n      var _ = path;\n      path = val;\n      val = _;\n    } else {\n      var prefix = val\n          ? val + \'.\'\n          : \'\';\n\n      if (path instanceof Document) {\n        if (path.$__isNested) {\n          path = path.toObject();\n        } else {\n          path = path._doc;\n        }\n      }\n\n      var keys = Object.keys(path);\n      var len = keys.length;\n      var i = 0;\n      var pathtype;\n      var key;\n\n      if (len === 0 && !this.schema.options.minimize) {\n        if (val) {\n          this.set(val, {});\n        }\n        return this;\n      }\n\n      if (this.schema.options.retainKeyOrder) {\n        while (i < len) {\n          _handleIndex.call(this, i++);\n        }\n      } else {\n        while (len--) {\n          _handleIndex.call(this, len);\n        }\n      }\n\n      return this;\n    }\n  }\n\n  function _handleIndex(i) {\n    key = keys[i];\n    var pathName = prefix + key;\n    pathtype = this.schema.pathType(pathName);\n\n    if (path[key] !== null\n        && path[key] !== void 0\n          // need to know if plain object - no Buffer, ObjectId, ref, etc\n        && utils.isObject(path[key])\n        && (!path[key].constructor || utils.getFunctionName(path[key].constructor) === \'Object\')\n        && pathtype !== \'virtual\'\n        && pathtype !== \'real\'\n        && !(this.$__path(pathName) instanceof MixedSchema)\n        && !(this.schema.paths[pathName] &&\n        this.schema.paths[pathName].options &&\n        this.schema.paths[pathName].options.ref)) {\n      this.set(path[key], prefix + key, constructing);\n    } else if (strict) {\n      // Don\'t overwrite defaults with undefined keys (gh-3981)\n      if (constructing && path[key] === void 0 &&\n          this.get(key) !== void 0) {\n        return;\n      }\n\n      if (pathtype === \'real\' || pathtype === \'virtual\') {\n        // Check for setting single embedded schema to document (gh-3535)\n        var p = path[key];\n        if (this.schema.paths[pathName] &&\n            this.schema.paths[pathName].$isSingleNested &&\n            path[key] instanceof Document) {\n          p = p.toObject({ virtuals: false, transform: false });\n        }\n        this.set(prefix + key, p, constructing);\n      } else if (pathtype === \'nested\' && path[key] instanceof Document) {\n        this.set(prefix + key,\n            path[key].toObject({transform: false}), constructing);\n      } else if (strict === \'throw\') {\n        if (pathtype === \'nested\') {\n          throw new ObjectExpectedError(key, path[key]);\n        } else {\n          throw new StrictModeError(key);\n        }\n      }\n    } else if (path[key] !== void 0) {\n      this.set(prefix + key, path[key], constructing);\n    }\n  }\n\n  var pathType = this.schema.pathType(path);\n  if (pathType === \'nested\' && val) {\n    if (utils.isObject(val) &&\n        (!val.constructor || utils.getFunctionName(val.constructor) === \'Object\')) {\n      if (!merge) {\n        this.setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      }\n\n      if (Object.keys(val).length === 0) {\n        this.setValue(path, {});\n        this.markModified(path);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        this.set(val, path, constructing);\n      }\n      return this;\n    }\n    this.invalidate(path, new MongooseError.CastError(\'Object\', val, path));\n    return this;\n  }\n\n  var schema;\n  var parts = path.split(\'.\');\n\n  if (pathType === \'adhocOrUndefined\' && strict) {\n    // check for roots that are Mixed types\n    var mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      var subpath = parts.slice(0, i + 1).join(\'.\');\n      schema = this.schema.path(subpath);\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n\n      // If path is underneath a virtual, bypass everything and just set it.\n      if (i + 1 < parts.length && this.schema.pathType(subpath) === \'virtual\') {\n        mpath.set(path, val, this);\n        return this;\n      }\n    }\n\n    if (!mixed) {\n      if (strict === \'throw\') {\n        throw new StrictModeError(path);\n      }\n      return this;\n    }\n  } else if (pathType === \'virtual\') {\n    schema = this.schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  var pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: "LEFT_SUBFIELD only supports Object"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    for (i = 0; i < parts.length; ++i) {\n      subpath = parts.slice(0, i + 1).join(\'.\');\n      if (this.isDirectModified(subpath) // earlier prefixes that are already\n            // marked as dirty have precedence\n          || this.get(subpath) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n\n  // if this doc is being constructed we should not trigger getters\n  var priorVal = constructing\n      ? undefined\n      : this.getValue(path);\n\n  if (!schema) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n    return this;\n  }\n\n  var shouldSet = true;\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    var didPopulate = false;\n    if (schema.options &&\n        schema.options.ref &&\n        val instanceof Document &&\n        (schema.options.ref === val.constructor.modelName || schema.options.ref === val.constructor.baseModelName)) {\n      if (this.ownerDocument) {\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val._id, {model: val.constructor});\n      } else {\n        this.populated(path, val._id, {model: val.constructor});\n      }\n      didPopulate = true;\n    }\n\n    var popOpts;\n    if (schema.options &&\n        Array.isArray(schema.options.type) &&\n        schema.options.type.length &&\n        schema.options.type[0].ref &&\n        Array.isArray(val) &&\n        val.length > 0 &&\n        val[0] instanceof Document &&\n        val[0].constructor.modelName &&\n        (schema.options.type[0].ref === val[0].constructor.baseModelName || schema.options.type[0].ref === val[0].constructor.modelName)) {\n      if (this.ownerDocument) {\n        popOpts = { model: val[0].constructor };\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val.map(function(v) { return v._id; }), popOpts);\n      } else {\n        popOpts = { model: val[0].constructor };\n        this.populated(path, val.map(function(v) { return v._id; }), popOpts);\n      }\n      didPopulate = true;\n    }\n    val = schema.applySetters(val, this, false, priorVal);\n\n    if (!didPopulate && this.$__.populated) {\n      delete this.$__.populated[path];\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    this.invalidate(path,\n      new MongooseError.CastError(schema.instance, val, path, e));\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n}',
  '$__delta': 'function () {\n  var dirty = this.$__dirty();\n  if (!dirty.length && VERSION_ALL !== this.$__.version) return;\n\n  var where = {},\n      delta = {},\n      len = dirty.length,\n      divergent = [],\n      d = 0;\n\n  where._id = this._doc._id;\n  if (where._id.toObject) {\n    where._id = where._id.toObject({ transform: false, depopulate: true });\n  }\n\n  for (; d < len; ++d) {\n    var data = dirty[d];\n    var value = data.value;\n\n    var match = checkDivergentArray(this, data.path, value);\n    if (match) {\n      divergent.push(match);\n      continue;\n    }\n\n    var pop = this.populated(data.path, true);\n    if (!pop && this.$__.selected) {\n      // If any array was selected using an $elemMatch projection, we alter the path and where clause\n      // NOTE: MongoDB only supports projected $elemMatch on top level array.\n      var pathSplit = data.path.split(\'.\');\n      var top = pathSplit[0];\n      if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {\n        // If the selected array entry was modified\n        if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === \'undefined\') {\n          where[top] = this.$__.selected[top];\n          pathSplit[1] = \'$\';\n          data.path = pathSplit.join(\'.\');\n        }\n        // if the selected array was modified in any other way throw an error\n        else {\n          divergent.push(data.path);\n          continue;\n        }\n      }\n    }\n\n    if (divergent.length) continue;\n\n    if (undefined === value) {\n      operand(this, where, delta, data, 1, \'$unset\');\n    } else if (value === null) {\n      operand(this, where, delta, data, null);\n    } else if (value._path && value._atomics) {\n      // arrays and other custom types (support plugins etc)\n      handleAtomics(this, where, delta, data, value);\n    } else if (value._path && Buffer.isBuffer(value)) {\n      // MongooseBuffer\n      value = value.toObject();\n      operand(this, where, delta, data, value);\n    } else {\n      value = utils.clone(value, {depopulate: 1, _isNested: true});\n      operand(this, where, delta, data, value);\n    }\n  }\n\n  if (divergent.length) {\n    return new DivergentArrayError(divergent);\n  }\n\n  if (this.$__.version) {\n    this.$__version(where, delta);\n  }\n\n  return [where, delta];\n}',
  '$__save': 'function (options, callback) {\n  var _this = this;\n\n  _this.$__handleSave(options, function(error, result) {\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.$__reset();\n    _this.$__storeShard();\n\n    var numAffected = 0;\n    if (result) {\n      if (Array.isArray(result)) {\n        numAffected = result.length;\n      } else if (result.result && result.result.n !== undefined) {\n        numAffected = result.result.n;\n      } else if (result.result && result.result.nModified !== undefined) {\n        numAffected = result.result.nModified;\n      } else {\n        numAffected = result;\n      }\n    }\n\n    // was this an update that required a version bump?\n    if (_this.$__.version && !_this.$__.inserting) {\n      var doIncrement = VERSION_INC === (VERSION_INC & _this.$__.version);\n      _this.$__.version = undefined;\n\n      if (numAffected <= 0) {\n        // the update failed. pass an error back\n        var err = new VersionError(_this);\n        return callback(err);\n      }\n\n      // increment version if was successful\n      if (doIncrement) {\n        var key = _this.schema.options.versionKey;\n        var version = _this.getValue(key) | 0;\n        _this.setValue(key, version + 1);\n      }\n    }\n\n    if (_this.schema.options &&\n        _this.schema.options.saveErrorIfNotFound &&\n        numAffected <= 0) {\n      error = new DocumentNotFoundError(result.$where);\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.emit(\'save\', _this, numAffected);\n    _this.constructor.emit(\'save\', _this, numAffected);\n    callback(null, _this, numAffected);\n  });\n}' }
[2017-05-04 15:43:39.848] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:43:39.867] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:43:40.031] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:43:40.045] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:43:39.875] [INFO] app - Redis client default is ready {}
[2017-05-04 15:43:40.139] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:43:40.871] [DEBUG] app - 2017-5-4 15:43:40 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:43:40.875] [WARN] console - this is a logger middleware.
[2017-05-04 15:43:40.897] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:44:02.816] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:44:02.831] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:44:03.282] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:44:03.291] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:44:06.733] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:44:06.743] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:44:12.366] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:44:12.377] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:44:12.380] [INFO] app - Redis client default is ready {}
[2017-05-04 15:44:12.514] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:44:14.102] [DEBUG] app - 2017-5-4 15:44:14 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:44:14.105] [WARN] console - this is a logger middleware.
[2017-05-04 15:44:14.126] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:44:28.241] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:44:28.252] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:44:28.257] [INFO] app - Redis client default is ready {}
[2017-05-04 15:44:28.456] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:44:30.027] [DEBUG] app - 2017-5-4 15:44:30 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:44:30.031] [WARN] console - this is a logger middleware.
[2017-05-04 15:44:30.049] [WARN] console - undefined
[2017-05-04 15:44:30.051] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:44:36.663] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:44:36.679] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:44:36.683] [INFO] app - Redis client default is ready {}
[2017-05-04 15:44:36.882] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:45:57.620] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:45:57.631] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:45:57.635] [INFO] app - Redis client default is ready {}
[2017-05-04 15:45:57.819] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:45:58.561] [DEBUG] app - 2017-5-4 15:45:58 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:45:58.568] [WARN] console - this is a logger middleware.
[2017-05-04 15:45:58.584] [WARN] console - { _id: 5902b753c5756d72945d90b3,
  updatedAt: 2017-04-28T03:30:27.167Z,
  createdAt: 2017-04-28T03:30:27.167Z,
  username: '222',
  __v: 0 }
[2017-05-04 15:45:58.592] [WARN] console - null
[2017-05-04 15:46:18.306] [DEBUG] app - 2017-5-4 15:46:18 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:46:18.308] [WARN] console - this is a logger middleware.
[2017-05-04 15:46:18.313] [WARN] console - { _id: 5902b753c5756d72945d90b3,
  updatedAt: 2017-04-28T03:30:27.167Z,
  createdAt: 2017-04-28T03:30:27.167Z,
  username: '222',
  __v: 0 }
[2017-05-04 15:46:18.314] [WARN] console - null
[2017-05-04 15:46:35.493] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:46:35.505] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:46:35.508] [INFO] app - Redis client default is ready {}
[2017-05-04 15:46:35.728] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:46:39.515] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:46:39.524] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:46:39.527] [INFO] app - Redis client default is ready {}
[2017-05-04 15:46:39.708] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:46:40.737] [DEBUG] app - 2017-5-4 15:46:40 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:46:40.742] [WARN] console - this is a logger middleware.
[2017-05-04 15:46:40.767] [WARN] console - null
[2017-05-04 15:47:08.678] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:47:08.687] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:47:08.690] [INFO] app - Redis client default is ready {}
[2017-05-04 15:47:08.884] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:47:10.837] [DEBUG] app - 2017-5-4 15:47:10 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:47:10.843] [WARN] console - this is a logger middleware.
[2017-05-04 15:47:10.859] [WARN] console - usr:o:id:5902b753c5756d72945d90b3
[2017-05-04 15:47:10.864] [WARN] console - null
[2017-05-04 15:47:21.030] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:47:21.044] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:47:21.050] [INFO] app - Redis client default is ready {}
[2017-05-04 15:47:21.265] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:47:22.840] [DEBUG] app - 2017-5-4 15:47:22 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:47:22.844] [WARN] console - this is a logger middleware.
[2017-05-04 15:47:22.861] [WARN] console - usr:o:id:5902b753c5756d72945d90b3
[2017-05-04 15:47:22.867] [WARN] console - { _id: 5902b753c5756d72945d90b3,
  updatedAt: 2017-04-28T03:30:27.167Z,
  createdAt: 2017-04-28T03:30:27.167Z,
  username: '222',
  __v: 0 }
[2017-05-04 15:47:34.561] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:47:34.572] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:47:34.576] [INFO] app - Redis client default is ready {}
[2017-05-04 15:47:34.802] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:47:35.641] [DEBUG] app - 2017-5-4 15:47:35 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:47:35.645] [WARN] console - this is a logger middleware.
[2017-05-04 15:47:35.660] [WARN] console - usr:o:id:5902b753c5756d72945d90b3
[2017-05-04 15:47:35.664] [WARN] console - 5902b753c5756d72945d90b3
[2017-05-04 15:47:55.946] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:47:55.957] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:47:55.960] [INFO] app - Redis client default is ready {}
[2017-05-04 15:47:56.137] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:47:57.652] [DEBUG] app - 2017-5-4 15:47:57 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:47:57.659] [WARN] console - this is a logger middleware.
[2017-05-04 15:47:57.676] [WARN] console - usr:o:id:5902b753c5756d72945d90b3
[2017-05-04 15:47:57.682] [WARN] console - usr:o:id:5902b753c5756d72945d90b3
[2017-05-04 15:49:04.898] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:49:04.908] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:49:04.911] [INFO] app - Redis client default is ready {}
[2017-05-04 15:49:05.127] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:49:10.202] [DEBUG] app - 2017-5-4 15:49:10 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:49:10.208] [WARN] console - this is a logger middleware.
[2017-05-04 15:49:10.226] [WARN] console - usr:o:id:5902b753c5756d72945d90b3
[2017-05-04 15:49:10.231] [WARN] console - { depopulate: 'function (path) {\n  var populatedIds = this.populated(path);\n  if (!populatedIds) {\n    return;\n  }\n  delete this.$__.populated[path];\n  this.set(path, populatedIds);\n  return this;\n}',
  equals: 'function (doc) {\n  if (!doc) {\n    return false;\n  }\n\n  var tid = this.get(\'_id\');\n  var docid = doc.get ? doc.get(\'_id\') : doc;\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals\n      ? tid.equals(docid)\n      : tid === docid;\n}',
  _posts: '[object Object]',
  '$__getAllSubdocs': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  function docReducer(seed, path) {\n    var val = this[path];\n\n    if (val instanceof Embedded) {\n      seed.push(val);\n    }\n    if (val && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(docReducer.bind(val._doc), seed);\n      seed.push(val);\n    }\n    if (val && val.isMongooseDocumentArray) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n        seed = Object.keys(doc._doc).reduce(docReducer.bind(doc._doc), seed);\n      });\n    } else if (val instanceof Document && val.$__isNested) {\n      if (val) {\n        seed = Object.keys(val).reduce(docReducer.bind(val), seed);\n      }\n    }\n    return seed;\n  }\n\n  var subDocs = Object.keys(this._doc).reduce(docReducer.bind(this), []);\n\n  return subDocs;\n}',
  removeListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  '$__original_save': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  '$__getArrayPathsToValidate': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  // validate all document arrays.\n  return this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return this.getValue(i);\n  }.bind(this))\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  }).reduce(function(seed, array) {\n    return seed.concat(array);\n  }, [])\n  .filter(function(doc) {\n    return doc;\n  });\n}',
  schema: '[object Object]',
  removeAllListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  save: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  isDirectSelected: 'function isDirectSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  removePost: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , posts = proto._posts || (proto._posts || {});\n    if (!posts[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all post callbacks for hook `name`\n      posts[name].length = 0;\n    } else {\n      posts[name] = posts[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  _lazySetupHooks: 'function (proto, methodName, errorCb) {\n    if (\'undefined\' === typeof proto[methodName].numAsyncPres) {\n      this.$hook(methodName, proto[methodName], errorCb);\n    }\n  }',
  toBSON: 'function () {\n  return this.toObject({\n    transform: false,\n    virtuals: false,\n    _skipDepopulateTopLevel: true,\n    depopulate: true,\n    flattenDecimals: false\n  });\n}',
  markModified: 'function (path) {\n  this.$__.activePaths.modify(path);\n}',
  on: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  increment: 'function increment() {\n  this.$__.version = VERSION_ALL;\n  return this;\n}',
  validate: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populated: 'function (path, val, options) {\n  // val and options are internal\n\n  if (val === null || val === void 0) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    var v = this.$__.populated[path];\n    if (v) {\n      return v.value;\n    }\n    return undefined;\n  }\n\n  // internal\n\n  if (val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    return this.$__.populated[path];\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = {value: val, options: options};\n  return val;\n}',
  update: 'function update() {\n  var args = utils.args(arguments);\n  args.unshift({_id: this._id});\n  return this.constructor.update.apply(this.constructor, args);\n}',
  id: '5902b753c5756d72945d90b3',
  '$__setSchema': 'function (schema) {\n  compile(schema.tree, this, undefined, schema.options);\n  this.schema = schema;\n}',
  isInit: 'function (path) {\n  return (path in this.$__.activePaths.states.init);\n}',
  '$__validate': 'function (callback) {\n  var _this = this;\n  var _complete = function() {\n    var err = _this.$__.validationError;\n    _this.$__.validationError = undefined;\n    _this.emit(\'validate\', _this);\n    _this.constructor.emit(\'validate\', _this);\n    if (err) {\n      for (var key in err.errors) {\n        // Make sure cast errors persist\n        if (!_this.__parent && err.errors[key] instanceof MongooseError.CastError) {\n          _this.invalidate(key, err.errors[key]);\n        }\n      }\n\n      return err;\n    }\n  };\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (paths.length === 0) {\n    process.nextTick(function() {\n      var error = _complete();\n      if (error) {\n        return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n          callback(error);\n        });\n      }\n      callback();\n    });\n  }\n\n  var validating = {},\n      total = 0;\n\n  var complete = function() {\n    var error = _complete();\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n    callback();\n  };\n\n  var validatePath = function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n    total++;\n\n    process.nextTick(function() {\n      var p = _this.schema.path(path);\n      if (!p) {\n        return --total || complete();\n      }\n\n      // If user marked as invalid or there was a cast error, don\'t validate\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      var val = _this.getValue(path);\n      p.doValidate(val, function(err) {\n        if (err) {\n          _this.invalidate(path, err, undefined, true);\n        }\n        --total || complete();\n      }, _this);\n    });\n  };\n\n  paths.forEach(validatePath);\n}',
  username: '222',
  db: '[object Object]',
  '$__original_validate': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  discriminators: 'undefined',
  isModified: 'function (paths) {\n  if (paths) {\n    if (!Array.isArray(paths)) {\n      paths = paths.split(\' \');\n    }\n    var modified = this.modifiedPaths();\n    var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n    var isModifiedChild = paths.some(function(path) {\n      return !!~modified.indexOf(path);\n    });\n    return isModifiedChild || paths.some(function(path) {\n      return directModifiedPaths.some(function(mod) {\n        return mod === path || path.indexOf(mod + \'.\') === 0;\n      });\n    });\n  }\n  return this.$__.activePaths.some(\'modify\');\n}',
  '$pre': 'function (name, isAsync, fn, errorCb) {\n    if (\'boolean\' !== typeof arguments[1]) {\n      errorCb = fn;\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {};\n\n    this._lazySetupHooks(proto, name, errorCb);\n\n    if (fn.isAsync = isAsync) {\n      proto[name].numAsyncPres++;\n    }\n\n    (pres[name] = pres[name] || []).push(fn);\n    return this;\n  }',
  toObject: 'function (options) {\n  return this.$toObject(options);\n}',
  '$markValid': 'function (path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n}',
  '$__buildDoc': 'function (obj, fields, skipId) {\n  var doc = {};\n  var exclude = null;\n  var keys;\n  var ki;\n  var _this = this;\n\n  // determine if this doc is a result of a query with\n  // excluded fields\n\n  if (fields && utils.getFunctionName(fields.constructor) === \'Object\') {\n    keys = Object.keys(fields);\n    ki = keys.length;\n\n    if (ki === 1 && keys[0] === \'_id\') {\n      exclude = !!fields[keys[ki]];\n    } else {\n      while (ki--) {\n        if (keys[ki] !== \'_id\' &&\n            (!fields[keys[ki]] || typeof fields[keys[ki]] !== \'object\')) {\n          exclude = !fields[keys[ki]];\n          break;\n        }\n      }\n    }\n  }\n\n  var paths = Object.keys(this.schema.paths);\n  var plen = paths.length;\n  var ii = 0;\n\n  var hasIncludedChildren = {};\n  if (exclude === false && fields) {\n    keys = Object.keys(fields);\n    for (var j = 0; j < keys.length; ++j) {\n      var parts = keys[j].split(\'.\');\n      var c = [];\n      for (var k = 0; k < parts.length; ++k) {\n        c.push(parts[k]);\n        hasIncludedChildren[c.join(\'.\')] = 1;\n      }\n    }\n  }\n\n  for (; ii < plen; ++ii) {\n    var p = paths[ii];\n\n    if (p === \'_id\') {\n      if (skipId) {\n        continue;\n      }\n      if (obj && \'_id\' in obj) {\n        continue;\n      }\n    }\n\n    var type = this.schema.paths[p];\n    var path = p.split(\'.\');\n    var len = path.length;\n    var last = len - 1;\n    var curPath = \'\';\n    var doc_ = doc;\n    var i = 0;\n    var included = false;\n\n    for (; i < len; ++i) {\n      var piece = path[i],\n          def;\n\n      curPath += (!curPath.length ? \'\' : \'.\') + piece;\n\n      // support excluding intermediary levels\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i === last) {\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          } else if (included) {\n            // selected field\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          }\n        } else {\n          def = type.getDefault(_this, false);\n          if (typeof def !== \'undefined\') {\n            doc_[piece] = def;\n            _this.$__.activePaths.default(p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  return doc;\n}',
  getValue: 'function (path) {\n  return utils.getValue(path, this._doc);\n}',
  collection: '[object Object]',
  createdAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  '$isValid': 'function (path) {\n  return !this.$__.validationError || !this.$__.validationError.errors[path];\n}',
  '$__version': 'function (where, delta) {\n  var key = this.schema.options.versionKey;\n\n  if (where === true) {\n    // this is an insert\n    if (key) this.setValue(key, delta[key] = 0);\n    return;\n  }\n\n  // updates\n\n  // only apply versioning if our versionKey was selected. else\n  // there is no way to select the correct version. we could fail\n  // fast here and force them to include the versionKey but\n  // thats a bit intrusive. can we do this automatically?\n  if (!this.isSelected(key)) {\n    return;\n  }\n\n  // $push $addToSet don\'t need the where clause set\n  if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {\n    where[key] = this.getValue(key);\n  }\n\n  if (VERSION_INC === (VERSION_INC & this.$__.version)) {\n    if (!delta.$set || typeof delta.$set[key] === \'undefined\') {\n      delta.$inc || (delta.$inc = {});\n      delta.$inc[key] = 1;\n    }\n  }\n}',
  isDirectModified: 'function (path) {\n  return (path in this.$__.activePaths.states.modify);\n}',
  '$isMongooseModelPrototype': 'true',
  modifiedPaths: 'function () {\n  var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n  return directModifiedPaths.reduce(function(list, path) {\n    var parts = path.split(\'.\');\n    return list.concat(parts.reduce(function(chains, part, i) {\n      return chains.concat(parts.slice(0, i).concat(part).join(\'.\'));\n    }, []).filter(function(chain) {\n      return (list.indexOf(chain) === -1);\n    }));\n  }, []);\n}',
  updatedAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  get: 'function (path, type) {\n  var adhoc;\n  if (type) {\n    adhoc = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  var schema = this.$__path(path) || this.schema.virtualpath(path),\n      pieces = path.split(\'.\'),\n      obj = this._doc;\n\n  for (var i = 0, l = pieces.length; i < l; i++) {\n    obj = obj === null || obj === void 0\n        ? undefined\n        : obj[pieces[i]];\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  // Check if this path is populated - don\'t apply getters if it is,\n  // because otherwise its a nested object. See gh-3357\n  if (schema && !this.populated(path)) {\n    obj = schema.applyGetters(obj, this);\n  }\n\n  return obj;\n}',
  '$__path': 'function (path) {\n  var adhocs = this.$__.adhocPaths,\n      adhocType = adhocs && adhocs[path];\n\n  if (adhocType) {\n    return adhocType;\n  }\n  return this.schema.path(path);\n}',
  listeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  '$__storeShard': 'function () {\n  // backwards compat\n  var key = this.schema.options.shardKey || this.schema.options.shardkey;\n  if (!(key && utils.getFunctionName(key.constructor) === \'Object\')) {\n    return;\n  }\n\n  var orig = this.$__.shardval = {},\n      paths = Object.keys(key),\n      len = paths.length,\n      val;\n\n  for (var i = 0; i < len; ++i) {\n    val = this.getValue(paths[i]);\n    if (isMongooseObject(val)) {\n      orig[paths[i]] = val.toObject({depopulate: true, _isNested: true});\n    } else if (val !== null && val !== undefined && val.valueOf &&\n          // Explicitly don\'t take value of dates\n        (!val.constructor || utils.getFunctionName(val.constructor) !== \'Date\')) {\n      orig[paths[i]] = val.valueOf();\n    } else {\n      orig[paths[i]] = val;\n    }\n  }\n}',
  '$__dirty': 'function () {\n  var _this = this;\n\n  var all = this.$__.activePaths.map(\'modify\', function(path) {\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  });\n\n  // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n  all = all.concat(this.$__.activePaths.map(\'default\', function(path) {\n    if (path === \'_id\' || !_this.getValue(path)) {\n      return;\n    }\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n\n  // Sort dirty paths in a flat hierarchy.\n  all.sort(function(a, b) {\n    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));\n  });\n\n  // Ignore "foo.a" if "foo" is dirty already.\n  var minimal = [],\n      lastPath,\n      top;\n\n  all.forEach(function(item) {\n    if (!item) {\n      return;\n    }\n    if (item.path.indexOf(lastPath) !== 0) {\n      lastPath = item.path + \'.\';\n      minimal.push(item);\n      top = item;\n    } else {\n      // special case for top level MongooseArrays\n      if (top.value && top.value._atomics && top.value.hasAtomics()) {\n        // the `top` array itself and a sub path of `top` are being modified.\n        // the only way to honor all of both modifications is through a $set\n        // of entire array.\n        top.value._atomics = {};\n        top.value._atomics.$set = top.value;\n      }\n    }\n  });\n\n  top = lastPath = null;\n  return minimal;\n}',
  model: 'function model(name) {\n  return this.db.model(name);\n}',
  '$isDefault': 'function (path) {\n  return (path in this.$__.activePaths.states.default);\n}',
  '$__original_remove': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  remove: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populate: 'function populate() {\n  if (arguments.length === 0) {\n    return this;\n  }\n\n  var pop = this.$__.populate || (this.$__.populate = {});\n  var args = utils.args(arguments);\n  var fn;\n\n  if (typeof args[args.length - 1] === \'function\') {\n    fn = args.pop();\n  }\n\n  // allow `doc.populate(callback)`\n  if (args.length) {\n    // use hash to remove duplicate paths\n    var res = utils.populate.apply(null, args);\n    for (var i = 0; i < res.length; ++i) {\n      pop[res[i].path] = res[i];\n    }\n  }\n\n  if (fn) {\n    var paths = utils.object.vals(pop);\n    this.$__.populate = undefined;\n    paths.__noPromise = true;\n    this.constructor.populate(this, paths, fn);\n  }\n\n  return this;\n}',
  '$__shouldModify': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  if (this.isNew) {\n    return true;\n  }\n\n  if (undefined === val && !this.isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (undefined === val && path in this.$__.activePaths.states.default) {\n    // we\'re just unsetting the default value which was never saved\n    return false;\n  }\n\n  // gh-3992: if setting a populated field to a doc, don\'t mark modified\n  // if they have the same _id\n  if (this.populated(path) &&\n      val instanceof Document &&\n      deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal || this.get(path))) {\n    return true;\n  }\n\n  if (!constructing &&\n      val !== null &&\n      val !== undefined &&\n      path in this.$__.activePaths.states.default &&\n      deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n  return false;\n}',
  '$__': '[object Object]',
  '$__fullPath': 'function (path) {\n  // overridden in SubDocuments\n  return path || \'\';\n}',
  _pres: '[object Object]',
  inspect: 'function (options) {\n  var isPOJO = options &&\n    utils.getFunctionName(options.constructor) === \'Object\';\n  var opts;\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n    opts.retainKeyOrder = true;\n  }\n  return this.toObject(opts);\n}',
  '$__reset': 'function reset() {\n  var _this = this;\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return _this.getValue(i);\n  })\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  })\n  .forEach(function(array) {\n    var i = array.length;\n    while (i--) {\n      var doc = array[i];\n      if (!doc) {\n        continue;\n      }\n      doc.$__reset();\n    }\n  });\n\n  // clear atomics\n  this.$__dirty().forEach(function(dirt) {\n    var type = dirt.value;\n    if (type && type._atomics) {\n      type._atomics = {};\n    }\n  });\n\n  // Clear \'dirty\' cache\n  this.$__.activePaths.clear(\'modify\');\n  this.$__.activePaths.clear(\'default\');\n  this.$__.validationError = undefined;\n  this.errors = undefined;\n  _this = this;\n  this.schema.requiredPaths().forEach(function(path) {\n    _this.$__.activePaths.require(path);\n  });\n\n  return this;\n}',
  init: 'function (doc, opts, fn) {\n  // do not prefix this method with $__ since its\n  // used by public hooks\n\n  if (typeof opts === \'function\') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.isNew = false;\n\n  // handle docs with populated paths\n  // If doc._id is not null or undefined\n  if (doc._id !== null && doc._id !== undefined &&\n    opts && opts.populated && opts.populated.length) {\n    var id = String(doc._id);\n    for (var i = 0; i < opts.populated.length; ++i) {\n      var item = opts.populated[i];\n      if (item.isVirtual) {\n        this.populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.populated(item.path, item._docs[id], item);\n      }\n    }\n  }\n\n  init(this, doc, this._doc);\n  this.$__storeShard();\n\n  this.emit(\'init\', this);\n  this.constructor.emit(\'init\', this);\n\n  if (fn) {\n    fn(null);\n  }\n  return this;\n}',
  setMaxListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  initializeTimestamps: 'function () {\n      if (!this.get(createdAt)) {\n        this.set(createdAt, new Date());\n      }\n      if (!this.get(updatedAt)) {\n        this.set(updatedAt, new Date());\n      }\n      return this;\n    }',
  once: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  __v: '0',
  '$toObject': 'function (options, json) {\n  var defaultOptions = {\n    transform: true,\n    json: json,\n    retainKeyOrder: this.schema.options.retainKeyOrder,\n    flattenDecimals: true\n  };\n\n  // _isNested will only be true if this is not the top level document, we\n  // should never depopulate\n  if (options && options.depopulate && options._isNested && this.$__.wasPopulated) {\n    // populated paths that we set to a document\n    return clone(this._id, options);\n  }\n\n  // When internally saving this document we always pass options,\n  // bypassing the custom schema options.\n  if (!(options && utils.getFunctionName(options.constructor) === \'Object\') ||\n      (options && options._useSchemaOptions)) {\n    if (json) {\n      options = this.schema.options.toJSON ?\n        clone(this.schema.options.toJSON) :\n        {};\n      options.json = true;\n      options._useSchemaOptions = true;\n    } else {\n      options = this.schema.options.toObject ?\n        clone(this.schema.options.toObject) :\n        {};\n      options.json = false;\n      options._useSchemaOptions = true;\n    }\n  }\n\n  for (var key in defaultOptions) {\n    if (options[key] === undefined) {\n      options[key] = defaultOptions[key];\n    }\n  }\n\n  (\'minimize\' in options) || (options.minimize = this.schema.options.minimize);\n\n  // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n  var originalTransform = options.transform;\n\n  options._isNested = true;\n\n  var ret = clone(this._doc, options) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, \'paths\', options);\n    // applyGetters for paths will add nested empty objects;\n    // if minimize is set, we need to remove them.\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || options.getters && options.virtuals !== false) {\n    applyGetters(this, ret, \'virtuals\', options);\n  }\n\n  if (options.versionKey === false && this.schema.options.versionKey) {\n    delete ret[this.schema.options.versionKey];\n  }\n\n  var transform = options.transform;\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema\'s transform and\n  // not the parent schema\'s\n  if (transform === true ||\n      (this.schema.options.toObject && transform)) {\n    var opts = options.json ? this.schema.options.toJSON : this.schema.options.toObject;\n\n    if (opts) {\n      transform = (typeof options.transform === \'function\' ? options.transform : opts.transform);\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === \'function\') {\n    var xformed = transform(this, ret, options);\n    if (typeof xformed !== \'undefined\') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n}',
  '$hook': 'function (name, fn, errorCb) {\n    if (arguments.length === 1 && typeof name === \'object\') {\n      for (var k in name) { // `name` is a hash of hookName->hookFn\n        this.$hook(k, name[k]);\n      }\n      return;\n    }\n\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {}\n      , posts = proto._posts = proto._posts || {};\n    pres[name] = pres[name] || [];\n    posts[name] = posts[name] || [];\n\n    proto[name] = function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    };\n    \n    proto[name].numAsyncPres = 0;\n\n    return this;\n  }',
  '$__set': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  var shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts,\n    schema, val, priorVal);\n  var _this = this;\n\n  if (shouldModify) {\n    this.markModified(pathToMark, val);\n\n    // handle directly setting arrays (gh-1126)\n    MongooseArray || (MongooseArray = require(\'./types/array\'));\n    if (val && val.isMongooseArray) {\n      val._registerAtomic(\'$set\', val);\n\n      // Update embedded document parent references (gh-5189)\n      if (val.isMongooseDocumentArray) {\n        val.forEach(function(item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      }\n\n      // Small hack for gh-1638: if we\'re overwriting the entire array, ignore\n      // paths that were modified before the array overwrite\n      this.$__.activePaths.forEach(function(modifiedPath) {\n        if (modifiedPath.indexOf(path + \'.\') === 0) {\n          _this.$__.activePaths.ignore(modifiedPath);\n        }\n      });\n    }\n  }\n\n  var obj = this._doc;\n  var i = 0;\n  var l = parts.length;\n  var cur = \'\';\n\n  for (; i < l; i++) {\n    var next = i + 1;\n    var last = next === l;\n    cur += (cur ? \'.\' + parts[i] : parts[i]);\n\n    if (last) {\n      obj[parts[i]] = val;\n    } else {\n      if (obj[parts[i]] && utils.getFunctionName(obj[parts[i]].constructor) === \'Object\') {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        this.set(cur, {});\n        obj = obj[parts[i]];\n      }\n    }\n  }\n}',
  isNew: 'false',
  unmarkModified: 'function (path) {\n  this.$__.activePaths.init(path);\n}',
  validateSync: 'function (pathsToValidate) {\n  var _this = this;\n\n  if (typeof pathsToValidate === \'string\') {\n    pathsToValidate = pathsToValidate.split(\' \');\n  }\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (pathsToValidate && pathsToValidate.length) {\n    var tmp = [];\n    for (var i = 0; i < paths.length; ++i) {\n      if (pathsToValidate.indexOf(paths[i]) !== -1) {\n        tmp.push(paths[i]);\n      }\n    }\n    paths = tmp;\n  }\n\n  var validating = {};\n\n  paths.forEach(function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n\n    var p = _this.schema.path(path);\n    if (!p) {\n      return;\n    }\n    if (!_this.$isValid(path)) {\n      return;\n    }\n\n    var val = _this.getValue(path);\n    var err = p.doValidateSync(val, _this);\n    if (err) {\n      _this.invalidate(path, err, undefined, true);\n    }\n  });\n\n  var err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n  _this.emit(\'validate\', _this);\n  _this.constructor.emit(\'validate\', _this);\n\n  if (err) {\n    for (var key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n}',
  errors: 'undefined',
  addListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  setValue: 'function (path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n}',
  '$__where': 'function _where(where) {\n  where || (where = {});\n\n  var paths,\n      len;\n\n  if (!where._id) {\n    where._id = this._doc._id;\n  }\n\n  if (this.$__.shardval) {\n    paths = Object.keys(this.$__.shardval);\n    len = paths.length;\n\n    for (var i = 0; i < len; ++i) {\n      where[paths[i]] = this.$__.shardval[paths[i]];\n    }\n  }\n\n  if (this._doc._id == null) {\n    return new Error(\'No _id found on document!\');\n  }\n\n  return where;\n}',
  invalidate: 'function (path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === \'string\') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || \'user defined\',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.errors[path] = err;\n  return this.$__.validationError;\n}',
  _doc: '[object Object]',
  execPopulate: 'function () {\n  var Promise = PromiseProvider.get();\n  var _this = this;\n  return new Promise.ES6(function(resolve, reject) {\n    _this.populate(function(error, res) {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(res);\n      }\n    });\n  });\n}',
  isSelected: 'function isSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    i = paths.length;\n    var pathDot = path + \'.\';\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n\n      if (cur.indexOf(pathDot) === 0) {\n        return inclusive || cur !== pathDot;\n      }\n\n      if (pathDot.indexOf(cur + \'.\') === 0) {\n        return inclusive;\n      }\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  _id: '5902b753c5756d72945d90b3',
  toString: 'function () {\n  return inspect(this.inspect());\n}',
  '$post': 'function (name, isAsync, fn) {\n    if (arguments.length === 2) {\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , posts = proto._posts = proto._posts || {};\n    \n    this._lazySetupHooks(proto, name);\n    (posts[name] = posts[name] || []).push(fn);\n    return this;\n  }',
  '$__handleSave': 'function (options, callback) {\n  var _this = this;\n  var i;\n  var keys;\n  var len;\n  if (!options.safe && this.schema.options.safe) {\n    options.safe = this.schema.options.safe;\n  }\n  if (typeof options.safe === \'boolean\') {\n    options.safe = null;\n  }\n\n  if (this.isNew) {\n    // send entire doc\n    var toObjectOptions = {};\n\n    toObjectOptions.retainKeyOrder = this.schema.options.retainKeyOrder;\n    toObjectOptions.depopulate = 1;\n    toObjectOptions._skipDepopulateTopLevel = true;\n    toObjectOptions.transform = false;\n    toObjectOptions.flattenDecimals = false;\n\n    var obj = this.toObject(toObjectOptions);\n\n    if (!utils.object.hasOwnProperty(obj || {}, \'_id\')) {\n      // documents must have an _id else mongoose won\'t know\n      // what to update later if more changes are made. the user\n      // wouldn\'t know what _id was generated by mongodb either\n      // nor would the ObjectId generated my mongodb necessarily\n      // match the schema definition.\n      setTimeout(function() {\n        callback(new Error(\'document must have an _id before saving\'));\n      }, 0);\n      return;\n    }\n\n    this.$__version(true, obj);\n    this.collection.insert(obj, options.safe, function(err, ret) {\n      if (err) {\n        _this.isNew = true;\n        _this.emit(\'isNew\', true);\n        _this.constructor.emit(\'isNew\', true);\n\n        callback(err);\n        return;\n      }\n\n      callback(null, ret);\n    });\n    this.$__reset();\n    this.isNew = false;\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n    // Make it possible to retry the insert\n    this.$__.inserting = true;\n  } else {\n    // Make sure we don\'t treat it as a new object on error,\n    // since it already exists\n    this.$__.inserting = false;\n\n    var delta = this.$__delta();\n\n    if (delta) {\n      if (delta instanceof Error) {\n        callback(delta);\n        return;\n      }\n\n      var where = this.$__where(delta[0]);\n      if (where instanceof Error) {\n        callback(where);\n        return;\n      }\n\n      if (this.$where) {\n        keys = Object.keys(this.$where);\n        len = keys.length;\n        for (i = 0; i < len; ++i) {\n          where[keys[i]] = this.$where[keys[i]];\n        }\n      }\n\n      this.collection.update(where, delta[1], options.safe, function(err, ret) {\n        if (err) {\n          callback(err);\n          return;\n        }\n        ret.$where = where;\n        callback(null, ret);\n      });\n    } else {\n      this.$__reset();\n      callback();\n      return;\n    }\n\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n  }\n}',
  '$ignore': 'function (path) {\n  this.$__.activePaths.ignore(path);\n}',
  emit: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  removePre: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , pres = proto._pres || (proto._pres || {});\n    if (!pres[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all pre callbacks for hook `name`\n      pres[name].length = 0;\n    } else {\n      pres[name] = pres[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  toJSON: 'function (options) {\n  return this.$toObject(options, true);\n}',
  '$__handleReject': 'function handleReject(err) {\n  // emit on the Model if listening\n  if (this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  } else if (this.constructor.listeners && this.constructor.listeners(\'error\').length) {\n    this.constructor.emit(\'error\', err);\n  } else if (this.listeners && this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  }\n}',
  set: 'function (path, val, type, options) {\n  if (type && utils.getFunctionName(type.constructor) === \'Object\') {\n    options = type;\n    type = undefined;\n  }\n\n  var merge = options && options.merge,\n      adhoc = type && type !== true,\n      constructing = type === true,\n      adhocs;\n\n  var strict = options && \'strict\' in options\n      ? options.strict\n      : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  if (typeof path !== \'string\') {\n    // new Document({ key: val })\n\n    if (path === null || path === void 0) {\n      var _ = path;\n      path = val;\n      val = _;\n    } else {\n      var prefix = val\n          ? val + \'.\'\n          : \'\';\n\n      if (path instanceof Document) {\n        if (path.$__isNested) {\n          path = path.toObject();\n        } else {\n          path = path._doc;\n        }\n      }\n\n      var keys = Object.keys(path);\n      var len = keys.length;\n      var i = 0;\n      var pathtype;\n      var key;\n\n      if (len === 0 && !this.schema.options.minimize) {\n        if (val) {\n          this.set(val, {});\n        }\n        return this;\n      }\n\n      if (this.schema.options.retainKeyOrder) {\n        while (i < len) {\n          _handleIndex.call(this, i++);\n        }\n      } else {\n        while (len--) {\n          _handleIndex.call(this, len);\n        }\n      }\n\n      return this;\n    }\n  }\n\n  function _handleIndex(i) {\n    key = keys[i];\n    var pathName = prefix + key;\n    pathtype = this.schema.pathType(pathName);\n\n    if (path[key] !== null\n        && path[key] !== void 0\n          // need to know if plain object - no Buffer, ObjectId, ref, etc\n        && utils.isObject(path[key])\n        && (!path[key].constructor || utils.getFunctionName(path[key].constructor) === \'Object\')\n        && pathtype !== \'virtual\'\n        && pathtype !== \'real\'\n        && !(this.$__path(pathName) instanceof MixedSchema)\n        && !(this.schema.paths[pathName] &&\n        this.schema.paths[pathName].options &&\n        this.schema.paths[pathName].options.ref)) {\n      this.set(path[key], prefix + key, constructing);\n    } else if (strict) {\n      // Don\'t overwrite defaults with undefined keys (gh-3981)\n      if (constructing && path[key] === void 0 &&\n          this.get(key) !== void 0) {\n        return;\n      }\n\n      if (pathtype === \'real\' || pathtype === \'virtual\') {\n        // Check for setting single embedded schema to document (gh-3535)\n        var p = path[key];\n        if (this.schema.paths[pathName] &&\n            this.schema.paths[pathName].$isSingleNested &&\n            path[key] instanceof Document) {\n          p = p.toObject({ virtuals: false, transform: false });\n        }\n        this.set(prefix + key, p, constructing);\n      } else if (pathtype === \'nested\' && path[key] instanceof Document) {\n        this.set(prefix + key,\n            path[key].toObject({transform: false}), constructing);\n      } else if (strict === \'throw\') {\n        if (pathtype === \'nested\') {\n          throw new ObjectExpectedError(key, path[key]);\n        } else {\n          throw new StrictModeError(key);\n        }\n      }\n    } else if (path[key] !== void 0) {\n      this.set(prefix + key, path[key], constructing);\n    }\n  }\n\n  var pathType = this.schema.pathType(path);\n  if (pathType === \'nested\' && val) {\n    if (utils.isObject(val) &&\n        (!val.constructor || utils.getFunctionName(val.constructor) === \'Object\')) {\n      if (!merge) {\n        this.setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      }\n\n      if (Object.keys(val).length === 0) {\n        this.setValue(path, {});\n        this.markModified(path);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        this.set(val, path, constructing);\n      }\n      return this;\n    }\n    this.invalidate(path, new MongooseError.CastError(\'Object\', val, path));\n    return this;\n  }\n\n  var schema;\n  var parts = path.split(\'.\');\n\n  if (pathType === \'adhocOrUndefined\' && strict) {\n    // check for roots that are Mixed types\n    var mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      var subpath = parts.slice(0, i + 1).join(\'.\');\n      schema = this.schema.path(subpath);\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n\n      // If path is underneath a virtual, bypass everything and just set it.\n      if (i + 1 < parts.length && this.schema.pathType(subpath) === \'virtual\') {\n        mpath.set(path, val, this);\n        return this;\n      }\n    }\n\n    if (!mixed) {\n      if (strict === \'throw\') {\n        throw new StrictModeError(path);\n      }\n      return this;\n    }\n  } else if (pathType === \'virtual\') {\n    schema = this.schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  var pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: "LEFT_SUBFIELD only supports Object"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    for (i = 0; i < parts.length; ++i) {\n      subpath = parts.slice(0, i + 1).join(\'.\');\n      if (this.isDirectModified(subpath) // earlier prefixes that are already\n            // marked as dirty have precedence\n          || this.get(subpath) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n\n  // if this doc is being constructed we should not trigger getters\n  var priorVal = constructing\n      ? undefined\n      : this.getValue(path);\n\n  if (!schema) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n    return this;\n  }\n\n  var shouldSet = true;\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    var didPopulate = false;\n    if (schema.options &&\n        schema.options.ref &&\n        val instanceof Document &&\n        (schema.options.ref === val.constructor.modelName || schema.options.ref === val.constructor.baseModelName)) {\n      if (this.ownerDocument) {\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val._id, {model: val.constructor});\n      } else {\n        this.populated(path, val._id, {model: val.constructor});\n      }\n      didPopulate = true;\n    }\n\n    var popOpts;\n    if (schema.options &&\n        Array.isArray(schema.options.type) &&\n        schema.options.type.length &&\n        schema.options.type[0].ref &&\n        Array.isArray(val) &&\n        val.length > 0 &&\n        val[0] instanceof Document &&\n        val[0].constructor.modelName &&\n        (schema.options.type[0].ref === val[0].constructor.baseModelName || schema.options.type[0].ref === val[0].constructor.modelName)) {\n      if (this.ownerDocument) {\n        popOpts = { model: val[0].constructor };\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val.map(function(v) { return v._id; }), popOpts);\n      } else {\n        popOpts = { model: val[0].constructor };\n        this.populated(path, val.map(function(v) { return v._id; }), popOpts);\n      }\n      didPopulate = true;\n    }\n    val = schema.applySetters(val, this, false, priorVal);\n\n    if (!didPopulate && this.$__.populated) {\n      delete this.$__.populated[path];\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    this.invalidate(path,\n      new MongooseError.CastError(schema.instance, val, path, e));\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n}',
  '$__delta': 'function () {\n  var dirty = this.$__dirty();\n  if (!dirty.length && VERSION_ALL !== this.$__.version) return;\n\n  var where = {},\n      delta = {},\n      len = dirty.length,\n      divergent = [],\n      d = 0;\n\n  where._id = this._doc._id;\n  if (where._id.toObject) {\n    where._id = where._id.toObject({ transform: false, depopulate: true });\n  }\n\n  for (; d < len; ++d) {\n    var data = dirty[d];\n    var value = data.value;\n\n    var match = checkDivergentArray(this, data.path, value);\n    if (match) {\n      divergent.push(match);\n      continue;\n    }\n\n    var pop = this.populated(data.path, true);\n    if (!pop && this.$__.selected) {\n      // If any array was selected using an $elemMatch projection, we alter the path and where clause\n      // NOTE: MongoDB only supports projected $elemMatch on top level array.\n      var pathSplit = data.path.split(\'.\');\n      var top = pathSplit[0];\n      if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {\n        // If the selected array entry was modified\n        if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === \'undefined\') {\n          where[top] = this.$__.selected[top];\n          pathSplit[1] = \'$\';\n          data.path = pathSplit.join(\'.\');\n        }\n        // if the selected array was modified in any other way throw an error\n        else {\n          divergent.push(data.path);\n          continue;\n        }\n      }\n    }\n\n    if (divergent.length) continue;\n\n    if (undefined === value) {\n      operand(this, where, delta, data, 1, \'$unset\');\n    } else if (value === null) {\n      operand(this, where, delta, data, null);\n    } else if (value._path && value._atomics) {\n      // arrays and other custom types (support plugins etc)\n      handleAtomics(this, where, delta, data, value);\n    } else if (value._path && Buffer.isBuffer(value)) {\n      // MongooseBuffer\n      value = value.toObject();\n      operand(this, where, delta, data, value);\n    } else {\n      value = utils.clone(value, {depopulate: 1, _isNested: true});\n      operand(this, where, delta, data, value);\n    }\n  }\n\n  if (divergent.length) {\n    return new DivergentArrayError(divergent);\n  }\n\n  if (this.$__.version) {\n    this.$__version(where, delta);\n  }\n\n  return [where, delta];\n}',
  '$__save': 'function (options, callback) {\n  var _this = this;\n\n  _this.$__handleSave(options, function(error, result) {\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.$__reset();\n    _this.$__storeShard();\n\n    var numAffected = 0;\n    if (result) {\n      if (Array.isArray(result)) {\n        numAffected = result.length;\n      } else if (result.result && result.result.n !== undefined) {\n        numAffected = result.result.n;\n      } else if (result.result && result.result.nModified !== undefined) {\n        numAffected = result.result.nModified;\n      } else {\n        numAffected = result;\n      }\n    }\n\n    // was this an update that required a version bump?\n    if (_this.$__.version && !_this.$__.inserting) {\n      var doIncrement = VERSION_INC === (VERSION_INC & _this.$__.version);\n      _this.$__.version = undefined;\n\n      if (numAffected <= 0) {\n        // the update failed. pass an error back\n        var err = new VersionError(_this);\n        return callback(err);\n      }\n\n      // increment version if was successful\n      if (doIncrement) {\n        var key = _this.schema.options.versionKey;\n        var version = _this.getValue(key) | 0;\n        _this.setValue(key, version + 1);\n      }\n    }\n\n    if (_this.schema.options &&\n        _this.schema.options.saveErrorIfNotFound &&\n        numAffected <= 0) {\n      error = new DocumentNotFoundError(result.$where);\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.emit(\'save\', _this, numAffected);\n    _this.constructor.emit(\'save\', _this, numAffected);\n    callback(null, _this, numAffected);\n  });\n}' }
[2017-05-04 15:50:02.147] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:50:02.157] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:50:02.162] [INFO] app - Redis client default is ready {}
[2017-05-04 15:50:02.334] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:50:05.284] [DEBUG] app - 2017-5-4 15:50:05 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:50:05.289] [WARN] console - this is a logger middleware.
[2017-05-04 15:50:08.368] [DEBUG] app - 2017-5-4 15:50:08 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:50:08.369] [WARN] console - this is a logger middleware.
[2017-05-04 15:50:18.551] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:50:18.568] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:50:18.593] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:50:18.607] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:50:18.573] [INFO] app - Redis client default is ready {}
[2017-05-04 15:50:18.794] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:50:55.167] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:50:55.179] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:50:59.309] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:50:59.323] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:50:59.325] [INFO] app - Redis client default is ready {}
[2017-05-04 15:50:59.464] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:51:00.897] [DEBUG] app - 2017-5-4 15:51:00 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:51:00.904] [WARN] console - this is a logger middleware.
[2017-05-04 15:51:00.922] [WARN] console - usr:o:id:5902b753c5756d72945d90b3
[2017-05-04 15:51:00.930] [WARN] console - usr:o:id:5902b753c5756d72945d90b3
[2017-05-04 15:51:04.161] [DEBUG] app - 2017-5-4 15:51:04 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:51:04.162] [WARN] console - this is a logger middleware.
[2017-05-04 15:51:04.168] [WARN] console - usr:o:id:5902b753c5756d72945d90b3
[2017-05-04 15:51:04.172] [WARN] console - usr:o:id:5902b753c5756d72945d90b3
[2017-05-04 15:56:05.006] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:56:05.020] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:56:05.023] [INFO] app - Redis client default is ready {}
[2017-05-04 15:56:05.168] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:56:11.043] [DEBUG] app - 2017-5-4 15:56:11 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:56:11.047] [WARN] console - this is a logger middleware.
[2017-05-04 15:56:11.065] [WARN] console - usr:o:id:5902b753c5756d72945d90b3
[2017-05-04 15:56:11.072] [WARN] console - usr:o:id:5902b753c5756d72945d90b3
[2017-05-04 15:57:17.728] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:57:17.740] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:57:17.743] [INFO] app - Redis client default is ready {}
[2017-05-04 15:57:17.912] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:57:42.588] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:57:42.600] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:57:42.603] [INFO] app - Redis client default is ready {}
[2017-05-04 15:57:42.856] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:57:45.598] [DEBUG] app - 2017-5-4 15:57:45 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:57:45.602] [WARN] console - this is a logger middleware.
[2017-05-04 15:57:45.622] [WARN] console - usr:o:id:5902b753c5756d72945d90b3
[2017-05-04 15:57:45.624] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:57:45.624] [WARN] console - OK
[2017-05-04 15:57:45.626] [WARN] console - usr:o:id:5902b753c5756d72945d90b3
[2017-05-04 15:57:54.702] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:57:54.717] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:57:54.720] [INFO] app - Redis client default is ready {}
[2017-05-04 15:57:54.934] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:57:56.597] [DEBUG] app - 2017-5-4 15:57:56 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:57:56.601] [WARN] console - this is a logger middleware.
[2017-05-04 15:57:56.616] [WARN] console - usr:o:id:5902b753c5756d72945d90b3
[2017-05-04 15:57:56.618] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:57:56.619] [WARN] console - undefined
[2017-05-04 15:57:56.621] [WARN] console - usr:o:id:5902b753c5756d72945d90b3
[2017-05-04 15:58:20.750] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:58:20.760] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:58:20.763] [INFO] app - Redis client default is ready {}
[2017-05-04 15:58:20.981] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:58:22.118] [DEBUG] app - 2017-5-4 15:58:22 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:58:22.124] [WARN] console - this is a logger middleware.
[2017-05-04 15:58:22.140] [WARN] console - usr:o:id:5902b753c5756d72945d90b3
[2017-05-04 15:58:22.141] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:58:22.142] [WARN] console - undefined
[2017-05-04 15:58:22.144] [WARN] console - usr:o:id:5902b753c5756d72945d90b3
[2017-05-04 15:58:52.495] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:58:52.508] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:58:52.511] [INFO] app - Redis client default is ready {}
[2017-05-04 15:58:52.721] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:58:54.063] [DEBUG] app - 2017-5-4 15:58:54 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:58:54.067] [WARN] console - this is a logger middleware.
[2017-05-04 15:58:54.084] [WARN] console - usr:o:id:5902b753c5756d72945d90b3
[2017-05-04 15:58:54.088] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:58:54.090] [WARN] console - undefined
[2017-05-04 15:59:15.018] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:59:15.028] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:59:15.036] [INFO] app - Redis client default is ready {}
[2017-05-04 15:59:15.210] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:59:16.367] [DEBUG] app - 2017-5-4 15:59:16 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:59:16.372] [WARN] console - this is a logger middleware.
[2017-05-04 15:59:16.393] [WARN] console - usr:o:id:5902b753c5756d72945d90b3
[2017-05-04 15:59:16.398] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:59:16.401] [WARN] console - test ********* undefined
[2017-05-04 15:59:52.319] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 15:59:52.330] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 15:59:52.333] [INFO] app - Redis client default is ready {}
[2017-05-04 15:59:52.531] [INFO] app - application is startup, listening on port 3000
[2017-05-04 15:59:54.794] [DEBUG] app - 2017-5-4 15:59:54 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 15:59:54.798] [WARN] console - this is a logger middleware.
[2017-05-04 15:59:54.822] [WARN] console - usr:o:id:5902b753c5756d72945d90b3
[2017-05-04 15:59:54.827] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 15:59:54.830] [WARN] console - test ********* OK
[2017-05-04 16:00:10.886] [DEBUG] app - 2017-5-4 16:00:10 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:00:10.888] [WARN] console - this is a logger middleware.
[2017-05-04 16:00:10.894] [WARN] console - usr:o:id:5902b753c5756d72945d90b3
[2017-05-04 16:00:10.896] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:00:10.897] [WARN] console - test ********* OK
[2017-05-04 16:00:27.294] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:00:27.314] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:00:27.317] [INFO] app - Redis client default is ready {}
[2017-05-04 16:00:27.504] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:00:28.257] [DEBUG] app - 2017-5-4 16:00:28 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:00:28.261] [WARN] console - this is a logger middleware.
[2017-05-04 16:00:28.285] [WARN] console - usr:o:id:5902b753c5756d72945d90b3
[2017-05-04 16:00:28.291] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:00:28.294] [WARN] console - test ********* OK
[2017-05-04 16:02:27.133] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:02:27.145] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:02:27.148] [INFO] app - Redis client default is ready {}
[2017-05-04 16:02:27.295] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:02:28.229] [DEBUG] app - 2017-5-4 16:02:28 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:02:28.233] [WARN] console - this is a logger middleware.
[2017-05-04 16:02:28.261] [WARN] console - usr:o:id:5902b753c5756d72945d90b3
[2017-05-04 16:02:28.266] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:02:28.272] [WARN] console - test ********* OK
[2017-05-04 16:02:57.883] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:02:57.894] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:02:57.897] [INFO] app - Redis client default is ready {}
[2017-05-04 16:02:58.092] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:02:58.671] [DEBUG] app - 2017-5-4 16:02:58 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:02:58.675] [WARN] console - this is a logger middleware.
[2017-05-04 16:02:58.697] [WARN] console - RedisClient {
  domain: null,
  _events: 
   { newListener: [Function],
     connect: [Function],
     ready: [Function],
     reconnecting: [Function],
     error: [ [Function], [Function: errorHandler] ],
     end: [Function] },
  _eventsCount: 6,
  _maxListeners: undefined,
  address: '127.0.0.1:6379',
  connection_options: { port: 6379, host: '127.0.0.1', family: 4 },
  connection_id: 0,
  connected: true,
  ready: true,
  should_buffer: false,
  max_attempts: 0,
  command_queue: { [String: ''] '0': undefined, _capacity: 16, _length: 0, _front: 1 },
  offline_queue: { [String: ''] _capacity: 16, _length: 0, _front: 0 },
  pipeline_queue: { [String: ''] _capacity: 16, _length: 0, _front: 0 },
  connect_timeout: 3600000,
  enable_offline_queue: true,
  retry_max_delay: null,
  retry_timer: null,
  retry_totaltime: 0,
  retry_delay: 200,
  retry_backoff: 1.7,
  attempts: 1,
  pub_sub_mode: 0,
  subscription_set: {},
  monitoring: false,
  message_buffers: false,
  closing: false,
  server_info: 
   { redis_version: '3.2.8',
     redis_git_sha1: '00000000',
     redis_git_dirty: '0',
     redis_build_id: 'ae7e7d2604b97c53',
     redis_mode: 'standalone',
     os: 'Darwin 15.0.0 x86_64',
     arch_bits: '64',
     multiplexing_api: 'kqueue',
     gcc_version: '4.2.1',
     process_id: '96159',
     run_id: 'ebe29182b7fe6e47163ac97dca7db95076a825ff',
     tcp_port: '6379',
     uptime_in_seconds: '10830',
     uptime_in_days: '0',
     hz: '10',
     lru_clock: '712753',
     executable: '/usr/local/redis/./bin/redis-server',
     config_file: '/usr/local/redis/./etc/redis.conf',
     connected_clients: '2',
     client_longest_output_list: '0',
     client_biggest_input_buf: '0',
     blocked_clients: '0',
     used_memory: '1105760',
     used_memory_human: '1.05M',
     used_memory_rss: '1839104',
     used_memory_rss_human: '1.75M',
     used_memory_peak: '1138848',
     used_memory_peak_human: '1.09M',
     total_system_memory: '8589934592',
     total_system_memory_human: '8.00G',
     used_memory_lua: '37888',
     used_memory_lua_human: '37.00K',
     maxmemory: '0',
     maxmemory_human: '0B',
     maxmemory_policy: 'noeviction',
     mem_fragmentation_ratio: '1.66',
     mem_allocator: 'libc',
     loading: '0',
     rdb_changes_since_last_save: '8',
     rdb_bgsave_in_progress: '0',
     rdb_last_save_time: '1493884665',
     rdb_last_bgsave_status: 'ok',
     rdb_last_bgsave_time_sec: '0',
     rdb_current_bgsave_time_sec: '-1',
     aof_enabled: '0',
     aof_rewrite_in_progress: '0',
     aof_rewrite_scheduled: '0',
     aof_last_rewrite_time_sec: '-1',
     aof_current_rewrite_time_sec: '-1',
     aof_last_bgrewrite_status: 'ok',
     aof_last_write_status: 'ok',
     total_connections_received: '225',
     total_commands_processed: '297',
     instantaneous_ops_per_sec: '0',
     total_net_input_bytes: '548439',
     total_net_output_bytes: '17150211',
     instantaneous_input_kbps: '0.00',
     instantaneous_output_kbps: '0.00',
     rejected_connections: '0',
     sync_full: '0',
     sync_partial_ok: '0',
     sync_partial_err: '0',
     expired_keys: '0',
     evicted_keys: '0',
     keyspace_hits: '22',
     keyspace_misses: '5',
     pubsub_channels: '0',
     pubsub_patterns: '0',
     latest_fork_usec: '495',
     migrate_cached_sockets: '0',
     role: 'master',
     connected_slaves: '0',
     master_repl_offset: '0',
     repl_backlog_active: '0',
     repl_backlog_size: '1048576',
     repl_backlog_first_byte_offset: '0',
     repl_backlog_histlen: '0',
     used_cpu_sys: '4.00',
     used_cpu_user: '2.25',
     used_cpu_sys_children: '0.01',
     used_cpu_user_children: '0.00',
     cluster_enabled: '0',
     db0: { avg_ttl: 0, expires: 0, keys: 3 },
     db2: { avg_ttl: 0, expires: 0, keys: 1 },
     versions: [ 3, 2, 8 ] },
  auth_pass: undefined,
  selected_db: undefined,
  old_state: null,
  fire_strings: true,
  pipeline: false,
  sub_commands_left: 0,
  times_connected: 1,
  buffers: false,
  options: 
   { port: 6379,
     host: '127.0.0.1',
     socket_nodelay: true,
     socket_keepalive: true,
     return_buffers: false,
     detect_buffers: false },
  reply: 'ON',
  reply_parser: 
   JavascriptRedisParser {
     optionReturnBuffers: false,
     optionStringNumbers: false,
     returnError: [Function: returnError],
     returnFatalError: [Function: returnFatalError],
     returnReply: [Function: returnReply],
     name: 'javascript',
     offset: 2220,
     buffer: null,
     bigStrSize: 0,
     bigOffset: 0,
     totalChunkSize: 0,
     bufferCache: [],
     arrayCache: [],
     arrayPos: [] },
  stream: 
   Socket {
     connecting: false,
     _hadError: false,
     _handle: 
      TCP {
        bytesRead: 2220,
        _externalStream: {},
        fd: 15,
        reading: true,
        owner: [Circular],
        onread: [Function: onread],
        onconnection: null,
        writeQueueSize: 0 },
     _parent: null,
     _host: null,
     _readableState: 
      ReadableState {
        objectMode: false,
        highWaterMark: 16384,
        buffer: [Object],
        length: 0,
        pipes: null,
        pipesCount: 0,
        flowing: true,
        ended: false,
        endEmitted: false,
        reading: true,
        sync: false,
        needReadable: true,
        emittedReadable: false,
        readableListening: false,
        resumeScheduled: false,
        defaultEncoding: 'utf8',
        ranOut: false,
        awaitDrain: 0,
        readingMore: false,
        decoder: null,
        encoding: null },
     readable: true,
     domain: null,
     _events: 
      { end: [Object],
        finish: [Function: onSocketFinish],
        _socketEnd: [Function: onSocketEnd],
        data: [Function],
        error: [Function],
        clientError: [Function],
        close: [Object],
        drain: [Function] },
     _eventsCount: 8,
     _maxListeners: undefined,
     _writableState: 
      WritableState {
        objectMode: false,
        highWaterMark: 16384,
        needDrain: false,
        ending: false,
        ended: false,
        finished: false,
        decodeStrings: false,
        defaultEncoding: 'utf8',
        length: 0,
        writing: false,
        corked: 0,
        sync: false,
        bufferProcessing: false,
        onwrite: [Function: bound onwrite],
        writecb: null,
        writelen: 0,
        bufferedRequest: null,
        lastBufferedRequest: null,
        pendingcb: 0,
        prefinished: false,
        errorEmitted: false,
        bufferedRequestCount: 0,
        corkedRequestsFree: [Object] },
     writable: true,
     allowHalfOpen: false,
     destroyed: false,
     _bytesDispatched: 14,
     _sockname: null,
     _pendingData: null,
     _pendingEncoding: '',
     server: null,
     _server: null,
     read: [Function],
     _consuming: true,
     _idleNext: null,
     _idlePrev: null,
     _idleTimeout: -1 },
  emitted_end: false,
  cork: [Function],
  uncork: [Function] }
[2017-05-04 16:03:37.204] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:03:37.214] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:03:37.218] [INFO] app - Redis client default is ready {}
[2017-05-04 16:03:37.430] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:03:38.428] [DEBUG] app - 2017-5-4 16:03:38 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:03:38.434] [WARN] console - this is a logger middleware.
[2017-05-04 16:03:38.448] [WARN] console - [Function: ret]
[2017-05-04 16:05:08.943] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:05:08.957] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:05:08.961] [INFO] app - Redis client default is ready {}
[2017-05-04 16:05:09.184] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:05:11.711] [DEBUG] app - 2017-5-4 16:05:11 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:05:11.715] [WARN] console - this is a logger middleware.
[2017-05-04 16:05:11.733] [WARN] console - [Function: ret]
[2017-05-04 16:05:11.739] [WARN] console - null
[2017-05-04 16:05:22.207] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:05:22.217] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:05:22.220] [INFO] app - Redis client default is ready {}
[2017-05-04 16:05:22.438] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:05:23.149] [DEBUG] app - 2017-5-4 16:05:23 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:05:23.152] [WARN] console - this is a logger middleware.
[2017-05-04 16:05:23.168] [WARN] console - [Function: ret]
[2017-05-04 16:05:23.174] [WARN] console - null
[2017-05-04 16:05:32.463] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:05:32.481] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:05:32.484] [INFO] app - Redis client default is ready {}
[2017-05-04 16:05:32.662] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:05:33.535] [DEBUG] app - 2017-5-4 16:05:33 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:05:33.539] [WARN] console - this is a logger middleware.
[2017-05-04 16:05:33.561] [WARN] console - [Function: ret]
[2017-05-04 16:05:33.568] [WARN] console - ??? null
[2017-05-04 16:05:43.366] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:05:43.377] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:05:43.382] [INFO] app - Redis client default is ready {}
[2017-05-04 16:05:43.592] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:05:46.047] [DEBUG] app - 2017-5-4 16:05:46 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:05:46.050] [WARN] console - this is a logger middleware.
[2017-05-04 16:05:46.070] [WARN] console - [Function: ret]
[2017-05-04 16:05:46.077] [WARN] console - ??? null
[2017-05-04 16:06:31.588] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:06:31.600] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:06:31.603] [INFO] app - Redis client default is ready {}
[2017-05-04 16:06:31.782] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:06:33.280] [DEBUG] app - 2017-5-4 16:06:33 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:06:33.285] [WARN] console - this is a logger middleware.
[2017-05-04 16:06:33.307] [WARN] console - [Function: ret]
[2017-05-04 16:06:33.319] [WARN] console - ??? 11
[2017-05-04 16:06:45.591] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:06:45.603] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:06:45.606] [INFO] app - Redis client default is ready {}
[2017-05-04 16:06:45.819] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:06:46.521] [DEBUG] app - 2017-5-4 16:06:46 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:06:46.525] [WARN] console - this is a logger middleware.
[2017-05-04 16:06:46.542] [WARN] console - [Function: ret]
[2017-05-04 16:06:46.551] [WARN] console - ??? 11
[2017-05-04 16:06:48.067] [DEBUG] app - 2017-5-4 16:06:48 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:06:48.069] [WARN] console - this is a logger middleware.
[2017-05-04 16:06:48.073] [WARN] console - [Function: ret]
[2017-05-04 16:06:48.075] [WARN] console - ??? 11
[2017-05-04 16:07:16.567] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:07:16.584] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:07:16.587] [INFO] app - Redis client default is ready {}
[2017-05-04 16:07:16.788] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:07:19.978] [DEBUG] app - 2017-5-4 16:07:19 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:07:19.981] [WARN] console - this is a logger middleware.
[2017-05-04 16:07:20.004] [WARN] console - [Function: ret]
[2017-05-04 16:07:46.959] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:07:46.969] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:07:46.972] [INFO] app - Redis client default is ready {}
[2017-05-04 16:07:47.142] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:07:48.411] [DEBUG] app - 2017-5-4 16:07:48 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:07:48.416] [WARN] console - this is a logger middleware.
[2017-05-04 16:07:48.434] [WARN] console - [Function: ret]
[2017-05-04 16:07:48.441] [WARN] console - res*********** 222
[2017-05-04 16:12:15.590] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:12:15.599] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:12:15.602] [INFO] app - Redis client default is ready {}
[2017-05-04 16:12:15.783] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:12:24.128] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:12:24.140] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:12:24.144] [INFO] app - Redis client default is ready {}
[2017-05-04 16:12:24.333] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:12:29.282] [DEBUG] app - 2017-5-4 16:12:29 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:12:29.286] [WARN] console - this is a logger middleware.
[2017-05-04 16:12:29.306] [WARN] console - node_redis: Deprecated: The HGETALL command contains a argument of type Object.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:12:29.308] [ERROR] app - { ReplyError: ERR wrong number of arguments for 'hgetall' command
    at parseError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/redis-parser/lib/parser.js:193:12)
    at parseType (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/redis-parser/lib/parser.js:303:14)
  command: 'HGETALL',
  args: [ '111', { name: '1111' } ],
  code: 'ERR' }
[2017-05-04 16:12:29.314] [ERROR] console - { ReplyError: ERR wrong number of arguments for 'hgetall' command
    at parseError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/redis-parser/lib/parser.js:193:12)
    at parseType (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/redis-parser/lib/parser.js:303:14)
  command: 'HGETALL',
  args: [ '111', { name: '1111' } ],
  code: 'ERR' }
[2017-05-04 16:13:14.441] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:13:14.452] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:13:14.455] [INFO] app - Redis client default is ready {}
[2017-05-04 16:13:14.621] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:13:15.286] [DEBUG] app - 2017-5-4 16:13:15 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:13:15.290] [WARN] console - this is a logger middleware.
[2017-05-04 16:13:15.309] [WARN] console - node_redis: Deprecated: The HGETALL command contains a argument of type Object.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:13:15.313] [ERROR] app - { ReplyError: ERR wrong number of arguments for 'hgetall' command
    at parseError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/redis-parser/lib/parser.js:193:12)
    at parseType (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/redis-parser/lib/parser.js:303:14)
  command: 'HGETALL',
  args: [ '111', { name: '1111' } ],
  code: 'ERR' }
[2017-05-04 16:13:15.318] [ERROR] console - { ReplyError: ERR wrong number of arguments for 'hgetall' command
    at parseError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/redis-parser/lib/parser.js:193:12)
    at parseType (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/redis-parser/lib/parser.js:303:14)
  command: 'HGETALL',
  args: [ '111', { name: '1111' } ],
  code: 'ERR' }
[2017-05-04 16:13:43.167] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:13:43.185] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:13:43.191] [INFO] app - Redis client default is ready {}
[2017-05-04 16:13:43.368] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:13:45.639] [DEBUG] app - 2017-5-4 16:13:45 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:13:45.643] [WARN] console - this is a logger middleware.
[2017-05-04 16:13:45.663] [WARN] console - node_redis: Deprecated: The HGETALL command contains a argument of type Object.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:13:45.666] [ERROR] app - { ReplyError: ERR wrong number of arguments for 'hgetall' command
    at parseError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/redis-parser/lib/parser.js:193:12)
    at parseType (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/redis-parser/lib/parser.js:303:14)
  command: 'HGETALL',
  args: [ '111', { name: '1111' } ],
  code: 'ERR' }
[2017-05-04 16:13:45.671] [ERROR] console - { ReplyError: ERR wrong number of arguments for 'hgetall' command
    at parseError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/redis-parser/lib/parser.js:193:12)
    at parseType (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/redis-parser/lib/parser.js:303:14)
  command: 'HGETALL',
  args: [ '111', { name: '1111' } ],
  code: 'ERR' }
[2017-05-04 16:14:02.540] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:14:02.551] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:14:02.556] [INFO] app - Redis client default is ready {}
[2017-05-04 16:14:02.777] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:14:03.843] [DEBUG] app - 2017-5-4 16:14:03 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:14:03.847] [WARN] console - this is a logger middleware.
[2017-05-04 16:14:03.876] [ERROR] app - TypeError: console.wran is not a function
    at UserKv._callee2$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:32:15)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:9:361
    at process._tickDomainCallback (internal/process/next_tick.js:135:7)
[2017-05-04 16:14:03.885] [ERROR] console - TypeError: console.wran is not a function
    at UserKv._callee2$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:32:15)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:9:361
    at process._tickDomainCallback (internal/process/next_tick.js:135:7)
[2017-05-04 16:14:14.259] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:14:14.273] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:14:14.282] [INFO] app - Redis client default is ready {}
[2017-05-04 16:14:14.473] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:14:15.400] [DEBUG] app - 2017-5-4 16:14:15 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:14:15.404] [WARN] console - this is a logger middleware.
[2017-05-04 16:14:15.429] [WARN] console - { name: '1111' }
[2017-05-04 16:14:30.414] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:14:30.424] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:14:30.427] [INFO] app - Redis client default is ready {}
[2017-05-04 16:14:30.645] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:14:31.624] [DEBUG] app - 2017-5-4 16:14:31 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:14:31.632] [WARN] console - this is a logger middleware.
[2017-05-04 16:14:31.656] [WARN] console - { name: '1111' }
[2017-05-04 16:14:33.889] [DEBUG] app - 2017-5-4 16:14:33 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:14:33.890] [WARN] console - this is a logger middleware.
[2017-05-04 16:14:33.892] [WARN] console - { name: '1111' }
[2017-05-04 16:14:44.322] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:14:44.333] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:14:44.337] [INFO] app - Redis client default is ready {}
[2017-05-04 16:14:44.545] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:14:45.607] [DEBUG] app - 2017-5-4 16:14:45 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:14:45.611] [WARN] console - this is a logger middleware.
[2017-05-04 16:14:45.633] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type InternalCache.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:14:45.634] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:14:45.634] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Object.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:14:45.634] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type NativeConnection.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:14:45.634] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:14:45.634] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type ObjectID.
This is converted to "5902b753c5756d72945d90b3" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:14:45.634] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Schema.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:14:45.635] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type NativeCollection.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:14:45.635] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Object.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:14:45.635] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Object.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:14:45.638] [WARN] console - { '$pre': 'function (name, isAsync, fn, errorCb) {\n    if (\'boolean\' !== typeof arguments[1]) {\n      errorCb = fn;\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {};\n\n    this._lazySetupHooks(proto, name, errorCb);\n\n    if (fn.isAsync = isAsync) {\n      proto[name].numAsyncPres++;\n    }\n\n    (pres[name] = pres[name] || []).push(fn);\n    return this;\n  }',
  errors: 'undefined',
  addListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  setValue: 'function (path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n}',
  '$__where': 'function _where(where) {\n  where || (where = {});\n\n  var paths,\n      len;\n\n  if (!where._id) {\n    where._id = this._doc._id;\n  }\n\n  if (this.$__.shardval) {\n    paths = Object.keys(this.$__.shardval);\n    len = paths.length;\n\n    for (var i = 0; i < len; ++i) {\n      where[paths[i]] = this.$__.shardval[paths[i]];\n    }\n  }\n\n  if (this._doc._id == null) {\n    return new Error(\'No _id found on document!\');\n  }\n\n  return where;\n}',
  _doc: '[object Object]',
  _id: '5902b753c5756d72945d90b3',
  '$post': 'function (name, isAsync, fn) {\n    if (arguments.length === 2) {\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , posts = proto._posts = proto._posts || {};\n    \n    this._lazySetupHooks(proto, name);\n    (posts[name] = posts[name] || []).push(fn);\n    return this;\n  }',
  getValue: 'function (path) {\n  return utils.getValue(path, this._doc);\n}',
  '$__handleSave': 'function (options, callback) {\n  var _this = this;\n  var i;\n  var keys;\n  var len;\n  if (!options.safe && this.schema.options.safe) {\n    options.safe = this.schema.options.safe;\n  }\n  if (typeof options.safe === \'boolean\') {\n    options.safe = null;\n  }\n\n  if (this.isNew) {\n    // send entire doc\n    var toObjectOptions = {};\n\n    toObjectOptions.retainKeyOrder = this.schema.options.retainKeyOrder;\n    toObjectOptions.depopulate = 1;\n    toObjectOptions._skipDepopulateTopLevel = true;\n    toObjectOptions.transform = false;\n    toObjectOptions.flattenDecimals = false;\n\n    var obj = this.toObject(toObjectOptions);\n\n    if (!utils.object.hasOwnProperty(obj || {}, \'_id\')) {\n      // documents must have an _id else mongoose won\'t know\n      // what to update later if more changes are made. the user\n      // wouldn\'t know what _id was generated by mongodb either\n      // nor would the ObjectId generated my mongodb necessarily\n      // match the schema definition.\n      setTimeout(function() {\n        callback(new Error(\'document must have an _id before saving\'));\n      }, 0);\n      return;\n    }\n\n    this.$__version(true, obj);\n    this.collection.insert(obj, options.safe, function(err, ret) {\n      if (err) {\n        _this.isNew = true;\n        _this.emit(\'isNew\', true);\n        _this.constructor.emit(\'isNew\', true);\n\n        callback(err);\n        return;\n      }\n\n      callback(null, ret);\n    });\n    this.$__reset();\n    this.isNew = false;\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n    // Make it possible to retry the insert\n    this.$__.inserting = true;\n  } else {\n    // Make sure we don\'t treat it as a new object on error,\n    // since it already exists\n    this.$__.inserting = false;\n\n    var delta = this.$__delta();\n\n    if (delta) {\n      if (delta instanceof Error) {\n        callback(delta);\n        return;\n      }\n\n      var where = this.$__where(delta[0]);\n      if (where instanceof Error) {\n        callback(where);\n        return;\n      }\n\n      if (this.$where) {\n        keys = Object.keys(this.$where);\n        len = keys.length;\n        for (i = 0; i < len; ++i) {\n          where[keys[i]] = this.$where[keys[i]];\n        }\n      }\n\n      this.collection.update(where, delta[1], options.safe, function(err, ret) {\n        if (err) {\n          callback(err);\n          return;\n        }\n        ret.$where = where;\n        callback(null, ret);\n      });\n    } else {\n      this.$__reset();\n      callback();\n      return;\n    }\n\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n  }\n}',
  '$__buildDoc': 'function (obj, fields, skipId) {\n  var doc = {};\n  var exclude = null;\n  var keys;\n  var ki;\n  var _this = this;\n\n  // determine if this doc is a result of a query with\n  // excluded fields\n\n  if (fields && utils.getFunctionName(fields.constructor) === \'Object\') {\n    keys = Object.keys(fields);\n    ki = keys.length;\n\n    if (ki === 1 && keys[0] === \'_id\') {\n      exclude = !!fields[keys[ki]];\n    } else {\n      while (ki--) {\n        if (keys[ki] !== \'_id\' &&\n            (!fields[keys[ki]] || typeof fields[keys[ki]] !== \'object\')) {\n          exclude = !fields[keys[ki]];\n          break;\n        }\n      }\n    }\n  }\n\n  var paths = Object.keys(this.schema.paths);\n  var plen = paths.length;\n  var ii = 0;\n\n  var hasIncludedChildren = {};\n  if (exclude === false && fields) {\n    keys = Object.keys(fields);\n    for (var j = 0; j < keys.length; ++j) {\n      var parts = keys[j].split(\'.\');\n      var c = [];\n      for (var k = 0; k < parts.length; ++k) {\n        c.push(parts[k]);\n        hasIncludedChildren[c.join(\'.\')] = 1;\n      }\n    }\n  }\n\n  for (; ii < plen; ++ii) {\n    var p = paths[ii];\n\n    if (p === \'_id\') {\n      if (skipId) {\n        continue;\n      }\n      if (obj && \'_id\' in obj) {\n        continue;\n      }\n    }\n\n    var type = this.schema.paths[p];\n    var path = p.split(\'.\');\n    var len = path.length;\n    var last = len - 1;\n    var curPath = \'\';\n    var doc_ = doc;\n    var i = 0;\n    var included = false;\n\n    for (; i < len; ++i) {\n      var piece = path[i],\n          def;\n\n      curPath += (!curPath.length ? \'\' : \'.\') + piece;\n\n      // support excluding intermediary levels\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i === last) {\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          } else if (included) {\n            // selected field\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          }\n        } else {\n          def = type.getDefault(_this, false);\n          if (typeof def !== \'undefined\') {\n            doc_[piece] = def;\n            _this.$__.activePaths.default(p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  return doc;\n}',
  '$ignore': 'function (path) {\n  this.$__.activePaths.ignore(path);\n}',
  removePre: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , pres = proto._pres || (proto._pres || {});\n    if (!pres[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all pre callbacks for hook `name`\n      pres[name].length = 0;\n    } else {\n      pres[name] = pres[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  collection: '[object Object]',
  emit: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  createdAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  '$__version': 'function (where, delta) {\n  var key = this.schema.options.versionKey;\n\n  if (where === true) {\n    // this is an insert\n    if (key) this.setValue(key, delta[key] = 0);\n    return;\n  }\n\n  // updates\n\n  // only apply versioning if our versionKey was selected. else\n  // there is no way to select the correct version. we could fail\n  // fast here and force them to include the versionKey but\n  // thats a bit intrusive. can we do this automatically?\n  if (!this.isSelected(key)) {\n    return;\n  }\n\n  // $push $addToSet don\'t need the where clause set\n  if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {\n    where[key] = this.getValue(key);\n  }\n\n  if (VERSION_INC === (VERSION_INC & this.$__.version)) {\n    if (!delta.$set || typeof delta.$set[key] === \'undefined\') {\n      delta.$inc || (delta.$inc = {});\n      delta.$inc[key] = 1;\n    }\n  }\n}',
  '$isMongooseModelPrototype': 'true',
  set: 'function (path, val, type, options) {\n  if (type && utils.getFunctionName(type.constructor) === \'Object\') {\n    options = type;\n    type = undefined;\n  }\n\n  var merge = options && options.merge,\n      adhoc = type && type !== true,\n      constructing = type === true,\n      adhocs;\n\n  var strict = options && \'strict\' in options\n      ? options.strict\n      : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  if (typeof path !== \'string\') {\n    // new Document({ key: val })\n\n    if (path === null || path === void 0) {\n      var _ = path;\n      path = val;\n      val = _;\n    } else {\n      var prefix = val\n          ? val + \'.\'\n          : \'\';\n\n      if (path instanceof Document) {\n        if (path.$__isNested) {\n          path = path.toObject();\n        } else {\n          path = path._doc;\n        }\n      }\n\n      var keys = Object.keys(path);\n      var len = keys.length;\n      var i = 0;\n      var pathtype;\n      var key;\n\n      if (len === 0 && !this.schema.options.minimize) {\n        if (val) {\n          this.set(val, {});\n        }\n        return this;\n      }\n\n      if (this.schema.options.retainKeyOrder) {\n        while (i < len) {\n          _handleIndex.call(this, i++);\n        }\n      } else {\n        while (len--) {\n          _handleIndex.call(this, len);\n        }\n      }\n\n      return this;\n    }\n  }\n\n  function _handleIndex(i) {\n    key = keys[i];\n    var pathName = prefix + key;\n    pathtype = this.schema.pathType(pathName);\n\n    if (path[key] !== null\n        && path[key] !== void 0\n          // need to know if plain object - no Buffer, ObjectId, ref, etc\n        && utils.isObject(path[key])\n        && (!path[key].constructor || utils.getFunctionName(path[key].constructor) === \'Object\')\n        && pathtype !== \'virtual\'\n        && pathtype !== \'real\'\n        && !(this.$__path(pathName) instanceof MixedSchema)\n        && !(this.schema.paths[pathName] &&\n        this.schema.paths[pathName].options &&\n        this.schema.paths[pathName].options.ref)) {\n      this.set(path[key], prefix + key, constructing);\n    } else if (strict) {\n      // Don\'t overwrite defaults with undefined keys (gh-3981)\n      if (constructing && path[key] === void 0 &&\n          this.get(key) !== void 0) {\n        return;\n      }\n\n      if (pathtype === \'real\' || pathtype === \'virtual\') {\n        // Check for setting single embedded schema to document (gh-3535)\n        var p = path[key];\n        if (this.schema.paths[pathName] &&\n            this.schema.paths[pathName].$isSingleNested &&\n            path[key] instanceof Document) {\n          p = p.toObject({ virtuals: false, transform: false });\n        }\n        this.set(prefix + key, p, constructing);\n      } else if (pathtype === \'nested\' && path[key] instanceof Document) {\n        this.set(prefix + key,\n            path[key].toObject({transform: false}), constructing);\n      } else if (strict === \'throw\') {\n        if (pathtype === \'nested\') {\n          throw new ObjectExpectedError(key, path[key]);\n        } else {\n          throw new StrictModeError(key);\n        }\n      }\n    } else if (path[key] !== void 0) {\n      this.set(prefix + key, path[key], constructing);\n    }\n  }\n\n  var pathType = this.schema.pathType(path);\n  if (pathType === \'nested\' && val) {\n    if (utils.isObject(val) &&\n        (!val.constructor || utils.getFunctionName(val.constructor) === \'Object\')) {\n      if (!merge) {\n        this.setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      }\n\n      if (Object.keys(val).length === 0) {\n        this.setValue(path, {});\n        this.markModified(path);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        this.set(val, path, constructing);\n      }\n      return this;\n    }\n    this.invalidate(path, new MongooseError.CastError(\'Object\', val, path));\n    return this;\n  }\n\n  var schema;\n  var parts = path.split(\'.\');\n\n  if (pathType === \'adhocOrUndefined\' && strict) {\n    // check for roots that are Mixed types\n    var mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      var subpath = parts.slice(0, i + 1).join(\'.\');\n      schema = this.schema.path(subpath);\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n\n      // If path is underneath a virtual, bypass everything and just set it.\n      if (i + 1 < parts.length && this.schema.pathType(subpath) === \'virtual\') {\n        mpath.set(path, val, this);\n        return this;\n      }\n    }\n\n    if (!mixed) {\n      if (strict === \'throw\') {\n        throw new StrictModeError(path);\n      }\n      return this;\n    }\n  } else if (pathType === \'virtual\') {\n    schema = this.schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  var pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: "LEFT_SUBFIELD only supports Object"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    for (i = 0; i < parts.length; ++i) {\n      subpath = parts.slice(0, i + 1).join(\'.\');\n      if (this.isDirectModified(subpath) // earlier prefixes that are already\n            // marked as dirty have precedence\n          || this.get(subpath) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n\n  // if this doc is being constructed we should not trigger getters\n  var priorVal = constructing\n      ? undefined\n      : this.getValue(path);\n\n  if (!schema) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n    return this;\n  }\n\n  var shouldSet = true;\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    var didPopulate = false;\n    if (schema.options &&\n        schema.options.ref &&\n        val instanceof Document &&\n        (schema.options.ref === val.constructor.modelName || schema.options.ref === val.constructor.baseModelName)) {\n      if (this.ownerDocument) {\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val._id, {model: val.constructor});\n      } else {\n        this.populated(path, val._id, {model: val.constructor});\n      }\n      didPopulate = true;\n    }\n\n    var popOpts;\n    if (schema.options &&\n        Array.isArray(schema.options.type) &&\n        schema.options.type.length &&\n        schema.options.type[0].ref &&\n        Array.isArray(val) &&\n        val.length > 0 &&\n        val[0] instanceof Document &&\n        val[0].constructor.modelName &&\n        (schema.options.type[0].ref === val[0].constructor.baseModelName || schema.options.type[0].ref === val[0].constructor.modelName)) {\n      if (this.ownerDocument) {\n        popOpts = { model: val[0].constructor };\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val.map(function(v) { return v._id; }), popOpts);\n      } else {\n        popOpts = { model: val[0].constructor };\n        this.populated(path, val.map(function(v) { return v._id; }), popOpts);\n      }\n      didPopulate = true;\n    }\n    val = schema.applySetters(val, this, false, priorVal);\n\n    if (!didPopulate && this.$__.populated) {\n      delete this.$__.populated[path];\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    this.invalidate(path,\n      new MongooseError.CastError(schema.instance, val, path, e));\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n}',
  modifiedPaths: 'function () {\n  var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n  return directModifiedPaths.reduce(function(list, path) {\n    var parts = path.split(\'.\');\n    return list.concat(parts.reduce(function(chains, part, i) {\n      return chains.concat(parts.slice(0, i).concat(part).join(\'.\'));\n    }, []).filter(function(chain) {\n      return (list.indexOf(chain) === -1);\n    }));\n  }, []);\n}',
  get: 'function (path, type) {\n  var adhoc;\n  if (type) {\n    adhoc = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  var schema = this.$__path(path) || this.schema.virtualpath(path),\n      pieces = path.split(\'.\'),\n      obj = this._doc;\n\n  for (var i = 0, l = pieces.length; i < l; i++) {\n    obj = obj === null || obj === void 0\n        ? undefined\n        : obj[pieces[i]];\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  // Check if this path is populated - don\'t apply getters if it is,\n  // because otherwise its a nested object. See gh-3357\n  if (schema && !this.populated(path)) {\n    obj = schema.applyGetters(obj, this);\n  }\n\n  return obj;\n}',
  updatedAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  '$__path': 'function (path) {\n  var adhocs = this.$__.adhocPaths,\n      adhocType = adhocs && adhocs[path];\n\n  if (adhocType) {\n    return adhocType;\n  }\n  return this.schema.path(path);\n}',
  '$__save': 'function (options, callback) {\n  var _this = this;\n\n  _this.$__handleSave(options, function(error, result) {\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.$__reset();\n    _this.$__storeShard();\n\n    var numAffected = 0;\n    if (result) {\n      if (Array.isArray(result)) {\n        numAffected = result.length;\n      } else if (result.result && result.result.n !== undefined) {\n        numAffected = result.result.n;\n      } else if (result.result && result.result.nModified !== undefined) {\n        numAffected = result.result.nModified;\n      } else {\n        numAffected = result;\n      }\n    }\n\n    // was this an update that required a version bump?\n    if (_this.$__.version && !_this.$__.inserting) {\n      var doIncrement = VERSION_INC === (VERSION_INC & _this.$__.version);\n      _this.$__.version = undefined;\n\n      if (numAffected <= 0) {\n        // the update failed. pass an error back\n        var err = new VersionError(_this);\n        return callback(err);\n      }\n\n      // increment version if was successful\n      if (doIncrement) {\n        var key = _this.schema.options.versionKey;\n        var version = _this.getValue(key) | 0;\n        _this.setValue(key, version + 1);\n      }\n    }\n\n    if (_this.schema.options &&\n        _this.schema.options.saveErrorIfNotFound &&\n        numAffected <= 0) {\n      error = new DocumentNotFoundError(result.$where);\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.emit(\'save\', _this, numAffected);\n    _this.constructor.emit(\'save\', _this, numAffected);\n    callback(null, _this, numAffected);\n  });\n}',
  '$__delta': 'function () {\n  var dirty = this.$__dirty();\n  if (!dirty.length && VERSION_ALL !== this.$__.version) return;\n\n  var where = {},\n      delta = {},\n      len = dirty.length,\n      divergent = [],\n      d = 0;\n\n  where._id = this._doc._id;\n  if (where._id.toObject) {\n    where._id = where._id.toObject({ transform: false, depopulate: true });\n  }\n\n  for (; d < len; ++d) {\n    var data = dirty[d];\n    var value = data.value;\n\n    var match = checkDivergentArray(this, data.path, value);\n    if (match) {\n      divergent.push(match);\n      continue;\n    }\n\n    var pop = this.populated(data.path, true);\n    if (!pop && this.$__.selected) {\n      // If any array was selected using an $elemMatch projection, we alter the path and where clause\n      // NOTE: MongoDB only supports projected $elemMatch on top level array.\n      var pathSplit = data.path.split(\'.\');\n      var top = pathSplit[0];\n      if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {\n        // If the selected array entry was modified\n        if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === \'undefined\') {\n          where[top] = this.$__.selected[top];\n          pathSplit[1] = \'$\';\n          data.path = pathSplit.join(\'.\');\n        }\n        // if the selected array was modified in any other way throw an error\n        else {\n          divergent.push(data.path);\n          continue;\n        }\n      }\n    }\n\n    if (divergent.length) continue;\n\n    if (undefined === value) {\n      operand(this, where, delta, data, 1, \'$unset\');\n    } else if (value === null) {\n      operand(this, where, delta, data, null);\n    } else if (value._path && value._atomics) {\n      // arrays and other custom types (support plugins etc)\n      handleAtomics(this, where, delta, data, value);\n    } else if (value._path && Buffer.isBuffer(value)) {\n      // MongooseBuffer\n      value = value.toObject();\n      operand(this, where, delta, data, value);\n    } else {\n      value = utils.clone(value, {depopulate: 1, _isNested: true});\n      operand(this, where, delta, data, value);\n    }\n  }\n\n  if (divergent.length) {\n    return new DivergentArrayError(divergent);\n  }\n\n  if (this.$__.version) {\n    this.$__version(where, delta);\n  }\n\n  return [where, delta];\n}',
  '$__storeShard': 'function () {\n  // backwards compat\n  var key = this.schema.options.shardKey || this.schema.options.shardkey;\n  if (!(key && utils.getFunctionName(key.constructor) === \'Object\')) {\n    return;\n  }\n\n  var orig = this.$__.shardval = {},\n      paths = Object.keys(key),\n      len = paths.length,\n      val;\n\n  for (var i = 0; i < len; ++i) {\n    val = this.getValue(paths[i]);\n    if (isMongooseObject(val)) {\n      orig[paths[i]] = val.toObject({depopulate: true, _isNested: true});\n    } else if (val !== null && val !== undefined && val.valueOf &&\n          // Explicitly don\'t take value of dates\n        (!val.constructor || utils.getFunctionName(val.constructor) !== \'Date\')) {\n      orig[paths[i]] = val.valueOf();\n    } else {\n      orig[paths[i]] = val;\n    }\n  }\n}',
  listeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  depopulate: 'function (path) {\n  var populatedIds = this.populated(path);\n  if (!populatedIds) {\n    return;\n  }\n  delete this.$__.populated[path];\n  this.set(path, populatedIds);\n  return this;\n}',
  equals: 'function (doc) {\n  if (!doc) {\n    return false;\n  }\n\n  var tid = this.get(\'_id\');\n  var docid = doc.get ? doc.get(\'_id\') : doc;\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals\n      ? tid.equals(docid)\n      : tid === docid;\n}',
  _posts: '[object Object]',
  '$__getAllSubdocs': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  function docReducer(seed, path) {\n    var val = this[path];\n\n    if (val instanceof Embedded) {\n      seed.push(val);\n    }\n    if (val && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(docReducer.bind(val._doc), seed);\n      seed.push(val);\n    }\n    if (val && val.isMongooseDocumentArray) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n        seed = Object.keys(doc._doc).reduce(docReducer.bind(doc._doc), seed);\n      });\n    } else if (val instanceof Document && val.$__isNested) {\n      if (val) {\n        seed = Object.keys(val).reduce(docReducer.bind(val), seed);\n      }\n    }\n    return seed;\n  }\n\n  var subDocs = Object.keys(this._doc).reduce(docReducer.bind(this), []);\n\n  return subDocs;\n}',
  '$__original_save': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  removeListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  '$__getArrayPathsToValidate': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  // validate all document arrays.\n  return this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return this.getValue(i);\n  }.bind(this))\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  }).reduce(function(seed, array) {\n    return seed.concat(array);\n  }, [])\n  .filter(function(doc) {\n    return doc;\n  });\n}',
  schema: '[object Object]',
  removeAllListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  save: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  isDirectSelected: 'function isDirectSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  removePost: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , posts = proto._posts || (proto._posts || {});\n    if (!posts[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all post callbacks for hook `name`\n      posts[name].length = 0;\n    } else {\n      posts[name] = posts[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  _lazySetupHooks: 'function (proto, methodName, errorCb) {\n    if (\'undefined\' === typeof proto[methodName].numAsyncPres) {\n      this.$hook(methodName, proto[methodName], errorCb);\n    }\n  }',
  toBSON: 'function () {\n  return this.toObject({\n    transform: false,\n    virtuals: false,\n    _skipDepopulateTopLevel: true,\n    depopulate: true,\n    flattenDecimals: false\n  });\n}',
  markModified: 'function (path) {\n  this.$__.activePaths.modify(path);\n}',
  on: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  increment: 'function increment() {\n  this.$__.version = VERSION_ALL;\n  return this;\n}',
  validate: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populated: 'function (path, val, options) {\n  // val and options are internal\n\n  if (val === null || val === void 0) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    var v = this.$__.populated[path];\n    if (v) {\n      return v.value;\n    }\n    return undefined;\n  }\n\n  // internal\n\n  if (val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    return this.$__.populated[path];\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = {value: val, options: options};\n  return val;\n}',
  update: 'function update() {\n  var args = utils.args(arguments);\n  args.unshift({_id: this._id});\n  return this.constructor.update.apply(this.constructor, args);\n}',
  id: '5902b753c5756d72945d90b3',
  '$__setSchema': 'function (schema) {\n  compile(schema.tree, this, undefined, schema.options);\n  this.schema = schema;\n}',
  isInit: 'function (path) {\n  return (path in this.$__.activePaths.states.init);\n}',
  '$__validate': 'function (callback) {\n  var _this = this;\n  var _complete = function() {\n    var err = _this.$__.validationError;\n    _this.$__.validationError = undefined;\n    _this.emit(\'validate\', _this);\n    _this.constructor.emit(\'validate\', _this);\n    if (err) {\n      for (var key in err.errors) {\n        // Make sure cast errors persist\n        if (!_this.__parent && err.errors[key] instanceof MongooseError.CastError) {\n          _this.invalidate(key, err.errors[key]);\n        }\n      }\n\n      return err;\n    }\n  };\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (paths.length === 0) {\n    process.nextTick(function() {\n      var error = _complete();\n      if (error) {\n        return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n          callback(error);\n        });\n      }\n      callback();\n    });\n  }\n\n  var validating = {},\n      total = 0;\n\n  var complete = function() {\n    var error = _complete();\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n    callback();\n  };\n\n  var validatePath = function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n    total++;\n\n    process.nextTick(function() {\n      var p = _this.schema.path(path);\n      if (!p) {\n        return --total || complete();\n      }\n\n      // If user marked as invalid or there was a cast error, don\'t validate\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      var val = _this.getValue(path);\n      p.doValidate(val, function(err) {\n        if (err) {\n          _this.invalidate(path, err, undefined, true);\n        }\n        --total || complete();\n      }, _this);\n    });\n  };\n\n  paths.forEach(validatePath);\n}',
  db: '[object Object]',
  username: '222',
  '$__original_validate': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  discriminators: 'undefined',
  isModified: 'function (paths) {\n  if (paths) {\n    if (!Array.isArray(paths)) {\n      paths = paths.split(\' \');\n    }\n    var modified = this.modifiedPaths();\n    var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n    var isModifiedChild = paths.some(function(path) {\n      return !!~modified.indexOf(path);\n    });\n    return isModifiedChild || paths.some(function(path) {\n      return directModifiedPaths.some(function(mod) {\n        return mod === path || path.indexOf(mod + \'.\') === 0;\n      });\n    });\n  }\n  return this.$__.activePaths.some(\'modify\');\n}',
  toObject: 'function (options) {\n  return this.$toObject(options);\n}',
  '$markValid': 'function (path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n}',
  '$isValid': 'function (path) {\n  return !this.$__.validationError || !this.$__.validationError.errors[path];\n}',
  isDirectModified: 'function (path) {\n  return (path in this.$__.activePaths.states.modify);\n}',
  '$__dirty': 'function () {\n  var _this = this;\n\n  var all = this.$__.activePaths.map(\'modify\', function(path) {\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  });\n\n  // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n  all = all.concat(this.$__.activePaths.map(\'default\', function(path) {\n    if (path === \'_id\' || !_this.getValue(path)) {\n      return;\n    }\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n\n  // Sort dirty paths in a flat hierarchy.\n  all.sort(function(a, b) {\n    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));\n  });\n\n  // Ignore "foo.a" if "foo" is dirty already.\n  var minimal = [],\n      lastPath,\n      top;\n\n  all.forEach(function(item) {\n    if (!item) {\n      return;\n    }\n    if (item.path.indexOf(lastPath) !== 0) {\n      lastPath = item.path + \'.\';\n      minimal.push(item);\n      top = item;\n    } else {\n      // special case for top level MongooseArrays\n      if (top.value && top.value._atomics && top.value.hasAtomics()) {\n        // the `top` array itself and a sub path of `top` are being modified.\n        // the only way to honor all of both modifications is through a $set\n        // of entire array.\n        top.value._atomics = {};\n        top.value._atomics.$set = top.value;\n      }\n    }\n  });\n\n  top = lastPath = null;\n  return minimal;\n}',
  model: 'function model(name) {\n  return this.db.model(name);\n}',
  '$isDefault': 'function (path) {\n  return (path in this.$__.activePaths.states.default);\n}',
  '$__original_remove': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  remove: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populate: 'function populate() {\n  if (arguments.length === 0) {\n    return this;\n  }\n\n  var pop = this.$__.populate || (this.$__.populate = {});\n  var args = utils.args(arguments);\n  var fn;\n\n  if (typeof args[args.length - 1] === \'function\') {\n    fn = args.pop();\n  }\n\n  // allow `doc.populate(callback)`\n  if (args.length) {\n    // use hash to remove duplicate paths\n    var res = utils.populate.apply(null, args);\n    for (var i = 0; i < res.length; ++i) {\n      pop[res[i].path] = res[i];\n    }\n  }\n\n  if (fn) {\n    var paths = utils.object.vals(pop);\n    this.$__.populate = undefined;\n    paths.__noPromise = true;\n    this.constructor.populate(this, paths, fn);\n  }\n\n  return this;\n}',
  '$__shouldModify': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  if (this.isNew) {\n    return true;\n  }\n\n  if (undefined === val && !this.isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (undefined === val && path in this.$__.activePaths.states.default) {\n    // we\'re just unsetting the default value which was never saved\n    return false;\n  }\n\n  // gh-3992: if setting a populated field to a doc, don\'t mark modified\n  // if they have the same _id\n  if (this.populated(path) &&\n      val instanceof Document &&\n      deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal || this.get(path))) {\n    return true;\n  }\n\n  if (!constructing &&\n      val !== null &&\n      val !== undefined &&\n      path in this.$__.activePaths.states.default &&\n      deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n  return false;\n}',
  '$__': '[object Object]',
  '$__fullPath': 'function (path) {\n  // overridden in SubDocuments\n  return path || \'\';\n}',
  _pres: '[object Object]',
  inspect: 'function (options) {\n  var isPOJO = options &&\n    utils.getFunctionName(options.constructor) === \'Object\';\n  var opts;\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n    opts.retainKeyOrder = true;\n  }\n  return this.toObject(opts);\n}',
  '$__reset': 'function reset() {\n  var _this = this;\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return _this.getValue(i);\n  })\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  })\n  .forEach(function(array) {\n    var i = array.length;\n    while (i--) {\n      var doc = array[i];\n      if (!doc) {\n        continue;\n      }\n      doc.$__reset();\n    }\n  });\n\n  // clear atomics\n  this.$__dirty().forEach(function(dirt) {\n    var type = dirt.value;\n    if (type && type._atomics) {\n      type._atomics = {};\n    }\n  });\n\n  // Clear \'dirty\' cache\n  this.$__.activePaths.clear(\'modify\');\n  this.$__.activePaths.clear(\'default\');\n  this.$__.validationError = undefined;\n  this.errors = undefined;\n  _this = this;\n  this.schema.requiredPaths().forEach(function(path) {\n    _this.$__.activePaths.require(path);\n  });\n\n  return this;\n}',
  init: 'function (doc, opts, fn) {\n  // do not prefix this method with $__ since its\n  // used by public hooks\n\n  if (typeof opts === \'function\') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.isNew = false;\n\n  // handle docs with populated paths\n  // If doc._id is not null or undefined\n  if (doc._id !== null && doc._id !== undefined &&\n    opts && opts.populated && opts.populated.length) {\n    var id = String(doc._id);\n    for (var i = 0; i < opts.populated.length; ++i) {\n      var item = opts.populated[i];\n      if (item.isVirtual) {\n        this.populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.populated(item.path, item._docs[id], item);\n      }\n    }\n  }\n\n  init(this, doc, this._doc);\n  this.$__storeShard();\n\n  this.emit(\'init\', this);\n  this.constructor.emit(\'init\', this);\n\n  if (fn) {\n    fn(null);\n  }\n  return this;\n}',
  setMaxListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  initializeTimestamps: 'function () {\n      if (!this.get(createdAt)) {\n        this.set(createdAt, new Date());\n      }\n      if (!this.get(updatedAt)) {\n        this.set(updatedAt, new Date());\n      }\n      return this;\n    }',
  once: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  __v: '0',
  '$toObject': 'function (options, json) {\n  var defaultOptions = {\n    transform: true,\n    json: json,\n    retainKeyOrder: this.schema.options.retainKeyOrder,\n    flattenDecimals: true\n  };\n\n  // _isNested will only be true if this is not the top level document, we\n  // should never depopulate\n  if (options && options.depopulate && options._isNested && this.$__.wasPopulated) {\n    // populated paths that we set to a document\n    return clone(this._id, options);\n  }\n\n  // When internally saving this document we always pass options,\n  // bypassing the custom schema options.\n  if (!(options && utils.getFunctionName(options.constructor) === \'Object\') ||\n      (options && options._useSchemaOptions)) {\n    if (json) {\n      options = this.schema.options.toJSON ?\n        clone(this.schema.options.toJSON) :\n        {};\n      options.json = true;\n      options._useSchemaOptions = true;\n    } else {\n      options = this.schema.options.toObject ?\n        clone(this.schema.options.toObject) :\n        {};\n      options.json = false;\n      options._useSchemaOptions = true;\n    }\n  }\n\n  for (var key in defaultOptions) {\n    if (options[key] === undefined) {\n      options[key] = defaultOptions[key];\n    }\n  }\n\n  (\'minimize\' in options) || (options.minimize = this.schema.options.minimize);\n\n  // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n  var originalTransform = options.transform;\n\n  options._isNested = true;\n\n  var ret = clone(this._doc, options) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, \'paths\', options);\n    // applyGetters for paths will add nested empty objects;\n    // if minimize is set, we need to remove them.\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || options.getters && options.virtuals !== false) {\n    applyGetters(this, ret, \'virtuals\', options);\n  }\n\n  if (options.versionKey === false && this.schema.options.versionKey) {\n    delete ret[this.schema.options.versionKey];\n  }\n\n  var transform = options.transform;\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema\'s transform and\n  // not the parent schema\'s\n  if (transform === true ||\n      (this.schema.options.toObject && transform)) {\n    var opts = options.json ? this.schema.options.toJSON : this.schema.options.toObject;\n\n    if (opts) {\n      transform = (typeof options.transform === \'function\' ? options.transform : opts.transform);\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === \'function\') {\n    var xformed = transform(this, ret, options);\n    if (typeof xformed !== \'undefined\') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n}',
  '$hook': 'function (name, fn, errorCb) {\n    if (arguments.length === 1 && typeof name === \'object\') {\n      for (var k in name) { // `name` is a hash of hookName->hookFn\n        this.$hook(k, name[k]);\n      }\n      return;\n    }\n\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {}\n      , posts = proto._posts = proto._posts || {};\n    pres[name] = pres[name] || [];\n    posts[name] = posts[name] || [];\n\n    proto[name] = function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    };\n    \n    proto[name].numAsyncPres = 0;\n\n    return this;\n  }',
  '$__set': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  var shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts,\n    schema, val, priorVal);\n  var _this = this;\n\n  if (shouldModify) {\n    this.markModified(pathToMark, val);\n\n    // handle directly setting arrays (gh-1126)\n    MongooseArray || (MongooseArray = require(\'./types/array\'));\n    if (val && val.isMongooseArray) {\n      val._registerAtomic(\'$set\', val);\n\n      // Update embedded document parent references (gh-5189)\n      if (val.isMongooseDocumentArray) {\n        val.forEach(function(item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      }\n\n      // Small hack for gh-1638: if we\'re overwriting the entire array, ignore\n      // paths that were modified before the array overwrite\n      this.$__.activePaths.forEach(function(modifiedPath) {\n        if (modifiedPath.indexOf(path + \'.\') === 0) {\n          _this.$__.activePaths.ignore(modifiedPath);\n        }\n      });\n    }\n  }\n\n  var obj = this._doc;\n  var i = 0;\n  var l = parts.length;\n  var cur = \'\';\n\n  for (; i < l; i++) {\n    var next = i + 1;\n    var last = next === l;\n    cur += (cur ? \'.\' + parts[i] : parts[i]);\n\n    if (last) {\n      obj[parts[i]] = val;\n    } else {\n      if (obj[parts[i]] && utils.getFunctionName(obj[parts[i]].constructor) === \'Object\') {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        this.set(cur, {});\n        obj = obj[parts[i]];\n      }\n    }\n  }\n}',
  name: '1111',
  isNew: 'false',
  unmarkModified: 'function (path) {\n  this.$__.activePaths.init(path);\n}',
  validateSync: 'function (pathsToValidate) {\n  var _this = this;\n\n  if (typeof pathsToValidate === \'string\') {\n    pathsToValidate = pathsToValidate.split(\' \');\n  }\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (pathsToValidate && pathsToValidate.length) {\n    var tmp = [];\n    for (var i = 0; i < paths.length; ++i) {\n      if (pathsToValidate.indexOf(paths[i]) !== -1) {\n        tmp.push(paths[i]);\n      }\n    }\n    paths = tmp;\n  }\n\n  var validating = {};\n\n  paths.forEach(function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n\n    var p = _this.schema.path(path);\n    if (!p) {\n      return;\n    }\n    if (!_this.$isValid(path)) {\n      return;\n    }\n\n    var val = _this.getValue(path);\n    var err = p.doValidateSync(val, _this);\n    if (err) {\n      _this.invalidate(path, err, undefined, true);\n    }\n  });\n\n  var err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n  _this.emit(\'validate\', _this);\n  _this.constructor.emit(\'validate\', _this);\n\n  if (err) {\n    for (var key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n}',
  invalidate: 'function (path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === \'string\') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || \'user defined\',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.errors[path] = err;\n  return this.$__.validationError;\n}',
  execPopulate: 'function () {\n  var Promise = PromiseProvider.get();\n  var _this = this;\n  return new Promise.ES6(function(resolve, reject) {\n    _this.populate(function(error, res) {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(res);\n      }\n    });\n  });\n}',
  isSelected: 'function isSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    i = paths.length;\n    var pathDot = path + \'.\';\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n\n      if (cur.indexOf(pathDot) === 0) {\n        return inclusive || cur !== pathDot;\n      }\n\n      if (pathDot.indexOf(cur + \'.\') === 0) {\n        return inclusive;\n      }\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  toString: 'function () {\n  return inspect(this.inspect());\n}',
  toJSON: 'function (options) {\n  return this.$toObject(options, true);\n}',
  '$__handleReject': 'function handleReject(err) {\n  // emit on the Model if listening\n  if (this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  } else if (this.constructor.listeners && this.constructor.listeners(\'error\').length) {\n    this.constructor.emit(\'error\', err);\n  } else if (this.listeners && this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  }\n}' }
[2017-05-04 16:14:57.275] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:14:57.287] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:14:57.291] [INFO] app - Redis client default is ready {}
[2017-05-04 16:14:57.483] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:14:58.105] [DEBUG] app - 2017-5-4 16:14:58 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:14:58.111] [WARN] console - this is a logger middleware.
[2017-05-04 16:14:58.132] [WARN] console - { setValue: 'function (path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n}',
  '$__where': 'function _where(where) {\n  where || (where = {});\n\n  var paths,\n      len;\n\n  if (!where._id) {\n    where._id = this._doc._id;\n  }\n\n  if (this.$__.shardval) {\n    paths = Object.keys(this.$__.shardval);\n    len = paths.length;\n\n    for (var i = 0; i < len; ++i) {\n      where[paths[i]] = this.$__.shardval[paths[i]];\n    }\n  }\n\n  if (this._doc._id == null) {\n    return new Error(\'No _id found on document!\');\n  }\n\n  return where;\n}',
  _doc: '[object Object]',
  _id: '5902b753c5756d72945d90b3',
  '$post': 'function (name, isAsync, fn) {\n    if (arguments.length === 2) {\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , posts = proto._posts = proto._posts || {};\n    \n    this._lazySetupHooks(proto, name);\n    (posts[name] = posts[name] || []).push(fn);\n    return this;\n  }',
  getValue: 'function (path) {\n  return utils.getValue(path, this._doc);\n}',
  '$__handleSave': 'function (options, callback) {\n  var _this = this;\n  var i;\n  var keys;\n  var len;\n  if (!options.safe && this.schema.options.safe) {\n    options.safe = this.schema.options.safe;\n  }\n  if (typeof options.safe === \'boolean\') {\n    options.safe = null;\n  }\n\n  if (this.isNew) {\n    // send entire doc\n    var toObjectOptions = {};\n\n    toObjectOptions.retainKeyOrder = this.schema.options.retainKeyOrder;\n    toObjectOptions.depopulate = 1;\n    toObjectOptions._skipDepopulateTopLevel = true;\n    toObjectOptions.transform = false;\n    toObjectOptions.flattenDecimals = false;\n\n    var obj = this.toObject(toObjectOptions);\n\n    if (!utils.object.hasOwnProperty(obj || {}, \'_id\')) {\n      // documents must have an _id else mongoose won\'t know\n      // what to update later if more changes are made. the user\n      // wouldn\'t know what _id was generated by mongodb either\n      // nor would the ObjectId generated my mongodb necessarily\n      // match the schema definition.\n      setTimeout(function() {\n        callback(new Error(\'document must have an _id before saving\'));\n      }, 0);\n      return;\n    }\n\n    this.$__version(true, obj);\n    this.collection.insert(obj, options.safe, function(err, ret) {\n      if (err) {\n        _this.isNew = true;\n        _this.emit(\'isNew\', true);\n        _this.constructor.emit(\'isNew\', true);\n\n        callback(err);\n        return;\n      }\n\n      callback(null, ret);\n    });\n    this.$__reset();\n    this.isNew = false;\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n    // Make it possible to retry the insert\n    this.$__.inserting = true;\n  } else {\n    // Make sure we don\'t treat it as a new object on error,\n    // since it already exists\n    this.$__.inserting = false;\n\n    var delta = this.$__delta();\n\n    if (delta) {\n      if (delta instanceof Error) {\n        callback(delta);\n        return;\n      }\n\n      var where = this.$__where(delta[0]);\n      if (where instanceof Error) {\n        callback(where);\n        return;\n      }\n\n      if (this.$where) {\n        keys = Object.keys(this.$where);\n        len = keys.length;\n        for (i = 0; i < len; ++i) {\n          where[keys[i]] = this.$where[keys[i]];\n        }\n      }\n\n      this.collection.update(where, delta[1], options.safe, function(err, ret) {\n        if (err) {\n          callback(err);\n          return;\n        }\n        ret.$where = where;\n        callback(null, ret);\n      });\n    } else {\n      this.$__reset();\n      callback();\n      return;\n    }\n\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n  }\n}',
  '$__buildDoc': 'function (obj, fields, skipId) {\n  var doc = {};\n  var exclude = null;\n  var keys;\n  var ki;\n  var _this = this;\n\n  // determine if this doc is a result of a query with\n  // excluded fields\n\n  if (fields && utils.getFunctionName(fields.constructor) === \'Object\') {\n    keys = Object.keys(fields);\n    ki = keys.length;\n\n    if (ki === 1 && keys[0] === \'_id\') {\n      exclude = !!fields[keys[ki]];\n    } else {\n      while (ki--) {\n        if (keys[ki] !== \'_id\' &&\n            (!fields[keys[ki]] || typeof fields[keys[ki]] !== \'object\')) {\n          exclude = !fields[keys[ki]];\n          break;\n        }\n      }\n    }\n  }\n\n  var paths = Object.keys(this.schema.paths);\n  var plen = paths.length;\n  var ii = 0;\n\n  var hasIncludedChildren = {};\n  if (exclude === false && fields) {\n    keys = Object.keys(fields);\n    for (var j = 0; j < keys.length; ++j) {\n      var parts = keys[j].split(\'.\');\n      var c = [];\n      for (var k = 0; k < parts.length; ++k) {\n        c.push(parts[k]);\n        hasIncludedChildren[c.join(\'.\')] = 1;\n      }\n    }\n  }\n\n  for (; ii < plen; ++ii) {\n    var p = paths[ii];\n\n    if (p === \'_id\') {\n      if (skipId) {\n        continue;\n      }\n      if (obj && \'_id\' in obj) {\n        continue;\n      }\n    }\n\n    var type = this.schema.paths[p];\n    var path = p.split(\'.\');\n    var len = path.length;\n    var last = len - 1;\n    var curPath = \'\';\n    var doc_ = doc;\n    var i = 0;\n    var included = false;\n\n    for (; i < len; ++i) {\n      var piece = path[i],\n          def;\n\n      curPath += (!curPath.length ? \'\' : \'.\') + piece;\n\n      // support excluding intermediary levels\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i === last) {\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          } else if (included) {\n            // selected field\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          }\n        } else {\n          def = type.getDefault(_this, false);\n          if (typeof def !== \'undefined\') {\n            doc_[piece] = def;\n            _this.$__.activePaths.default(p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  return doc;\n}',
  '$ignore': 'function (path) {\n  this.$__.activePaths.ignore(path);\n}',
  removePre: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , pres = proto._pres || (proto._pres || {});\n    if (!pres[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all pre callbacks for hook `name`\n      pres[name].length = 0;\n    } else {\n      pres[name] = pres[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  collection: '[object Object]',
  emit: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  createdAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  '$__version': 'function (where, delta) {\n  var key = this.schema.options.versionKey;\n\n  if (where === true) {\n    // this is an insert\n    if (key) this.setValue(key, delta[key] = 0);\n    return;\n  }\n\n  // updates\n\n  // only apply versioning if our versionKey was selected. else\n  // there is no way to select the correct version. we could fail\n  // fast here and force them to include the versionKey but\n  // thats a bit intrusive. can we do this automatically?\n  if (!this.isSelected(key)) {\n    return;\n  }\n\n  // $push $addToSet don\'t need the where clause set\n  if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {\n    where[key] = this.getValue(key);\n  }\n\n  if (VERSION_INC === (VERSION_INC & this.$__.version)) {\n    if (!delta.$set || typeof delta.$set[key] === \'undefined\') {\n      delta.$inc || (delta.$inc = {});\n      delta.$inc[key] = 1;\n    }\n  }\n}',
  '$isMongooseModelPrototype': 'true',
  set: 'function (path, val, type, options) {\n  if (type && utils.getFunctionName(type.constructor) === \'Object\') {\n    options = type;\n    type = undefined;\n  }\n\n  var merge = options && options.merge,\n      adhoc = type && type !== true,\n      constructing = type === true,\n      adhocs;\n\n  var strict = options && \'strict\' in options\n      ? options.strict\n      : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  if (typeof path !== \'string\') {\n    // new Document({ key: val })\n\n    if (path === null || path === void 0) {\n      var _ = path;\n      path = val;\n      val = _;\n    } else {\n      var prefix = val\n          ? val + \'.\'\n          : \'\';\n\n      if (path instanceof Document) {\n        if (path.$__isNested) {\n          path = path.toObject();\n        } else {\n          path = path._doc;\n        }\n      }\n\n      var keys = Object.keys(path);\n      var len = keys.length;\n      var i = 0;\n      var pathtype;\n      var key;\n\n      if (len === 0 && !this.schema.options.minimize) {\n        if (val) {\n          this.set(val, {});\n        }\n        return this;\n      }\n\n      if (this.schema.options.retainKeyOrder) {\n        while (i < len) {\n          _handleIndex.call(this, i++);\n        }\n      } else {\n        while (len--) {\n          _handleIndex.call(this, len);\n        }\n      }\n\n      return this;\n    }\n  }\n\n  function _handleIndex(i) {\n    key = keys[i];\n    var pathName = prefix + key;\n    pathtype = this.schema.pathType(pathName);\n\n    if (path[key] !== null\n        && path[key] !== void 0\n          // need to know if plain object - no Buffer, ObjectId, ref, etc\n        && utils.isObject(path[key])\n        && (!path[key].constructor || utils.getFunctionName(path[key].constructor) === \'Object\')\n        && pathtype !== \'virtual\'\n        && pathtype !== \'real\'\n        && !(this.$__path(pathName) instanceof MixedSchema)\n        && !(this.schema.paths[pathName] &&\n        this.schema.paths[pathName].options &&\n        this.schema.paths[pathName].options.ref)) {\n      this.set(path[key], prefix + key, constructing);\n    } else if (strict) {\n      // Don\'t overwrite defaults with undefined keys (gh-3981)\n      if (constructing && path[key] === void 0 &&\n          this.get(key) !== void 0) {\n        return;\n      }\n\n      if (pathtype === \'real\' || pathtype === \'virtual\') {\n        // Check for setting single embedded schema to document (gh-3535)\n        var p = path[key];\n        if (this.schema.paths[pathName] &&\n            this.schema.paths[pathName].$isSingleNested &&\n            path[key] instanceof Document) {\n          p = p.toObject({ virtuals: false, transform: false });\n        }\n        this.set(prefix + key, p, constructing);\n      } else if (pathtype === \'nested\' && path[key] instanceof Document) {\n        this.set(prefix + key,\n            path[key].toObject({transform: false}), constructing);\n      } else if (strict === \'throw\') {\n        if (pathtype === \'nested\') {\n          throw new ObjectExpectedError(key, path[key]);\n        } else {\n          throw new StrictModeError(key);\n        }\n      }\n    } else if (path[key] !== void 0) {\n      this.set(prefix + key, path[key], constructing);\n    }\n  }\n\n  var pathType = this.schema.pathType(path);\n  if (pathType === \'nested\' && val) {\n    if (utils.isObject(val) &&\n        (!val.constructor || utils.getFunctionName(val.constructor) === \'Object\')) {\n      if (!merge) {\n        this.setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      }\n\n      if (Object.keys(val).length === 0) {\n        this.setValue(path, {});\n        this.markModified(path);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        this.set(val, path, constructing);\n      }\n      return this;\n    }\n    this.invalidate(path, new MongooseError.CastError(\'Object\', val, path));\n    return this;\n  }\n\n  var schema;\n  var parts = path.split(\'.\');\n\n  if (pathType === \'adhocOrUndefined\' && strict) {\n    // check for roots that are Mixed types\n    var mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      var subpath = parts.slice(0, i + 1).join(\'.\');\n      schema = this.schema.path(subpath);\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n\n      // If path is underneath a virtual, bypass everything and just set it.\n      if (i + 1 < parts.length && this.schema.pathType(subpath) === \'virtual\') {\n        mpath.set(path, val, this);\n        return this;\n      }\n    }\n\n    if (!mixed) {\n      if (strict === \'throw\') {\n        throw new StrictModeError(path);\n      }\n      return this;\n    }\n  } else if (pathType === \'virtual\') {\n    schema = this.schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  var pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: "LEFT_SUBFIELD only supports Object"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    for (i = 0; i < parts.length; ++i) {\n      subpath = parts.slice(0, i + 1).join(\'.\');\n      if (this.isDirectModified(subpath) // earlier prefixes that are already\n            // marked as dirty have precedence\n          || this.get(subpath) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n\n  // if this doc is being constructed we should not trigger getters\n  var priorVal = constructing\n      ? undefined\n      : this.getValue(path);\n\n  if (!schema) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n    return this;\n  }\n\n  var shouldSet = true;\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    var didPopulate = false;\n    if (schema.options &&\n        schema.options.ref &&\n        val instanceof Document &&\n        (schema.options.ref === val.constructor.modelName || schema.options.ref === val.constructor.baseModelName)) {\n      if (this.ownerDocument) {\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val._id, {model: val.constructor});\n      } else {\n        this.populated(path, val._id, {model: val.constructor});\n      }\n      didPopulate = true;\n    }\n\n    var popOpts;\n    if (schema.options &&\n        Array.isArray(schema.options.type) &&\n        schema.options.type.length &&\n        schema.options.type[0].ref &&\n        Array.isArray(val) &&\n        val.length > 0 &&\n        val[0] instanceof Document &&\n        val[0].constructor.modelName &&\n        (schema.options.type[0].ref === val[0].constructor.baseModelName || schema.options.type[0].ref === val[0].constructor.modelName)) {\n      if (this.ownerDocument) {\n        popOpts = { model: val[0].constructor };\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val.map(function(v) { return v._id; }), popOpts);\n      } else {\n        popOpts = { model: val[0].constructor };\n        this.populated(path, val.map(function(v) { return v._id; }), popOpts);\n      }\n      didPopulate = true;\n    }\n    val = schema.applySetters(val, this, false, priorVal);\n\n    if (!didPopulate && this.$__.populated) {\n      delete this.$__.populated[path];\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    this.invalidate(path,\n      new MongooseError.CastError(schema.instance, val, path, e));\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n}',
  modifiedPaths: 'function () {\n  var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n  return directModifiedPaths.reduce(function(list, path) {\n    var parts = path.split(\'.\');\n    return list.concat(parts.reduce(function(chains, part, i) {\n      return chains.concat(parts.slice(0, i).concat(part).join(\'.\'));\n    }, []).filter(function(chain) {\n      return (list.indexOf(chain) === -1);\n    }));\n  }, []);\n}',
  get: 'function (path, type) {\n  var adhoc;\n  if (type) {\n    adhoc = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  var schema = this.$__path(path) || this.schema.virtualpath(path),\n      pieces = path.split(\'.\'),\n      obj = this._doc;\n\n  for (var i = 0, l = pieces.length; i < l; i++) {\n    obj = obj === null || obj === void 0\n        ? undefined\n        : obj[pieces[i]];\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  // Check if this path is populated - don\'t apply getters if it is,\n  // because otherwise its a nested object. See gh-3357\n  if (schema && !this.populated(path)) {\n    obj = schema.applyGetters(obj, this);\n  }\n\n  return obj;\n}',
  updatedAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  '$__path': 'function (path) {\n  var adhocs = this.$__.adhocPaths,\n      adhocType = adhocs && adhocs[path];\n\n  if (adhocType) {\n    return adhocType;\n  }\n  return this.schema.path(path);\n}',
  '$__save': 'function (options, callback) {\n  var _this = this;\n\n  _this.$__handleSave(options, function(error, result) {\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.$__reset();\n    _this.$__storeShard();\n\n    var numAffected = 0;\n    if (result) {\n      if (Array.isArray(result)) {\n        numAffected = result.length;\n      } else if (result.result && result.result.n !== undefined) {\n        numAffected = result.result.n;\n      } else if (result.result && result.result.nModified !== undefined) {\n        numAffected = result.result.nModified;\n      } else {\n        numAffected = result;\n      }\n    }\n\n    // was this an update that required a version bump?\n    if (_this.$__.version && !_this.$__.inserting) {\n      var doIncrement = VERSION_INC === (VERSION_INC & _this.$__.version);\n      _this.$__.version = undefined;\n\n      if (numAffected <= 0) {\n        // the update failed. pass an error back\n        var err = new VersionError(_this);\n        return callback(err);\n      }\n\n      // increment version if was successful\n      if (doIncrement) {\n        var key = _this.schema.options.versionKey;\n        var version = _this.getValue(key) | 0;\n        _this.setValue(key, version + 1);\n      }\n    }\n\n    if (_this.schema.options &&\n        _this.schema.options.saveErrorIfNotFound &&\n        numAffected <= 0) {\n      error = new DocumentNotFoundError(result.$where);\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.emit(\'save\', _this, numAffected);\n    _this.constructor.emit(\'save\', _this, numAffected);\n    callback(null, _this, numAffected);\n  });\n}',
  '$__delta': 'function () {\n  var dirty = this.$__dirty();\n  if (!dirty.length && VERSION_ALL !== this.$__.version) return;\n\n  var where = {},\n      delta = {},\n      len = dirty.length,\n      divergent = [],\n      d = 0;\n\n  where._id = this._doc._id;\n  if (where._id.toObject) {\n    where._id = where._id.toObject({ transform: false, depopulate: true });\n  }\n\n  for (; d < len; ++d) {\n    var data = dirty[d];\n    var value = data.value;\n\n    var match = checkDivergentArray(this, data.path, value);\n    if (match) {\n      divergent.push(match);\n      continue;\n    }\n\n    var pop = this.populated(data.path, true);\n    if (!pop && this.$__.selected) {\n      // If any array was selected using an $elemMatch projection, we alter the path and where clause\n      // NOTE: MongoDB only supports projected $elemMatch on top level array.\n      var pathSplit = data.path.split(\'.\');\n      var top = pathSplit[0];\n      if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {\n        // If the selected array entry was modified\n        if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === \'undefined\') {\n          where[top] = this.$__.selected[top];\n          pathSplit[1] = \'$\';\n          data.path = pathSplit.join(\'.\');\n        }\n        // if the selected array was modified in any other way throw an error\n        else {\n          divergent.push(data.path);\n          continue;\n        }\n      }\n    }\n\n    if (divergent.length) continue;\n\n    if (undefined === value) {\n      operand(this, where, delta, data, 1, \'$unset\');\n    } else if (value === null) {\n      operand(this, where, delta, data, null);\n    } else if (value._path && value._atomics) {\n      // arrays and other custom types (support plugins etc)\n      handleAtomics(this, where, delta, data, value);\n    } else if (value._path && Buffer.isBuffer(value)) {\n      // MongooseBuffer\n      value = value.toObject();\n      operand(this, where, delta, data, value);\n    } else {\n      value = utils.clone(value, {depopulate: 1, _isNested: true});\n      operand(this, where, delta, data, value);\n    }\n  }\n\n  if (divergent.length) {\n    return new DivergentArrayError(divergent);\n  }\n\n  if (this.$__.version) {\n    this.$__version(where, delta);\n  }\n\n  return [where, delta];\n}',
  '$__storeShard': 'function () {\n  // backwards compat\n  var key = this.schema.options.shardKey || this.schema.options.shardkey;\n  if (!(key && utils.getFunctionName(key.constructor) === \'Object\')) {\n    return;\n  }\n\n  var orig = this.$__.shardval = {},\n      paths = Object.keys(key),\n      len = paths.length,\n      val;\n\n  for (var i = 0; i < len; ++i) {\n    val = this.getValue(paths[i]);\n    if (isMongooseObject(val)) {\n      orig[paths[i]] = val.toObject({depopulate: true, _isNested: true});\n    } else if (val !== null && val !== undefined && val.valueOf &&\n          // Explicitly don\'t take value of dates\n        (!val.constructor || utils.getFunctionName(val.constructor) !== \'Date\')) {\n      orig[paths[i]] = val.valueOf();\n    } else {\n      orig[paths[i]] = val;\n    }\n  }\n}',
  listeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  depopulate: 'function (path) {\n  var populatedIds = this.populated(path);\n  if (!populatedIds) {\n    return;\n  }\n  delete this.$__.populated[path];\n  this.set(path, populatedIds);\n  return this;\n}',
  equals: 'function (doc) {\n  if (!doc) {\n    return false;\n  }\n\n  var tid = this.get(\'_id\');\n  var docid = doc.get ? doc.get(\'_id\') : doc;\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals\n      ? tid.equals(docid)\n      : tid === docid;\n}',
  _posts: '[object Object]',
  '$__getAllSubdocs': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  function docReducer(seed, path) {\n    var val = this[path];\n\n    if (val instanceof Embedded) {\n      seed.push(val);\n    }\n    if (val && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(docReducer.bind(val._doc), seed);\n      seed.push(val);\n    }\n    if (val && val.isMongooseDocumentArray) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n        seed = Object.keys(doc._doc).reduce(docReducer.bind(doc._doc), seed);\n      });\n    } else if (val instanceof Document && val.$__isNested) {\n      if (val) {\n        seed = Object.keys(val).reduce(docReducer.bind(val), seed);\n      }\n    }\n    return seed;\n  }\n\n  var subDocs = Object.keys(this._doc).reduce(docReducer.bind(this), []);\n\n  return subDocs;\n}',
  '$__original_save': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  removeListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  '$__getArrayPathsToValidate': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  // validate all document arrays.\n  return this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return this.getValue(i);\n  }.bind(this))\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  }).reduce(function(seed, array) {\n    return seed.concat(array);\n  }, [])\n  .filter(function(doc) {\n    return doc;\n  });\n}',
  schema: '[object Object]',
  removeAllListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  save: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  isDirectSelected: 'function isDirectSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  removePost: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , posts = proto._posts || (proto._posts || {});\n    if (!posts[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all post callbacks for hook `name`\n      posts[name].length = 0;\n    } else {\n      posts[name] = posts[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  _lazySetupHooks: 'function (proto, methodName, errorCb) {\n    if (\'undefined\' === typeof proto[methodName].numAsyncPres) {\n      this.$hook(methodName, proto[methodName], errorCb);\n    }\n  }',
  toBSON: 'function () {\n  return this.toObject({\n    transform: false,\n    virtuals: false,\n    _skipDepopulateTopLevel: true,\n    depopulate: true,\n    flattenDecimals: false\n  });\n}',
  markModified: 'function (path) {\n  this.$__.activePaths.modify(path);\n}',
  on: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  increment: 'function increment() {\n  this.$__.version = VERSION_ALL;\n  return this;\n}',
  validate: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populated: 'function (path, val, options) {\n  // val and options are internal\n\n  if (val === null || val === void 0) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    var v = this.$__.populated[path];\n    if (v) {\n      return v.value;\n    }\n    return undefined;\n  }\n\n  // internal\n\n  if (val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    return this.$__.populated[path];\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = {value: val, options: options};\n  return val;\n}',
  update: 'function update() {\n  var args = utils.args(arguments);\n  args.unshift({_id: this._id});\n  return this.constructor.update.apply(this.constructor, args);\n}',
  id: '5902b753c5756d72945d90b3',
  '$__setSchema': 'function (schema) {\n  compile(schema.tree, this, undefined, schema.options);\n  this.schema = schema;\n}',
  isInit: 'function (path) {\n  return (path in this.$__.activePaths.states.init);\n}',
  '$__validate': 'function (callback) {\n  var _this = this;\n  var _complete = function() {\n    var err = _this.$__.validationError;\n    _this.$__.validationError = undefined;\n    _this.emit(\'validate\', _this);\n    _this.constructor.emit(\'validate\', _this);\n    if (err) {\n      for (var key in err.errors) {\n        // Make sure cast errors persist\n        if (!_this.__parent && err.errors[key] instanceof MongooseError.CastError) {\n          _this.invalidate(key, err.errors[key]);\n        }\n      }\n\n      return err;\n    }\n  };\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (paths.length === 0) {\n    process.nextTick(function() {\n      var error = _complete();\n      if (error) {\n        return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n          callback(error);\n        });\n      }\n      callback();\n    });\n  }\n\n  var validating = {},\n      total = 0;\n\n  var complete = function() {\n    var error = _complete();\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n    callback();\n  };\n\n  var validatePath = function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n    total++;\n\n    process.nextTick(function() {\n      var p = _this.schema.path(path);\n      if (!p) {\n        return --total || complete();\n      }\n\n      // If user marked as invalid or there was a cast error, don\'t validate\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      var val = _this.getValue(path);\n      p.doValidate(val, function(err) {\n        if (err) {\n          _this.invalidate(path, err, undefined, true);\n        }\n        --total || complete();\n      }, _this);\n    });\n  };\n\n  paths.forEach(validatePath);\n}',
  db: '[object Object]',
  username: '222',
  '$__original_validate': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  discriminators: 'undefined',
  isModified: 'function (paths) {\n  if (paths) {\n    if (!Array.isArray(paths)) {\n      paths = paths.split(\' \');\n    }\n    var modified = this.modifiedPaths();\n    var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n    var isModifiedChild = paths.some(function(path) {\n      return !!~modified.indexOf(path);\n    });\n    return isModifiedChild || paths.some(function(path) {\n      return directModifiedPaths.some(function(mod) {\n        return mod === path || path.indexOf(mod + \'.\') === 0;\n      });\n    });\n  }\n  return this.$__.activePaths.some(\'modify\');\n}',
  '$pre': 'function (name, isAsync, fn, errorCb) {\n    if (\'boolean\' !== typeof arguments[1]) {\n      errorCb = fn;\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {};\n\n    this._lazySetupHooks(proto, name, errorCb);\n\n    if (fn.isAsync = isAsync) {\n      proto[name].numAsyncPres++;\n    }\n\n    (pres[name] = pres[name] || []).push(fn);\n    return this;\n  }',
  toObject: 'function (options) {\n  return this.$toObject(options);\n}',
  '$markValid': 'function (path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n}',
  '$isValid': 'function (path) {\n  return !this.$__.validationError || !this.$__.validationError.errors[path];\n}',
  isDirectModified: 'function (path) {\n  return (path in this.$__.activePaths.states.modify);\n}',
  '$__dirty': 'function () {\n  var _this = this;\n\n  var all = this.$__.activePaths.map(\'modify\', function(path) {\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  });\n\n  // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n  all = all.concat(this.$__.activePaths.map(\'default\', function(path) {\n    if (path === \'_id\' || !_this.getValue(path)) {\n      return;\n    }\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n\n  // Sort dirty paths in a flat hierarchy.\n  all.sort(function(a, b) {\n    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));\n  });\n\n  // Ignore "foo.a" if "foo" is dirty already.\n  var minimal = [],\n      lastPath,\n      top;\n\n  all.forEach(function(item) {\n    if (!item) {\n      return;\n    }\n    if (item.path.indexOf(lastPath) !== 0) {\n      lastPath = item.path + \'.\';\n      minimal.push(item);\n      top = item;\n    } else {\n      // special case for top level MongooseArrays\n      if (top.value && top.value._atomics && top.value.hasAtomics()) {\n        // the `top` array itself and a sub path of `top` are being modified.\n        // the only way to honor all of both modifications is through a $set\n        // of entire array.\n        top.value._atomics = {};\n        top.value._atomics.$set = top.value;\n      }\n    }\n  });\n\n  top = lastPath = null;\n  return minimal;\n}',
  model: 'function model(name) {\n  return this.db.model(name);\n}',
  '$isDefault': 'function (path) {\n  return (path in this.$__.activePaths.states.default);\n}',
  '$__original_remove': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  remove: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populate: 'function populate() {\n  if (arguments.length === 0) {\n    return this;\n  }\n\n  var pop = this.$__.populate || (this.$__.populate = {});\n  var args = utils.args(arguments);\n  var fn;\n\n  if (typeof args[args.length - 1] === \'function\') {\n    fn = args.pop();\n  }\n\n  // allow `doc.populate(callback)`\n  if (args.length) {\n    // use hash to remove duplicate paths\n    var res = utils.populate.apply(null, args);\n    for (var i = 0; i < res.length; ++i) {\n      pop[res[i].path] = res[i];\n    }\n  }\n\n  if (fn) {\n    var paths = utils.object.vals(pop);\n    this.$__.populate = undefined;\n    paths.__noPromise = true;\n    this.constructor.populate(this, paths, fn);\n  }\n\n  return this;\n}',
  '$__shouldModify': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  if (this.isNew) {\n    return true;\n  }\n\n  if (undefined === val && !this.isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (undefined === val && path in this.$__.activePaths.states.default) {\n    // we\'re just unsetting the default value which was never saved\n    return false;\n  }\n\n  // gh-3992: if setting a populated field to a doc, don\'t mark modified\n  // if they have the same _id\n  if (this.populated(path) &&\n      val instanceof Document &&\n      deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal || this.get(path))) {\n    return true;\n  }\n\n  if (!constructing &&\n      val !== null &&\n      val !== undefined &&\n      path in this.$__.activePaths.states.default &&\n      deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n  return false;\n}',
  '$__': '[object Object]',
  '$__fullPath': 'function (path) {\n  // overridden in SubDocuments\n  return path || \'\';\n}',
  _pres: '[object Object]',
  inspect: 'function (options) {\n  var isPOJO = options &&\n    utils.getFunctionName(options.constructor) === \'Object\';\n  var opts;\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n    opts.retainKeyOrder = true;\n  }\n  return this.toObject(opts);\n}',
  '$__reset': 'function reset() {\n  var _this = this;\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return _this.getValue(i);\n  })\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  })\n  .forEach(function(array) {\n    var i = array.length;\n    while (i--) {\n      var doc = array[i];\n      if (!doc) {\n        continue;\n      }\n      doc.$__reset();\n    }\n  });\n\n  // clear atomics\n  this.$__dirty().forEach(function(dirt) {\n    var type = dirt.value;\n    if (type && type._atomics) {\n      type._atomics = {};\n    }\n  });\n\n  // Clear \'dirty\' cache\n  this.$__.activePaths.clear(\'modify\');\n  this.$__.activePaths.clear(\'default\');\n  this.$__.validationError = undefined;\n  this.errors = undefined;\n  _this = this;\n  this.schema.requiredPaths().forEach(function(path) {\n    _this.$__.activePaths.require(path);\n  });\n\n  return this;\n}',
  init: 'function (doc, opts, fn) {\n  // do not prefix this method with $__ since its\n  // used by public hooks\n\n  if (typeof opts === \'function\') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.isNew = false;\n\n  // handle docs with populated paths\n  // If doc._id is not null or undefined\n  if (doc._id !== null && doc._id !== undefined &&\n    opts && opts.populated && opts.populated.length) {\n    var id = String(doc._id);\n    for (var i = 0; i < opts.populated.length; ++i) {\n      var item = opts.populated[i];\n      if (item.isVirtual) {\n        this.populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.populated(item.path, item._docs[id], item);\n      }\n    }\n  }\n\n  init(this, doc, this._doc);\n  this.$__storeShard();\n\n  this.emit(\'init\', this);\n  this.constructor.emit(\'init\', this);\n\n  if (fn) {\n    fn(null);\n  }\n  return this;\n}',
  setMaxListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  initializeTimestamps: 'function () {\n      if (!this.get(createdAt)) {\n        this.set(createdAt, new Date());\n      }\n      if (!this.get(updatedAt)) {\n        this.set(updatedAt, new Date());\n      }\n      return this;\n    }',
  once: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  __v: '0',
  '$toObject': 'function (options, json) {\n  var defaultOptions = {\n    transform: true,\n    json: json,\n    retainKeyOrder: this.schema.options.retainKeyOrder,\n    flattenDecimals: true\n  };\n\n  // _isNested will only be true if this is not the top level document, we\n  // should never depopulate\n  if (options && options.depopulate && options._isNested && this.$__.wasPopulated) {\n    // populated paths that we set to a document\n    return clone(this._id, options);\n  }\n\n  // When internally saving this document we always pass options,\n  // bypassing the custom schema options.\n  if (!(options && utils.getFunctionName(options.constructor) === \'Object\') ||\n      (options && options._useSchemaOptions)) {\n    if (json) {\n      options = this.schema.options.toJSON ?\n        clone(this.schema.options.toJSON) :\n        {};\n      options.json = true;\n      options._useSchemaOptions = true;\n    } else {\n      options = this.schema.options.toObject ?\n        clone(this.schema.options.toObject) :\n        {};\n      options.json = false;\n      options._useSchemaOptions = true;\n    }\n  }\n\n  for (var key in defaultOptions) {\n    if (options[key] === undefined) {\n      options[key] = defaultOptions[key];\n    }\n  }\n\n  (\'minimize\' in options) || (options.minimize = this.schema.options.minimize);\n\n  // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n  var originalTransform = options.transform;\n\n  options._isNested = true;\n\n  var ret = clone(this._doc, options) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, \'paths\', options);\n    // applyGetters for paths will add nested empty objects;\n    // if minimize is set, we need to remove them.\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || options.getters && options.virtuals !== false) {\n    applyGetters(this, ret, \'virtuals\', options);\n  }\n\n  if (options.versionKey === false && this.schema.options.versionKey) {\n    delete ret[this.schema.options.versionKey];\n  }\n\n  var transform = options.transform;\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema\'s transform and\n  // not the parent schema\'s\n  if (transform === true ||\n      (this.schema.options.toObject && transform)) {\n    var opts = options.json ? this.schema.options.toJSON : this.schema.options.toObject;\n\n    if (opts) {\n      transform = (typeof options.transform === \'function\' ? options.transform : opts.transform);\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === \'function\') {\n    var xformed = transform(this, ret, options);\n    if (typeof xformed !== \'undefined\') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n}',
  '$hook': 'function (name, fn, errorCb) {\n    if (arguments.length === 1 && typeof name === \'object\') {\n      for (var k in name) { // `name` is a hash of hookName->hookFn\n        this.$hook(k, name[k]);\n      }\n      return;\n    }\n\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {}\n      , posts = proto._posts = proto._posts || {};\n    pres[name] = pres[name] || [];\n    posts[name] = posts[name] || [];\n\n    proto[name] = function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    };\n    \n    proto[name].numAsyncPres = 0;\n\n    return this;\n  }',
  '$__set': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  var shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts,\n    schema, val, priorVal);\n  var _this = this;\n\n  if (shouldModify) {\n    this.markModified(pathToMark, val);\n\n    // handle directly setting arrays (gh-1126)\n    MongooseArray || (MongooseArray = require(\'./types/array\'));\n    if (val && val.isMongooseArray) {\n      val._registerAtomic(\'$set\', val);\n\n      // Update embedded document parent references (gh-5189)\n      if (val.isMongooseDocumentArray) {\n        val.forEach(function(item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      }\n\n      // Small hack for gh-1638: if we\'re overwriting the entire array, ignore\n      // paths that were modified before the array overwrite\n      this.$__.activePaths.forEach(function(modifiedPath) {\n        if (modifiedPath.indexOf(path + \'.\') === 0) {\n          _this.$__.activePaths.ignore(modifiedPath);\n        }\n      });\n    }\n  }\n\n  var obj = this._doc;\n  var i = 0;\n  var l = parts.length;\n  var cur = \'\';\n\n  for (; i < l; i++) {\n    var next = i + 1;\n    var last = next === l;\n    cur += (cur ? \'.\' + parts[i] : parts[i]);\n\n    if (last) {\n      obj[parts[i]] = val;\n    } else {\n      if (obj[parts[i]] && utils.getFunctionName(obj[parts[i]].constructor) === \'Object\') {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        this.set(cur, {});\n        obj = obj[parts[i]];\n      }\n    }\n  }\n}',
  name: '111',
  isNew: 'false',
  unmarkModified: 'function (path) {\n  this.$__.activePaths.init(path);\n}',
  validateSync: 'function (pathsToValidate) {\n  var _this = this;\n\n  if (typeof pathsToValidate === \'string\') {\n    pathsToValidate = pathsToValidate.split(\' \');\n  }\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (pathsToValidate && pathsToValidate.length) {\n    var tmp = [];\n    for (var i = 0; i < paths.length; ++i) {\n      if (pathsToValidate.indexOf(paths[i]) !== -1) {\n        tmp.push(paths[i]);\n      }\n    }\n    paths = tmp;\n  }\n\n  var validating = {};\n\n  paths.forEach(function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n\n    var p = _this.schema.path(path);\n    if (!p) {\n      return;\n    }\n    if (!_this.$isValid(path)) {\n      return;\n    }\n\n    var val = _this.getValue(path);\n    var err = p.doValidateSync(val, _this);\n    if (err) {\n      _this.invalidate(path, err, undefined, true);\n    }\n  });\n\n  var err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n  _this.emit(\'validate\', _this);\n  _this.constructor.emit(\'validate\', _this);\n\n  if (err) {\n    for (var key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n}',
  errors: 'undefined',
  addListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  invalidate: 'function (path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === \'string\') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || \'user defined\',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.errors[path] = err;\n  return this.$__.validationError;\n}',
  execPopulate: 'function () {\n  var Promise = PromiseProvider.get();\n  var _this = this;\n  return new Promise.ES6(function(resolve, reject) {\n    _this.populate(function(error, res) {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(res);\n      }\n    });\n  });\n}',
  isSelected: 'function isSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    i = paths.length;\n    var pathDot = path + \'.\';\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n\n      if (cur.indexOf(pathDot) === 0) {\n        return inclusive || cur !== pathDot;\n      }\n\n      if (pathDot.indexOf(cur + \'.\') === 0) {\n        return inclusive;\n      }\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  toString: 'function () {\n  return inspect(this.inspect());\n}',
  toJSON: 'function (options) {\n  return this.$toObject(options, true);\n}',
  '$__handleReject': 'function handleReject(err) {\n  // emit on the Model if listening\n  if (this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  } else if (this.constructor.listeners && this.constructor.listeners(\'error\').length) {\n    this.constructor.emit(\'error\', err);\n  } else if (this.listeners && this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  }\n}' }
[2017-05-04 16:15:06.536] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:15:06.553] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:15:06.556] [INFO] app - Redis client default is ready {}
[2017-05-04 16:15:06.763] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:15:07.928] [DEBUG] app - 2017-5-4 16:15:07 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:15:07.931] [WARN] console - this is a logger middleware.
[2017-05-04 16:15:07.952] [WARN] console - { _doc: '[object Object]',
  _id: '5902b753c5756d72945d90b3',
  '$post': 'function (name, isAsync, fn) {\n    if (arguments.length === 2) {\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , posts = proto._posts = proto._posts || {};\n    \n    this._lazySetupHooks(proto, name);\n    (posts[name] = posts[name] || []).push(fn);\n    return this;\n  }',
  getValue: 'function (path) {\n  return utils.getValue(path, this._doc);\n}',
  '$__handleSave': 'function (options, callback) {\n  var _this = this;\n  var i;\n  var keys;\n  var len;\n  if (!options.safe && this.schema.options.safe) {\n    options.safe = this.schema.options.safe;\n  }\n  if (typeof options.safe === \'boolean\') {\n    options.safe = null;\n  }\n\n  if (this.isNew) {\n    // send entire doc\n    var toObjectOptions = {};\n\n    toObjectOptions.retainKeyOrder = this.schema.options.retainKeyOrder;\n    toObjectOptions.depopulate = 1;\n    toObjectOptions._skipDepopulateTopLevel = true;\n    toObjectOptions.transform = false;\n    toObjectOptions.flattenDecimals = false;\n\n    var obj = this.toObject(toObjectOptions);\n\n    if (!utils.object.hasOwnProperty(obj || {}, \'_id\')) {\n      // documents must have an _id else mongoose won\'t know\n      // what to update later if more changes are made. the user\n      // wouldn\'t know what _id was generated by mongodb either\n      // nor would the ObjectId generated my mongodb necessarily\n      // match the schema definition.\n      setTimeout(function() {\n        callback(new Error(\'document must have an _id before saving\'));\n      }, 0);\n      return;\n    }\n\n    this.$__version(true, obj);\n    this.collection.insert(obj, options.safe, function(err, ret) {\n      if (err) {\n        _this.isNew = true;\n        _this.emit(\'isNew\', true);\n        _this.constructor.emit(\'isNew\', true);\n\n        callback(err);\n        return;\n      }\n\n      callback(null, ret);\n    });\n    this.$__reset();\n    this.isNew = false;\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n    // Make it possible to retry the insert\n    this.$__.inserting = true;\n  } else {\n    // Make sure we don\'t treat it as a new object on error,\n    // since it already exists\n    this.$__.inserting = false;\n\n    var delta = this.$__delta();\n\n    if (delta) {\n      if (delta instanceof Error) {\n        callback(delta);\n        return;\n      }\n\n      var where = this.$__where(delta[0]);\n      if (where instanceof Error) {\n        callback(where);\n        return;\n      }\n\n      if (this.$where) {\n        keys = Object.keys(this.$where);\n        len = keys.length;\n        for (i = 0; i < len; ++i) {\n          where[keys[i]] = this.$where[keys[i]];\n        }\n      }\n\n      this.collection.update(where, delta[1], options.safe, function(err, ret) {\n        if (err) {\n          callback(err);\n          return;\n        }\n        ret.$where = where;\n        callback(null, ret);\n      });\n    } else {\n      this.$__reset();\n      callback();\n      return;\n    }\n\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n  }\n}',
  '$__buildDoc': 'function (obj, fields, skipId) {\n  var doc = {};\n  var exclude = null;\n  var keys;\n  var ki;\n  var _this = this;\n\n  // determine if this doc is a result of a query with\n  // excluded fields\n\n  if (fields && utils.getFunctionName(fields.constructor) === \'Object\') {\n    keys = Object.keys(fields);\n    ki = keys.length;\n\n    if (ki === 1 && keys[0] === \'_id\') {\n      exclude = !!fields[keys[ki]];\n    } else {\n      while (ki--) {\n        if (keys[ki] !== \'_id\' &&\n            (!fields[keys[ki]] || typeof fields[keys[ki]] !== \'object\')) {\n          exclude = !fields[keys[ki]];\n          break;\n        }\n      }\n    }\n  }\n\n  var paths = Object.keys(this.schema.paths);\n  var plen = paths.length;\n  var ii = 0;\n\n  var hasIncludedChildren = {};\n  if (exclude === false && fields) {\n    keys = Object.keys(fields);\n    for (var j = 0; j < keys.length; ++j) {\n      var parts = keys[j].split(\'.\');\n      var c = [];\n      for (var k = 0; k < parts.length; ++k) {\n        c.push(parts[k]);\n        hasIncludedChildren[c.join(\'.\')] = 1;\n      }\n    }\n  }\n\n  for (; ii < plen; ++ii) {\n    var p = paths[ii];\n\n    if (p === \'_id\') {\n      if (skipId) {\n        continue;\n      }\n      if (obj && \'_id\' in obj) {\n        continue;\n      }\n    }\n\n    var type = this.schema.paths[p];\n    var path = p.split(\'.\');\n    var len = path.length;\n    var last = len - 1;\n    var curPath = \'\';\n    var doc_ = doc;\n    var i = 0;\n    var included = false;\n\n    for (; i < len; ++i) {\n      var piece = path[i],\n          def;\n\n      curPath += (!curPath.length ? \'\' : \'.\') + piece;\n\n      // support excluding intermediary levels\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i === last) {\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          } else if (included) {\n            // selected field\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          }\n        } else {\n          def = type.getDefault(_this, false);\n          if (typeof def !== \'undefined\') {\n            doc_[piece] = def;\n            _this.$__.activePaths.default(p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  return doc;\n}',
  '$ignore': 'function (path) {\n  this.$__.activePaths.ignore(path);\n}',
  removePre: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , pres = proto._pres || (proto._pres || {});\n    if (!pres[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all pre callbacks for hook `name`\n      pres[name].length = 0;\n    } else {\n      pres[name] = pres[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  collection: '[object Object]',
  emit: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  createdAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  '$__version': 'function (where, delta) {\n  var key = this.schema.options.versionKey;\n\n  if (where === true) {\n    // this is an insert\n    if (key) this.setValue(key, delta[key] = 0);\n    return;\n  }\n\n  // updates\n\n  // only apply versioning if our versionKey was selected. else\n  // there is no way to select the correct version. we could fail\n  // fast here and force them to include the versionKey but\n  // thats a bit intrusive. can we do this automatically?\n  if (!this.isSelected(key)) {\n    return;\n  }\n\n  // $push $addToSet don\'t need the where clause set\n  if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {\n    where[key] = this.getValue(key);\n  }\n\n  if (VERSION_INC === (VERSION_INC & this.$__.version)) {\n    if (!delta.$set || typeof delta.$set[key] === \'undefined\') {\n      delta.$inc || (delta.$inc = {});\n      delta.$inc[key] = 1;\n    }\n  }\n}',
  '$isMongooseModelPrototype': 'true',
  set: 'function (path, val, type, options) {\n  if (type && utils.getFunctionName(type.constructor) === \'Object\') {\n    options = type;\n    type = undefined;\n  }\n\n  var merge = options && options.merge,\n      adhoc = type && type !== true,\n      constructing = type === true,\n      adhocs;\n\n  var strict = options && \'strict\' in options\n      ? options.strict\n      : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  if (typeof path !== \'string\') {\n    // new Document({ key: val })\n\n    if (path === null || path === void 0) {\n      var _ = path;\n      path = val;\n      val = _;\n    } else {\n      var prefix = val\n          ? val + \'.\'\n          : \'\';\n\n      if (path instanceof Document) {\n        if (path.$__isNested) {\n          path = path.toObject();\n        } else {\n          path = path._doc;\n        }\n      }\n\n      var keys = Object.keys(path);\n      var len = keys.length;\n      var i = 0;\n      var pathtype;\n      var key;\n\n      if (len === 0 && !this.schema.options.minimize) {\n        if (val) {\n          this.set(val, {});\n        }\n        return this;\n      }\n\n      if (this.schema.options.retainKeyOrder) {\n        while (i < len) {\n          _handleIndex.call(this, i++);\n        }\n      } else {\n        while (len--) {\n          _handleIndex.call(this, len);\n        }\n      }\n\n      return this;\n    }\n  }\n\n  function _handleIndex(i) {\n    key = keys[i];\n    var pathName = prefix + key;\n    pathtype = this.schema.pathType(pathName);\n\n    if (path[key] !== null\n        && path[key] !== void 0\n          // need to know if plain object - no Buffer, ObjectId, ref, etc\n        && utils.isObject(path[key])\n        && (!path[key].constructor || utils.getFunctionName(path[key].constructor) === \'Object\')\n        && pathtype !== \'virtual\'\n        && pathtype !== \'real\'\n        && !(this.$__path(pathName) instanceof MixedSchema)\n        && !(this.schema.paths[pathName] &&\n        this.schema.paths[pathName].options &&\n        this.schema.paths[pathName].options.ref)) {\n      this.set(path[key], prefix + key, constructing);\n    } else if (strict) {\n      // Don\'t overwrite defaults with undefined keys (gh-3981)\n      if (constructing && path[key] === void 0 &&\n          this.get(key) !== void 0) {\n        return;\n      }\n\n      if (pathtype === \'real\' || pathtype === \'virtual\') {\n        // Check for setting single embedded schema to document (gh-3535)\n        var p = path[key];\n        if (this.schema.paths[pathName] &&\n            this.schema.paths[pathName].$isSingleNested &&\n            path[key] instanceof Document) {\n          p = p.toObject({ virtuals: false, transform: false });\n        }\n        this.set(prefix + key, p, constructing);\n      } else if (pathtype === \'nested\' && path[key] instanceof Document) {\n        this.set(prefix + key,\n            path[key].toObject({transform: false}), constructing);\n      } else if (strict === \'throw\') {\n        if (pathtype === \'nested\') {\n          throw new ObjectExpectedError(key, path[key]);\n        } else {\n          throw new StrictModeError(key);\n        }\n      }\n    } else if (path[key] !== void 0) {\n      this.set(prefix + key, path[key], constructing);\n    }\n  }\n\n  var pathType = this.schema.pathType(path);\n  if (pathType === \'nested\' && val) {\n    if (utils.isObject(val) &&\n        (!val.constructor || utils.getFunctionName(val.constructor) === \'Object\')) {\n      if (!merge) {\n        this.setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      }\n\n      if (Object.keys(val).length === 0) {\n        this.setValue(path, {});\n        this.markModified(path);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        this.set(val, path, constructing);\n      }\n      return this;\n    }\n    this.invalidate(path, new MongooseError.CastError(\'Object\', val, path));\n    return this;\n  }\n\n  var schema;\n  var parts = path.split(\'.\');\n\n  if (pathType === \'adhocOrUndefined\' && strict) {\n    // check for roots that are Mixed types\n    var mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      var subpath = parts.slice(0, i + 1).join(\'.\');\n      schema = this.schema.path(subpath);\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n\n      // If path is underneath a virtual, bypass everything and just set it.\n      if (i + 1 < parts.length && this.schema.pathType(subpath) === \'virtual\') {\n        mpath.set(path, val, this);\n        return this;\n      }\n    }\n\n    if (!mixed) {\n      if (strict === \'throw\') {\n        throw new StrictModeError(path);\n      }\n      return this;\n    }\n  } else if (pathType === \'virtual\') {\n    schema = this.schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  var pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: "LEFT_SUBFIELD only supports Object"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    for (i = 0; i < parts.length; ++i) {\n      subpath = parts.slice(0, i + 1).join(\'.\');\n      if (this.isDirectModified(subpath) // earlier prefixes that are already\n            // marked as dirty have precedence\n          || this.get(subpath) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n\n  // if this doc is being constructed we should not trigger getters\n  var priorVal = constructing\n      ? undefined\n      : this.getValue(path);\n\n  if (!schema) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n    return this;\n  }\n\n  var shouldSet = true;\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    var didPopulate = false;\n    if (schema.options &&\n        schema.options.ref &&\n        val instanceof Document &&\n        (schema.options.ref === val.constructor.modelName || schema.options.ref === val.constructor.baseModelName)) {\n      if (this.ownerDocument) {\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val._id, {model: val.constructor});\n      } else {\n        this.populated(path, val._id, {model: val.constructor});\n      }\n      didPopulate = true;\n    }\n\n    var popOpts;\n    if (schema.options &&\n        Array.isArray(schema.options.type) &&\n        schema.options.type.length &&\n        schema.options.type[0].ref &&\n        Array.isArray(val) &&\n        val.length > 0 &&\n        val[0] instanceof Document &&\n        val[0].constructor.modelName &&\n        (schema.options.type[0].ref === val[0].constructor.baseModelName || schema.options.type[0].ref === val[0].constructor.modelName)) {\n      if (this.ownerDocument) {\n        popOpts = { model: val[0].constructor };\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val.map(function(v) { return v._id; }), popOpts);\n      } else {\n        popOpts = { model: val[0].constructor };\n        this.populated(path, val.map(function(v) { return v._id; }), popOpts);\n      }\n      didPopulate = true;\n    }\n    val = schema.applySetters(val, this, false, priorVal);\n\n    if (!didPopulate && this.$__.populated) {\n      delete this.$__.populated[path];\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    this.invalidate(path,\n      new MongooseError.CastError(schema.instance, val, path, e));\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n}',
  modifiedPaths: 'function () {\n  var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n  return directModifiedPaths.reduce(function(list, path) {\n    var parts = path.split(\'.\');\n    return list.concat(parts.reduce(function(chains, part, i) {\n      return chains.concat(parts.slice(0, i).concat(part).join(\'.\'));\n    }, []).filter(function(chain) {\n      return (list.indexOf(chain) === -1);\n    }));\n  }, []);\n}',
  get: 'function (path, type) {\n  var adhoc;\n  if (type) {\n    adhoc = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  var schema = this.$__path(path) || this.schema.virtualpath(path),\n      pieces = path.split(\'.\'),\n      obj = this._doc;\n\n  for (var i = 0, l = pieces.length; i < l; i++) {\n    obj = obj === null || obj === void 0\n        ? undefined\n        : obj[pieces[i]];\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  // Check if this path is populated - don\'t apply getters if it is,\n  // because otherwise its a nested object. See gh-3357\n  if (schema && !this.populated(path)) {\n    obj = schema.applyGetters(obj, this);\n  }\n\n  return obj;\n}',
  updatedAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  '$__path': 'function (path) {\n  var adhocs = this.$__.adhocPaths,\n      adhocType = adhocs && adhocs[path];\n\n  if (adhocType) {\n    return adhocType;\n  }\n  return this.schema.path(path);\n}',
  '$__save': 'function (options, callback) {\n  var _this = this;\n\n  _this.$__handleSave(options, function(error, result) {\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.$__reset();\n    _this.$__storeShard();\n\n    var numAffected = 0;\n    if (result) {\n      if (Array.isArray(result)) {\n        numAffected = result.length;\n      } else if (result.result && result.result.n !== undefined) {\n        numAffected = result.result.n;\n      } else if (result.result && result.result.nModified !== undefined) {\n        numAffected = result.result.nModified;\n      } else {\n        numAffected = result;\n      }\n    }\n\n    // was this an update that required a version bump?\n    if (_this.$__.version && !_this.$__.inserting) {\n      var doIncrement = VERSION_INC === (VERSION_INC & _this.$__.version);\n      _this.$__.version = undefined;\n\n      if (numAffected <= 0) {\n        // the update failed. pass an error back\n        var err = new VersionError(_this);\n        return callback(err);\n      }\n\n      // increment version if was successful\n      if (doIncrement) {\n        var key = _this.schema.options.versionKey;\n        var version = _this.getValue(key) | 0;\n        _this.setValue(key, version + 1);\n      }\n    }\n\n    if (_this.schema.options &&\n        _this.schema.options.saveErrorIfNotFound &&\n        numAffected <= 0) {\n      error = new DocumentNotFoundError(result.$where);\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.emit(\'save\', _this, numAffected);\n    _this.constructor.emit(\'save\', _this, numAffected);\n    callback(null, _this, numAffected);\n  });\n}',
  '$__delta': 'function () {\n  var dirty = this.$__dirty();\n  if (!dirty.length && VERSION_ALL !== this.$__.version) return;\n\n  var where = {},\n      delta = {},\n      len = dirty.length,\n      divergent = [],\n      d = 0;\n\n  where._id = this._doc._id;\n  if (where._id.toObject) {\n    where._id = where._id.toObject({ transform: false, depopulate: true });\n  }\n\n  for (; d < len; ++d) {\n    var data = dirty[d];\n    var value = data.value;\n\n    var match = checkDivergentArray(this, data.path, value);\n    if (match) {\n      divergent.push(match);\n      continue;\n    }\n\n    var pop = this.populated(data.path, true);\n    if (!pop && this.$__.selected) {\n      // If any array was selected using an $elemMatch projection, we alter the path and where clause\n      // NOTE: MongoDB only supports projected $elemMatch on top level array.\n      var pathSplit = data.path.split(\'.\');\n      var top = pathSplit[0];\n      if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {\n        // If the selected array entry was modified\n        if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === \'undefined\') {\n          where[top] = this.$__.selected[top];\n          pathSplit[1] = \'$\';\n          data.path = pathSplit.join(\'.\');\n        }\n        // if the selected array was modified in any other way throw an error\n        else {\n          divergent.push(data.path);\n          continue;\n        }\n      }\n    }\n\n    if (divergent.length) continue;\n\n    if (undefined === value) {\n      operand(this, where, delta, data, 1, \'$unset\');\n    } else if (value === null) {\n      operand(this, where, delta, data, null);\n    } else if (value._path && value._atomics) {\n      // arrays and other custom types (support plugins etc)\n      handleAtomics(this, where, delta, data, value);\n    } else if (value._path && Buffer.isBuffer(value)) {\n      // MongooseBuffer\n      value = value.toObject();\n      operand(this, where, delta, data, value);\n    } else {\n      value = utils.clone(value, {depopulate: 1, _isNested: true});\n      operand(this, where, delta, data, value);\n    }\n  }\n\n  if (divergent.length) {\n    return new DivergentArrayError(divergent);\n  }\n\n  if (this.$__.version) {\n    this.$__version(where, delta);\n  }\n\n  return [where, delta];\n}',
  '$__storeShard': 'function () {\n  // backwards compat\n  var key = this.schema.options.shardKey || this.schema.options.shardkey;\n  if (!(key && utils.getFunctionName(key.constructor) === \'Object\')) {\n    return;\n  }\n\n  var orig = this.$__.shardval = {},\n      paths = Object.keys(key),\n      len = paths.length,\n      val;\n\n  for (var i = 0; i < len; ++i) {\n    val = this.getValue(paths[i]);\n    if (isMongooseObject(val)) {\n      orig[paths[i]] = val.toObject({depopulate: true, _isNested: true});\n    } else if (val !== null && val !== undefined && val.valueOf &&\n          // Explicitly don\'t take value of dates\n        (!val.constructor || utils.getFunctionName(val.constructor) !== \'Date\')) {\n      orig[paths[i]] = val.valueOf();\n    } else {\n      orig[paths[i]] = val;\n    }\n  }\n}',
  listeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  depopulate: 'function (path) {\n  var populatedIds = this.populated(path);\n  if (!populatedIds) {\n    return;\n  }\n  delete this.$__.populated[path];\n  this.set(path, populatedIds);\n  return this;\n}',
  equals: 'function (doc) {\n  if (!doc) {\n    return false;\n  }\n\n  var tid = this.get(\'_id\');\n  var docid = doc.get ? doc.get(\'_id\') : doc;\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals\n      ? tid.equals(docid)\n      : tid === docid;\n}',
  _posts: '[object Object]',
  '$__getAllSubdocs': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  function docReducer(seed, path) {\n    var val = this[path];\n\n    if (val instanceof Embedded) {\n      seed.push(val);\n    }\n    if (val && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(docReducer.bind(val._doc), seed);\n      seed.push(val);\n    }\n    if (val && val.isMongooseDocumentArray) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n        seed = Object.keys(doc._doc).reduce(docReducer.bind(doc._doc), seed);\n      });\n    } else if (val instanceof Document && val.$__isNested) {\n      if (val) {\n        seed = Object.keys(val).reduce(docReducer.bind(val), seed);\n      }\n    }\n    return seed;\n  }\n\n  var subDocs = Object.keys(this._doc).reduce(docReducer.bind(this), []);\n\n  return subDocs;\n}',
  '$__original_save': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  removeListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  '$__getArrayPathsToValidate': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  // validate all document arrays.\n  return this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return this.getValue(i);\n  }.bind(this))\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  }).reduce(function(seed, array) {\n    return seed.concat(array);\n  }, [])\n  .filter(function(doc) {\n    return doc;\n  });\n}',
  schema: '[object Object]',
  removeAllListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  save: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  isDirectSelected: 'function isDirectSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  removePost: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , posts = proto._posts || (proto._posts || {});\n    if (!posts[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all post callbacks for hook `name`\n      posts[name].length = 0;\n    } else {\n      posts[name] = posts[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  _lazySetupHooks: 'function (proto, methodName, errorCb) {\n    if (\'undefined\' === typeof proto[methodName].numAsyncPres) {\n      this.$hook(methodName, proto[methodName], errorCb);\n    }\n  }',
  toBSON: 'function () {\n  return this.toObject({\n    transform: false,\n    virtuals: false,\n    _skipDepopulateTopLevel: true,\n    depopulate: true,\n    flattenDecimals: false\n  });\n}',
  markModified: 'function (path) {\n  this.$__.activePaths.modify(path);\n}',
  on: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  increment: 'function increment() {\n  this.$__.version = VERSION_ALL;\n  return this;\n}',
  validate: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populated: 'function (path, val, options) {\n  // val and options are internal\n\n  if (val === null || val === void 0) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    var v = this.$__.populated[path];\n    if (v) {\n      return v.value;\n    }\n    return undefined;\n  }\n\n  // internal\n\n  if (val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    return this.$__.populated[path];\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = {value: val, options: options};\n  return val;\n}',
  update: 'function update() {\n  var args = utils.args(arguments);\n  args.unshift({_id: this._id});\n  return this.constructor.update.apply(this.constructor, args);\n}',
  id: '5902b753c5756d72945d90b3',
  '$__setSchema': 'function (schema) {\n  compile(schema.tree, this, undefined, schema.options);\n  this.schema = schema;\n}',
  isInit: 'function (path) {\n  return (path in this.$__.activePaths.states.init);\n}',
  '$__validate': 'function (callback) {\n  var _this = this;\n  var _complete = function() {\n    var err = _this.$__.validationError;\n    _this.$__.validationError = undefined;\n    _this.emit(\'validate\', _this);\n    _this.constructor.emit(\'validate\', _this);\n    if (err) {\n      for (var key in err.errors) {\n        // Make sure cast errors persist\n        if (!_this.__parent && err.errors[key] instanceof MongooseError.CastError) {\n          _this.invalidate(key, err.errors[key]);\n        }\n      }\n\n      return err;\n    }\n  };\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (paths.length === 0) {\n    process.nextTick(function() {\n      var error = _complete();\n      if (error) {\n        return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n          callback(error);\n        });\n      }\n      callback();\n    });\n  }\n\n  var validating = {},\n      total = 0;\n\n  var complete = function() {\n    var error = _complete();\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n    callback();\n  };\n\n  var validatePath = function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n    total++;\n\n    process.nextTick(function() {\n      var p = _this.schema.path(path);\n      if (!p) {\n        return --total || complete();\n      }\n\n      // If user marked as invalid or there was a cast error, don\'t validate\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      var val = _this.getValue(path);\n      p.doValidate(val, function(err) {\n        if (err) {\n          _this.invalidate(path, err, undefined, true);\n        }\n        --total || complete();\n      }, _this);\n    });\n  };\n\n  paths.forEach(validatePath);\n}',
  db: '[object Object]',
  username: '222',
  '$__original_validate': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  discriminators: 'undefined',
  isModified: 'function (paths) {\n  if (paths) {\n    if (!Array.isArray(paths)) {\n      paths = paths.split(\' \');\n    }\n    var modified = this.modifiedPaths();\n    var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n    var isModifiedChild = paths.some(function(path) {\n      return !!~modified.indexOf(path);\n    });\n    return isModifiedChild || paths.some(function(path) {\n      return directModifiedPaths.some(function(mod) {\n        return mod === path || path.indexOf(mod + \'.\') === 0;\n      });\n    });\n  }\n  return this.$__.activePaths.some(\'modify\');\n}',
  '$pre': 'function (name, isAsync, fn, errorCb) {\n    if (\'boolean\' !== typeof arguments[1]) {\n      errorCb = fn;\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {};\n\n    this._lazySetupHooks(proto, name, errorCb);\n\n    if (fn.isAsync = isAsync) {\n      proto[name].numAsyncPres++;\n    }\n\n    (pres[name] = pres[name] || []).push(fn);\n    return this;\n  }',
  toObject: 'function (options) {\n  return this.$toObject(options);\n}',
  '$markValid': 'function (path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n}',
  '$isValid': 'function (path) {\n  return !this.$__.validationError || !this.$__.validationError.errors[path];\n}',
  isDirectModified: 'function (path) {\n  return (path in this.$__.activePaths.states.modify);\n}',
  '$__dirty': 'function () {\n  var _this = this;\n\n  var all = this.$__.activePaths.map(\'modify\', function(path) {\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  });\n\n  // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n  all = all.concat(this.$__.activePaths.map(\'default\', function(path) {\n    if (path === \'_id\' || !_this.getValue(path)) {\n      return;\n    }\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n\n  // Sort dirty paths in a flat hierarchy.\n  all.sort(function(a, b) {\n    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));\n  });\n\n  // Ignore "foo.a" if "foo" is dirty already.\n  var minimal = [],\n      lastPath,\n      top;\n\n  all.forEach(function(item) {\n    if (!item) {\n      return;\n    }\n    if (item.path.indexOf(lastPath) !== 0) {\n      lastPath = item.path + \'.\';\n      minimal.push(item);\n      top = item;\n    } else {\n      // special case for top level MongooseArrays\n      if (top.value && top.value._atomics && top.value.hasAtomics()) {\n        // the `top` array itself and a sub path of `top` are being modified.\n        // the only way to honor all of both modifications is through a $set\n        // of entire array.\n        top.value._atomics = {};\n        top.value._atomics.$set = top.value;\n      }\n    }\n  });\n\n  top = lastPath = null;\n  return minimal;\n}',
  model: 'function model(name) {\n  return this.db.model(name);\n}',
  '$isDefault': 'function (path) {\n  return (path in this.$__.activePaths.states.default);\n}',
  '$__original_remove': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  remove: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populate: 'function populate() {\n  if (arguments.length === 0) {\n    return this;\n  }\n\n  var pop = this.$__.populate || (this.$__.populate = {});\n  var args = utils.args(arguments);\n  var fn;\n\n  if (typeof args[args.length - 1] === \'function\') {\n    fn = args.pop();\n  }\n\n  // allow `doc.populate(callback)`\n  if (args.length) {\n    // use hash to remove duplicate paths\n    var res = utils.populate.apply(null, args);\n    for (var i = 0; i < res.length; ++i) {\n      pop[res[i].path] = res[i];\n    }\n  }\n\n  if (fn) {\n    var paths = utils.object.vals(pop);\n    this.$__.populate = undefined;\n    paths.__noPromise = true;\n    this.constructor.populate(this, paths, fn);\n  }\n\n  return this;\n}',
  '$__shouldModify': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  if (this.isNew) {\n    return true;\n  }\n\n  if (undefined === val && !this.isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (undefined === val && path in this.$__.activePaths.states.default) {\n    // we\'re just unsetting the default value which was never saved\n    return false;\n  }\n\n  // gh-3992: if setting a populated field to a doc, don\'t mark modified\n  // if they have the same _id\n  if (this.populated(path) &&\n      val instanceof Document &&\n      deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal || this.get(path))) {\n    return true;\n  }\n\n  if (!constructing &&\n      val !== null &&\n      val !== undefined &&\n      path in this.$__.activePaths.states.default &&\n      deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n  return false;\n}',
  '$__': '[object Object]',
  '$__fullPath': 'function (path) {\n  // overridden in SubDocuments\n  return path || \'\';\n}',
  _pres: '[object Object]',
  inspect: 'function (options) {\n  var isPOJO = options &&\n    utils.getFunctionName(options.constructor) === \'Object\';\n  var opts;\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n    opts.retainKeyOrder = true;\n  }\n  return this.toObject(opts);\n}',
  '$__reset': 'function reset() {\n  var _this = this;\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return _this.getValue(i);\n  })\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  })\n  .forEach(function(array) {\n    var i = array.length;\n    while (i--) {\n      var doc = array[i];\n      if (!doc) {\n        continue;\n      }\n      doc.$__reset();\n    }\n  });\n\n  // clear atomics\n  this.$__dirty().forEach(function(dirt) {\n    var type = dirt.value;\n    if (type && type._atomics) {\n      type._atomics = {};\n    }\n  });\n\n  // Clear \'dirty\' cache\n  this.$__.activePaths.clear(\'modify\');\n  this.$__.activePaths.clear(\'default\');\n  this.$__.validationError = undefined;\n  this.errors = undefined;\n  _this = this;\n  this.schema.requiredPaths().forEach(function(path) {\n    _this.$__.activePaths.require(path);\n  });\n\n  return this;\n}',
  init: 'function (doc, opts, fn) {\n  // do not prefix this method with $__ since its\n  // used by public hooks\n\n  if (typeof opts === \'function\') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.isNew = false;\n\n  // handle docs with populated paths\n  // If doc._id is not null or undefined\n  if (doc._id !== null && doc._id !== undefined &&\n    opts && opts.populated && opts.populated.length) {\n    var id = String(doc._id);\n    for (var i = 0; i < opts.populated.length; ++i) {\n      var item = opts.populated[i];\n      if (item.isVirtual) {\n        this.populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.populated(item.path, item._docs[id], item);\n      }\n    }\n  }\n\n  init(this, doc, this._doc);\n  this.$__storeShard();\n\n  this.emit(\'init\', this);\n  this.constructor.emit(\'init\', this);\n\n  if (fn) {\n    fn(null);\n  }\n  return this;\n}',
  setMaxListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  initializeTimestamps: 'function () {\n      if (!this.get(createdAt)) {\n        this.set(createdAt, new Date());\n      }\n      if (!this.get(updatedAt)) {\n        this.set(updatedAt, new Date());\n      }\n      return this;\n    }',
  once: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  __v: '0',
  '$toObject': 'function (options, json) {\n  var defaultOptions = {\n    transform: true,\n    json: json,\n    retainKeyOrder: this.schema.options.retainKeyOrder,\n    flattenDecimals: true\n  };\n\n  // _isNested will only be true if this is not the top level document, we\n  // should never depopulate\n  if (options && options.depopulate && options._isNested && this.$__.wasPopulated) {\n    // populated paths that we set to a document\n    return clone(this._id, options);\n  }\n\n  // When internally saving this document we always pass options,\n  // bypassing the custom schema options.\n  if (!(options && utils.getFunctionName(options.constructor) === \'Object\') ||\n      (options && options._useSchemaOptions)) {\n    if (json) {\n      options = this.schema.options.toJSON ?\n        clone(this.schema.options.toJSON) :\n        {};\n      options.json = true;\n      options._useSchemaOptions = true;\n    } else {\n      options = this.schema.options.toObject ?\n        clone(this.schema.options.toObject) :\n        {};\n      options.json = false;\n      options._useSchemaOptions = true;\n    }\n  }\n\n  for (var key in defaultOptions) {\n    if (options[key] === undefined) {\n      options[key] = defaultOptions[key];\n    }\n  }\n\n  (\'minimize\' in options) || (options.minimize = this.schema.options.minimize);\n\n  // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n  var originalTransform = options.transform;\n\n  options._isNested = true;\n\n  var ret = clone(this._doc, options) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, \'paths\', options);\n    // applyGetters for paths will add nested empty objects;\n    // if minimize is set, we need to remove them.\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || options.getters && options.virtuals !== false) {\n    applyGetters(this, ret, \'virtuals\', options);\n  }\n\n  if (options.versionKey === false && this.schema.options.versionKey) {\n    delete ret[this.schema.options.versionKey];\n  }\n\n  var transform = options.transform;\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema\'s transform and\n  // not the parent schema\'s\n  if (transform === true ||\n      (this.schema.options.toObject && transform)) {\n    var opts = options.json ? this.schema.options.toJSON : this.schema.options.toObject;\n\n    if (opts) {\n      transform = (typeof options.transform === \'function\' ? options.transform : opts.transform);\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === \'function\') {\n    var xformed = transform(this, ret, options);\n    if (typeof xformed !== \'undefined\') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n}',
  '$hook': 'function (name, fn, errorCb) {\n    if (arguments.length === 1 && typeof name === \'object\') {\n      for (var k in name) { // `name` is a hash of hookName->hookFn\n        this.$hook(k, name[k]);\n      }\n      return;\n    }\n\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {}\n      , posts = proto._posts = proto._posts || {};\n    pres[name] = pres[name] || [];\n    posts[name] = posts[name] || [];\n\n    proto[name] = function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    };\n    \n    proto[name].numAsyncPres = 0;\n\n    return this;\n  }',
  '$__set': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  var shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts,\n    schema, val, priorVal);\n  var _this = this;\n\n  if (shouldModify) {\n    this.markModified(pathToMark, val);\n\n    // handle directly setting arrays (gh-1126)\n    MongooseArray || (MongooseArray = require(\'./types/array\'));\n    if (val && val.isMongooseArray) {\n      val._registerAtomic(\'$set\', val);\n\n      // Update embedded document parent references (gh-5189)\n      if (val.isMongooseDocumentArray) {\n        val.forEach(function(item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      }\n\n      // Small hack for gh-1638: if we\'re overwriting the entire array, ignore\n      // paths that were modified before the array overwrite\n      this.$__.activePaths.forEach(function(modifiedPath) {\n        if (modifiedPath.indexOf(path + \'.\') === 0) {\n          _this.$__.activePaths.ignore(modifiedPath);\n        }\n      });\n    }\n  }\n\n  var obj = this._doc;\n  var i = 0;\n  var l = parts.length;\n  var cur = \'\';\n\n  for (; i < l; i++) {\n    var next = i + 1;\n    var last = next === l;\n    cur += (cur ? \'.\' + parts[i] : parts[i]);\n\n    if (last) {\n      obj[parts[i]] = val;\n    } else {\n      if (obj[parts[i]] && utils.getFunctionName(obj[parts[i]].constructor) === \'Object\') {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        this.set(cur, {});\n        obj = obj[parts[i]];\n      }\n    }\n  }\n}',
  name: '111',
  isNew: 'false',
  unmarkModified: 'function (path) {\n  this.$__.activePaths.init(path);\n}',
  validateSync: 'function (pathsToValidate) {\n  var _this = this;\n\n  if (typeof pathsToValidate === \'string\') {\n    pathsToValidate = pathsToValidate.split(\' \');\n  }\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (pathsToValidate && pathsToValidate.length) {\n    var tmp = [];\n    for (var i = 0; i < paths.length; ++i) {\n      if (pathsToValidate.indexOf(paths[i]) !== -1) {\n        tmp.push(paths[i]);\n      }\n    }\n    paths = tmp;\n  }\n\n  var validating = {};\n\n  paths.forEach(function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n\n    var p = _this.schema.path(path);\n    if (!p) {\n      return;\n    }\n    if (!_this.$isValid(path)) {\n      return;\n    }\n\n    var val = _this.getValue(path);\n    var err = p.doValidateSync(val, _this);\n    if (err) {\n      _this.invalidate(path, err, undefined, true);\n    }\n  });\n\n  var err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n  _this.emit(\'validate\', _this);\n  _this.constructor.emit(\'validate\', _this);\n\n  if (err) {\n    for (var key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n}',
  errors: 'undefined',
  addListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  setValue: 'function (path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n}',
  '$__where': 'function _where(where) {\n  where || (where = {});\n\n  var paths,\n      len;\n\n  if (!where._id) {\n    where._id = this._doc._id;\n  }\n\n  if (this.$__.shardval) {\n    paths = Object.keys(this.$__.shardval);\n    len = paths.length;\n\n    for (var i = 0; i < len; ++i) {\n      where[paths[i]] = this.$__.shardval[paths[i]];\n    }\n  }\n\n  if (this._doc._id == null) {\n    return new Error(\'No _id found on document!\');\n  }\n\n  return where;\n}',
  invalidate: 'function (path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === \'string\') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || \'user defined\',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.errors[path] = err;\n  return this.$__.validationError;\n}',
  execPopulate: 'function () {\n  var Promise = PromiseProvider.get();\n  var _this = this;\n  return new Promise.ES6(function(resolve, reject) {\n    _this.populate(function(error, res) {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(res);\n      }\n    });\n  });\n}',
  isSelected: 'function isSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    i = paths.length;\n    var pathDot = path + \'.\';\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n\n      if (cur.indexOf(pathDot) === 0) {\n        return inclusive || cur !== pathDot;\n      }\n\n      if (pathDot.indexOf(cur + \'.\') === 0) {\n        return inclusive;\n      }\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  toString: 'function () {\n  return inspect(this.inspect());\n}',
  toJSON: 'function (options) {\n  return this.$toObject(options, true);\n}',
  '$__handleReject': 'function handleReject(err) {\n  // emit on the Model if listening\n  if (this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  } else if (this.constructor.listeners && this.constructor.listeners(\'error\').length) {\n    this.constructor.emit(\'error\', err);\n  } else if (this.listeners && this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  }\n}' }
[2017-05-04 16:15:16.672] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:15:16.682] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:15:16.685] [INFO] app - Redis client default is ready {}
[2017-05-04 16:15:16.884] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:15:18.257] [DEBUG] app - 2017-5-4 16:15:18 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:15:18.263] [WARN] console - this is a logger middleware.
[2017-05-04 16:15:18.286] [WARN] console - { name: '111' }
[2017-05-04 16:15:26.442] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:15:26.452] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:15:26.455] [INFO] app - Redis client default is ready {}
[2017-05-04 16:15:26.650] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:15:27.475] [DEBUG] app - 2017-5-4 16:15:27 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:15:27.479] [WARN] console - this is a logger middleware.
[2017-05-04 16:15:27.505] [WARN] console - { _doc: '[object Object]',
  _id: '5902b753c5756d72945d90b3',
  '$post': 'function (name, isAsync, fn) {\n    if (arguments.length === 2) {\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , posts = proto._posts = proto._posts || {};\n    \n    this._lazySetupHooks(proto, name);\n    (posts[name] = posts[name] || []).push(fn);\n    return this;\n  }',
  getValue: 'function (path) {\n  return utils.getValue(path, this._doc);\n}',
  '$__handleSave': 'function (options, callback) {\n  var _this = this;\n  var i;\n  var keys;\n  var len;\n  if (!options.safe && this.schema.options.safe) {\n    options.safe = this.schema.options.safe;\n  }\n  if (typeof options.safe === \'boolean\') {\n    options.safe = null;\n  }\n\n  if (this.isNew) {\n    // send entire doc\n    var toObjectOptions = {};\n\n    toObjectOptions.retainKeyOrder = this.schema.options.retainKeyOrder;\n    toObjectOptions.depopulate = 1;\n    toObjectOptions._skipDepopulateTopLevel = true;\n    toObjectOptions.transform = false;\n    toObjectOptions.flattenDecimals = false;\n\n    var obj = this.toObject(toObjectOptions);\n\n    if (!utils.object.hasOwnProperty(obj || {}, \'_id\')) {\n      // documents must have an _id else mongoose won\'t know\n      // what to update later if more changes are made. the user\n      // wouldn\'t know what _id was generated by mongodb either\n      // nor would the ObjectId generated my mongodb necessarily\n      // match the schema definition.\n      setTimeout(function() {\n        callback(new Error(\'document must have an _id before saving\'));\n      }, 0);\n      return;\n    }\n\n    this.$__version(true, obj);\n    this.collection.insert(obj, options.safe, function(err, ret) {\n      if (err) {\n        _this.isNew = true;\n        _this.emit(\'isNew\', true);\n        _this.constructor.emit(\'isNew\', true);\n\n        callback(err);\n        return;\n      }\n\n      callback(null, ret);\n    });\n    this.$__reset();\n    this.isNew = false;\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n    // Make it possible to retry the insert\n    this.$__.inserting = true;\n  } else {\n    // Make sure we don\'t treat it as a new object on error,\n    // since it already exists\n    this.$__.inserting = false;\n\n    var delta = this.$__delta();\n\n    if (delta) {\n      if (delta instanceof Error) {\n        callback(delta);\n        return;\n      }\n\n      var where = this.$__where(delta[0]);\n      if (where instanceof Error) {\n        callback(where);\n        return;\n      }\n\n      if (this.$where) {\n        keys = Object.keys(this.$where);\n        len = keys.length;\n        for (i = 0; i < len; ++i) {\n          where[keys[i]] = this.$where[keys[i]];\n        }\n      }\n\n      this.collection.update(where, delta[1], options.safe, function(err, ret) {\n        if (err) {\n          callback(err);\n          return;\n        }\n        ret.$where = where;\n        callback(null, ret);\n      });\n    } else {\n      this.$__reset();\n      callback();\n      return;\n    }\n\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n  }\n}',
  '$__buildDoc': 'function (obj, fields, skipId) {\n  var doc = {};\n  var exclude = null;\n  var keys;\n  var ki;\n  var _this = this;\n\n  // determine if this doc is a result of a query with\n  // excluded fields\n\n  if (fields && utils.getFunctionName(fields.constructor) === \'Object\') {\n    keys = Object.keys(fields);\n    ki = keys.length;\n\n    if (ki === 1 && keys[0] === \'_id\') {\n      exclude = !!fields[keys[ki]];\n    } else {\n      while (ki--) {\n        if (keys[ki] !== \'_id\' &&\n            (!fields[keys[ki]] || typeof fields[keys[ki]] !== \'object\')) {\n          exclude = !fields[keys[ki]];\n          break;\n        }\n      }\n    }\n  }\n\n  var paths = Object.keys(this.schema.paths);\n  var plen = paths.length;\n  var ii = 0;\n\n  var hasIncludedChildren = {};\n  if (exclude === false && fields) {\n    keys = Object.keys(fields);\n    for (var j = 0; j < keys.length; ++j) {\n      var parts = keys[j].split(\'.\');\n      var c = [];\n      for (var k = 0; k < parts.length; ++k) {\n        c.push(parts[k]);\n        hasIncludedChildren[c.join(\'.\')] = 1;\n      }\n    }\n  }\n\n  for (; ii < plen; ++ii) {\n    var p = paths[ii];\n\n    if (p === \'_id\') {\n      if (skipId) {\n        continue;\n      }\n      if (obj && \'_id\' in obj) {\n        continue;\n      }\n    }\n\n    var type = this.schema.paths[p];\n    var path = p.split(\'.\');\n    var len = path.length;\n    var last = len - 1;\n    var curPath = \'\';\n    var doc_ = doc;\n    var i = 0;\n    var included = false;\n\n    for (; i < len; ++i) {\n      var piece = path[i],\n          def;\n\n      curPath += (!curPath.length ? \'\' : \'.\') + piece;\n\n      // support excluding intermediary levels\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i === last) {\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          } else if (included) {\n            // selected field\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          }\n        } else {\n          def = type.getDefault(_this, false);\n          if (typeof def !== \'undefined\') {\n            doc_[piece] = def;\n            _this.$__.activePaths.default(p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  return doc;\n}',
  '$ignore': 'function (path) {\n  this.$__.activePaths.ignore(path);\n}',
  removePre: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , pres = proto._pres || (proto._pres || {});\n    if (!pres[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all pre callbacks for hook `name`\n      pres[name].length = 0;\n    } else {\n      pres[name] = pres[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  collection: '[object Object]',
  emit: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  createdAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  '$__version': 'function (where, delta) {\n  var key = this.schema.options.versionKey;\n\n  if (where === true) {\n    // this is an insert\n    if (key) this.setValue(key, delta[key] = 0);\n    return;\n  }\n\n  // updates\n\n  // only apply versioning if our versionKey was selected. else\n  // there is no way to select the correct version. we could fail\n  // fast here and force them to include the versionKey but\n  // thats a bit intrusive. can we do this automatically?\n  if (!this.isSelected(key)) {\n    return;\n  }\n\n  // $push $addToSet don\'t need the where clause set\n  if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {\n    where[key] = this.getValue(key);\n  }\n\n  if (VERSION_INC === (VERSION_INC & this.$__.version)) {\n    if (!delta.$set || typeof delta.$set[key] === \'undefined\') {\n      delta.$inc || (delta.$inc = {});\n      delta.$inc[key] = 1;\n    }\n  }\n}',
  '$isMongooseModelPrototype': 'true',
  set: 'function (path, val, type, options) {\n  if (type && utils.getFunctionName(type.constructor) === \'Object\') {\n    options = type;\n    type = undefined;\n  }\n\n  var merge = options && options.merge,\n      adhoc = type && type !== true,\n      constructing = type === true,\n      adhocs;\n\n  var strict = options && \'strict\' in options\n      ? options.strict\n      : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  if (typeof path !== \'string\') {\n    // new Document({ key: val })\n\n    if (path === null || path === void 0) {\n      var _ = path;\n      path = val;\n      val = _;\n    } else {\n      var prefix = val\n          ? val + \'.\'\n          : \'\';\n\n      if (path instanceof Document) {\n        if (path.$__isNested) {\n          path = path.toObject();\n        } else {\n          path = path._doc;\n        }\n      }\n\n      var keys = Object.keys(path);\n      var len = keys.length;\n      var i = 0;\n      var pathtype;\n      var key;\n\n      if (len === 0 && !this.schema.options.minimize) {\n        if (val) {\n          this.set(val, {});\n        }\n        return this;\n      }\n\n      if (this.schema.options.retainKeyOrder) {\n        while (i < len) {\n          _handleIndex.call(this, i++);\n        }\n      } else {\n        while (len--) {\n          _handleIndex.call(this, len);\n        }\n      }\n\n      return this;\n    }\n  }\n\n  function _handleIndex(i) {\n    key = keys[i];\n    var pathName = prefix + key;\n    pathtype = this.schema.pathType(pathName);\n\n    if (path[key] !== null\n        && path[key] !== void 0\n          // need to know if plain object - no Buffer, ObjectId, ref, etc\n        && utils.isObject(path[key])\n        && (!path[key].constructor || utils.getFunctionName(path[key].constructor) === \'Object\')\n        && pathtype !== \'virtual\'\n        && pathtype !== \'real\'\n        && !(this.$__path(pathName) instanceof MixedSchema)\n        && !(this.schema.paths[pathName] &&\n        this.schema.paths[pathName].options &&\n        this.schema.paths[pathName].options.ref)) {\n      this.set(path[key], prefix + key, constructing);\n    } else if (strict) {\n      // Don\'t overwrite defaults with undefined keys (gh-3981)\n      if (constructing && path[key] === void 0 &&\n          this.get(key) !== void 0) {\n        return;\n      }\n\n      if (pathtype === \'real\' || pathtype === \'virtual\') {\n        // Check for setting single embedded schema to document (gh-3535)\n        var p = path[key];\n        if (this.schema.paths[pathName] &&\n            this.schema.paths[pathName].$isSingleNested &&\n            path[key] instanceof Document) {\n          p = p.toObject({ virtuals: false, transform: false });\n        }\n        this.set(prefix + key, p, constructing);\n      } else if (pathtype === \'nested\' && path[key] instanceof Document) {\n        this.set(prefix + key,\n            path[key].toObject({transform: false}), constructing);\n      } else if (strict === \'throw\') {\n        if (pathtype === \'nested\') {\n          throw new ObjectExpectedError(key, path[key]);\n        } else {\n          throw new StrictModeError(key);\n        }\n      }\n    } else if (path[key] !== void 0) {\n      this.set(prefix + key, path[key], constructing);\n    }\n  }\n\n  var pathType = this.schema.pathType(path);\n  if (pathType === \'nested\' && val) {\n    if (utils.isObject(val) &&\n        (!val.constructor || utils.getFunctionName(val.constructor) === \'Object\')) {\n      if (!merge) {\n        this.setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      }\n\n      if (Object.keys(val).length === 0) {\n        this.setValue(path, {});\n        this.markModified(path);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        this.set(val, path, constructing);\n      }\n      return this;\n    }\n    this.invalidate(path, new MongooseError.CastError(\'Object\', val, path));\n    return this;\n  }\n\n  var schema;\n  var parts = path.split(\'.\');\n\n  if (pathType === \'adhocOrUndefined\' && strict) {\n    // check for roots that are Mixed types\n    var mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      var subpath = parts.slice(0, i + 1).join(\'.\');\n      schema = this.schema.path(subpath);\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n\n      // If path is underneath a virtual, bypass everything and just set it.\n      if (i + 1 < parts.length && this.schema.pathType(subpath) === \'virtual\') {\n        mpath.set(path, val, this);\n        return this;\n      }\n    }\n\n    if (!mixed) {\n      if (strict === \'throw\') {\n        throw new StrictModeError(path);\n      }\n      return this;\n    }\n  } else if (pathType === \'virtual\') {\n    schema = this.schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  var pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: "LEFT_SUBFIELD only supports Object"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    for (i = 0; i < parts.length; ++i) {\n      subpath = parts.slice(0, i + 1).join(\'.\');\n      if (this.isDirectModified(subpath) // earlier prefixes that are already\n            // marked as dirty have precedence\n          || this.get(subpath) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n\n  // if this doc is being constructed we should not trigger getters\n  var priorVal = constructing\n      ? undefined\n      : this.getValue(path);\n\n  if (!schema) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n    return this;\n  }\n\n  var shouldSet = true;\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    var didPopulate = false;\n    if (schema.options &&\n        schema.options.ref &&\n        val instanceof Document &&\n        (schema.options.ref === val.constructor.modelName || schema.options.ref === val.constructor.baseModelName)) {\n      if (this.ownerDocument) {\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val._id, {model: val.constructor});\n      } else {\n        this.populated(path, val._id, {model: val.constructor});\n      }\n      didPopulate = true;\n    }\n\n    var popOpts;\n    if (schema.options &&\n        Array.isArray(schema.options.type) &&\n        schema.options.type.length &&\n        schema.options.type[0].ref &&\n        Array.isArray(val) &&\n        val.length > 0 &&\n        val[0] instanceof Document &&\n        val[0].constructor.modelName &&\n        (schema.options.type[0].ref === val[0].constructor.baseModelName || schema.options.type[0].ref === val[0].constructor.modelName)) {\n      if (this.ownerDocument) {\n        popOpts = { model: val[0].constructor };\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val.map(function(v) { return v._id; }), popOpts);\n      } else {\n        popOpts = { model: val[0].constructor };\n        this.populated(path, val.map(function(v) { return v._id; }), popOpts);\n      }\n      didPopulate = true;\n    }\n    val = schema.applySetters(val, this, false, priorVal);\n\n    if (!didPopulate && this.$__.populated) {\n      delete this.$__.populated[path];\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    this.invalidate(path,\n      new MongooseError.CastError(schema.instance, val, path, e));\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n}',
  modifiedPaths: 'function () {\n  var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n  return directModifiedPaths.reduce(function(list, path) {\n    var parts = path.split(\'.\');\n    return list.concat(parts.reduce(function(chains, part, i) {\n      return chains.concat(parts.slice(0, i).concat(part).join(\'.\'));\n    }, []).filter(function(chain) {\n      return (list.indexOf(chain) === -1);\n    }));\n  }, []);\n}',
  get: 'function (path, type) {\n  var adhoc;\n  if (type) {\n    adhoc = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  var schema = this.$__path(path) || this.schema.virtualpath(path),\n      pieces = path.split(\'.\'),\n      obj = this._doc;\n\n  for (var i = 0, l = pieces.length; i < l; i++) {\n    obj = obj === null || obj === void 0\n        ? undefined\n        : obj[pieces[i]];\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  // Check if this path is populated - don\'t apply getters if it is,\n  // because otherwise its a nested object. See gh-3357\n  if (schema && !this.populated(path)) {\n    obj = schema.applyGetters(obj, this);\n  }\n\n  return obj;\n}',
  updatedAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  '$__path': 'function (path) {\n  var adhocs = this.$__.adhocPaths,\n      adhocType = adhocs && adhocs[path];\n\n  if (adhocType) {\n    return adhocType;\n  }\n  return this.schema.path(path);\n}',
  '$__save': 'function (options, callback) {\n  var _this = this;\n\n  _this.$__handleSave(options, function(error, result) {\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.$__reset();\n    _this.$__storeShard();\n\n    var numAffected = 0;\n    if (result) {\n      if (Array.isArray(result)) {\n        numAffected = result.length;\n      } else if (result.result && result.result.n !== undefined) {\n        numAffected = result.result.n;\n      } else if (result.result && result.result.nModified !== undefined) {\n        numAffected = result.result.nModified;\n      } else {\n        numAffected = result;\n      }\n    }\n\n    // was this an update that required a version bump?\n    if (_this.$__.version && !_this.$__.inserting) {\n      var doIncrement = VERSION_INC === (VERSION_INC & _this.$__.version);\n      _this.$__.version = undefined;\n\n      if (numAffected <= 0) {\n        // the update failed. pass an error back\n        var err = new VersionError(_this);\n        return callback(err);\n      }\n\n      // increment version if was successful\n      if (doIncrement) {\n        var key = _this.schema.options.versionKey;\n        var version = _this.getValue(key) | 0;\n        _this.setValue(key, version + 1);\n      }\n    }\n\n    if (_this.schema.options &&\n        _this.schema.options.saveErrorIfNotFound &&\n        numAffected <= 0) {\n      error = new DocumentNotFoundError(result.$where);\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.emit(\'save\', _this, numAffected);\n    _this.constructor.emit(\'save\', _this, numAffected);\n    callback(null, _this, numAffected);\n  });\n}',
  '$__delta': 'function () {\n  var dirty = this.$__dirty();\n  if (!dirty.length && VERSION_ALL !== this.$__.version) return;\n\n  var where = {},\n      delta = {},\n      len = dirty.length,\n      divergent = [],\n      d = 0;\n\n  where._id = this._doc._id;\n  if (where._id.toObject) {\n    where._id = where._id.toObject({ transform: false, depopulate: true });\n  }\n\n  for (; d < len; ++d) {\n    var data = dirty[d];\n    var value = data.value;\n\n    var match = checkDivergentArray(this, data.path, value);\n    if (match) {\n      divergent.push(match);\n      continue;\n    }\n\n    var pop = this.populated(data.path, true);\n    if (!pop && this.$__.selected) {\n      // If any array was selected using an $elemMatch projection, we alter the path and where clause\n      // NOTE: MongoDB only supports projected $elemMatch on top level array.\n      var pathSplit = data.path.split(\'.\');\n      var top = pathSplit[0];\n      if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {\n        // If the selected array entry was modified\n        if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === \'undefined\') {\n          where[top] = this.$__.selected[top];\n          pathSplit[1] = \'$\';\n          data.path = pathSplit.join(\'.\');\n        }\n        // if the selected array was modified in any other way throw an error\n        else {\n          divergent.push(data.path);\n          continue;\n        }\n      }\n    }\n\n    if (divergent.length) continue;\n\n    if (undefined === value) {\n      operand(this, where, delta, data, 1, \'$unset\');\n    } else if (value === null) {\n      operand(this, where, delta, data, null);\n    } else if (value._path && value._atomics) {\n      // arrays and other custom types (support plugins etc)\n      handleAtomics(this, where, delta, data, value);\n    } else if (value._path && Buffer.isBuffer(value)) {\n      // MongooseBuffer\n      value = value.toObject();\n      operand(this, where, delta, data, value);\n    } else {\n      value = utils.clone(value, {depopulate: 1, _isNested: true});\n      operand(this, where, delta, data, value);\n    }\n  }\n\n  if (divergent.length) {\n    return new DivergentArrayError(divergent);\n  }\n\n  if (this.$__.version) {\n    this.$__version(where, delta);\n  }\n\n  return [where, delta];\n}',
  '$__storeShard': 'function () {\n  // backwards compat\n  var key = this.schema.options.shardKey || this.schema.options.shardkey;\n  if (!(key && utils.getFunctionName(key.constructor) === \'Object\')) {\n    return;\n  }\n\n  var orig = this.$__.shardval = {},\n      paths = Object.keys(key),\n      len = paths.length,\n      val;\n\n  for (var i = 0; i < len; ++i) {\n    val = this.getValue(paths[i]);\n    if (isMongooseObject(val)) {\n      orig[paths[i]] = val.toObject({depopulate: true, _isNested: true});\n    } else if (val !== null && val !== undefined && val.valueOf &&\n          // Explicitly don\'t take value of dates\n        (!val.constructor || utils.getFunctionName(val.constructor) !== \'Date\')) {\n      orig[paths[i]] = val.valueOf();\n    } else {\n      orig[paths[i]] = val;\n    }\n  }\n}',
  listeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  depopulate: 'function (path) {\n  var populatedIds = this.populated(path);\n  if (!populatedIds) {\n    return;\n  }\n  delete this.$__.populated[path];\n  this.set(path, populatedIds);\n  return this;\n}',
  equals: 'function (doc) {\n  if (!doc) {\n    return false;\n  }\n\n  var tid = this.get(\'_id\');\n  var docid = doc.get ? doc.get(\'_id\') : doc;\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals\n      ? tid.equals(docid)\n      : tid === docid;\n}',
  _posts: '[object Object]',
  '$__getAllSubdocs': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  function docReducer(seed, path) {\n    var val = this[path];\n\n    if (val instanceof Embedded) {\n      seed.push(val);\n    }\n    if (val && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(docReducer.bind(val._doc), seed);\n      seed.push(val);\n    }\n    if (val && val.isMongooseDocumentArray) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n        seed = Object.keys(doc._doc).reduce(docReducer.bind(doc._doc), seed);\n      });\n    } else if (val instanceof Document && val.$__isNested) {\n      if (val) {\n        seed = Object.keys(val).reduce(docReducer.bind(val), seed);\n      }\n    }\n    return seed;\n  }\n\n  var subDocs = Object.keys(this._doc).reduce(docReducer.bind(this), []);\n\n  return subDocs;\n}',
  '$__original_save': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  removeListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  '$__getArrayPathsToValidate': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  // validate all document arrays.\n  return this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return this.getValue(i);\n  }.bind(this))\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  }).reduce(function(seed, array) {\n    return seed.concat(array);\n  }, [])\n  .filter(function(doc) {\n    return doc;\n  });\n}',
  schema: '[object Object]',
  removeAllListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  save: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  isDirectSelected: 'function isDirectSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  removePost: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , posts = proto._posts || (proto._posts || {});\n    if (!posts[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all post callbacks for hook `name`\n      posts[name].length = 0;\n    } else {\n      posts[name] = posts[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  _lazySetupHooks: 'function (proto, methodName, errorCb) {\n    if (\'undefined\' === typeof proto[methodName].numAsyncPres) {\n      this.$hook(methodName, proto[methodName], errorCb);\n    }\n  }',
  toBSON: 'function () {\n  return this.toObject({\n    transform: false,\n    virtuals: false,\n    _skipDepopulateTopLevel: true,\n    depopulate: true,\n    flattenDecimals: false\n  });\n}',
  markModified: 'function (path) {\n  this.$__.activePaths.modify(path);\n}',
  on: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  increment: 'function increment() {\n  this.$__.version = VERSION_ALL;\n  return this;\n}',
  validate: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populated: 'function (path, val, options) {\n  // val and options are internal\n\n  if (val === null || val === void 0) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    var v = this.$__.populated[path];\n    if (v) {\n      return v.value;\n    }\n    return undefined;\n  }\n\n  // internal\n\n  if (val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    return this.$__.populated[path];\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = {value: val, options: options};\n  return val;\n}',
  update: 'function update() {\n  var args = utils.args(arguments);\n  args.unshift({_id: this._id});\n  return this.constructor.update.apply(this.constructor, args);\n}',
  id: '5902b753c5756d72945d90b3',
  '$__setSchema': 'function (schema) {\n  compile(schema.tree, this, undefined, schema.options);\n  this.schema = schema;\n}',
  isInit: 'function (path) {\n  return (path in this.$__.activePaths.states.init);\n}',
  '$__validate': 'function (callback) {\n  var _this = this;\n  var _complete = function() {\n    var err = _this.$__.validationError;\n    _this.$__.validationError = undefined;\n    _this.emit(\'validate\', _this);\n    _this.constructor.emit(\'validate\', _this);\n    if (err) {\n      for (var key in err.errors) {\n        // Make sure cast errors persist\n        if (!_this.__parent && err.errors[key] instanceof MongooseError.CastError) {\n          _this.invalidate(key, err.errors[key]);\n        }\n      }\n\n      return err;\n    }\n  };\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (paths.length === 0) {\n    process.nextTick(function() {\n      var error = _complete();\n      if (error) {\n        return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n          callback(error);\n        });\n      }\n      callback();\n    });\n  }\n\n  var validating = {},\n      total = 0;\n\n  var complete = function() {\n    var error = _complete();\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n    callback();\n  };\n\n  var validatePath = function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n    total++;\n\n    process.nextTick(function() {\n      var p = _this.schema.path(path);\n      if (!p) {\n        return --total || complete();\n      }\n\n      // If user marked as invalid or there was a cast error, don\'t validate\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      var val = _this.getValue(path);\n      p.doValidate(val, function(err) {\n        if (err) {\n          _this.invalidate(path, err, undefined, true);\n        }\n        --total || complete();\n      }, _this);\n    });\n  };\n\n  paths.forEach(validatePath);\n}',
  db: '[object Object]',
  username: '222',
  '$__original_validate': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  discriminators: 'undefined',
  isModified: 'function (paths) {\n  if (paths) {\n    if (!Array.isArray(paths)) {\n      paths = paths.split(\' \');\n    }\n    var modified = this.modifiedPaths();\n    var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n    var isModifiedChild = paths.some(function(path) {\n      return !!~modified.indexOf(path);\n    });\n    return isModifiedChild || paths.some(function(path) {\n      return directModifiedPaths.some(function(mod) {\n        return mod === path || path.indexOf(mod + \'.\') === 0;\n      });\n    });\n  }\n  return this.$__.activePaths.some(\'modify\');\n}',
  '$pre': 'function (name, isAsync, fn, errorCb) {\n    if (\'boolean\' !== typeof arguments[1]) {\n      errorCb = fn;\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {};\n\n    this._lazySetupHooks(proto, name, errorCb);\n\n    if (fn.isAsync = isAsync) {\n      proto[name].numAsyncPres++;\n    }\n\n    (pres[name] = pres[name] || []).push(fn);\n    return this;\n  }',
  toObject: 'function (options) {\n  return this.$toObject(options);\n}',
  '$markValid': 'function (path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n}',
  '$isValid': 'function (path) {\n  return !this.$__.validationError || !this.$__.validationError.errors[path];\n}',
  isDirectModified: 'function (path) {\n  return (path in this.$__.activePaths.states.modify);\n}',
  '$__dirty': 'function () {\n  var _this = this;\n\n  var all = this.$__.activePaths.map(\'modify\', function(path) {\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  });\n\n  // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n  all = all.concat(this.$__.activePaths.map(\'default\', function(path) {\n    if (path === \'_id\' || !_this.getValue(path)) {\n      return;\n    }\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n\n  // Sort dirty paths in a flat hierarchy.\n  all.sort(function(a, b) {\n    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));\n  });\n\n  // Ignore "foo.a" if "foo" is dirty already.\n  var minimal = [],\n      lastPath,\n      top;\n\n  all.forEach(function(item) {\n    if (!item) {\n      return;\n    }\n    if (item.path.indexOf(lastPath) !== 0) {\n      lastPath = item.path + \'.\';\n      minimal.push(item);\n      top = item;\n    } else {\n      // special case for top level MongooseArrays\n      if (top.value && top.value._atomics && top.value.hasAtomics()) {\n        // the `top` array itself and a sub path of `top` are being modified.\n        // the only way to honor all of both modifications is through a $set\n        // of entire array.\n        top.value._atomics = {};\n        top.value._atomics.$set = top.value;\n      }\n    }\n  });\n\n  top = lastPath = null;\n  return minimal;\n}',
  model: 'function model(name) {\n  return this.db.model(name);\n}',
  '$isDefault': 'function (path) {\n  return (path in this.$__.activePaths.states.default);\n}',
  '$__original_remove': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  remove: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populate: 'function populate() {\n  if (arguments.length === 0) {\n    return this;\n  }\n\n  var pop = this.$__.populate || (this.$__.populate = {});\n  var args = utils.args(arguments);\n  var fn;\n\n  if (typeof args[args.length - 1] === \'function\') {\n    fn = args.pop();\n  }\n\n  // allow `doc.populate(callback)`\n  if (args.length) {\n    // use hash to remove duplicate paths\n    var res = utils.populate.apply(null, args);\n    for (var i = 0; i < res.length; ++i) {\n      pop[res[i].path] = res[i];\n    }\n  }\n\n  if (fn) {\n    var paths = utils.object.vals(pop);\n    this.$__.populate = undefined;\n    paths.__noPromise = true;\n    this.constructor.populate(this, paths, fn);\n  }\n\n  return this;\n}',
  '$__shouldModify': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  if (this.isNew) {\n    return true;\n  }\n\n  if (undefined === val && !this.isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (undefined === val && path in this.$__.activePaths.states.default) {\n    // we\'re just unsetting the default value which was never saved\n    return false;\n  }\n\n  // gh-3992: if setting a populated field to a doc, don\'t mark modified\n  // if they have the same _id\n  if (this.populated(path) &&\n      val instanceof Document &&\n      deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal || this.get(path))) {\n    return true;\n  }\n\n  if (!constructing &&\n      val !== null &&\n      val !== undefined &&\n      path in this.$__.activePaths.states.default &&\n      deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n  return false;\n}',
  '$__': '[object Object]',
  '$__fullPath': 'function (path) {\n  // overridden in SubDocuments\n  return path || \'\';\n}',
  _pres: '[object Object]',
  inspect: 'function (options) {\n  var isPOJO = options &&\n    utils.getFunctionName(options.constructor) === \'Object\';\n  var opts;\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n    opts.retainKeyOrder = true;\n  }\n  return this.toObject(opts);\n}',
  '$__reset': 'function reset() {\n  var _this = this;\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return _this.getValue(i);\n  })\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  })\n  .forEach(function(array) {\n    var i = array.length;\n    while (i--) {\n      var doc = array[i];\n      if (!doc) {\n        continue;\n      }\n      doc.$__reset();\n    }\n  });\n\n  // clear atomics\n  this.$__dirty().forEach(function(dirt) {\n    var type = dirt.value;\n    if (type && type._atomics) {\n      type._atomics = {};\n    }\n  });\n\n  // Clear \'dirty\' cache\n  this.$__.activePaths.clear(\'modify\');\n  this.$__.activePaths.clear(\'default\');\n  this.$__.validationError = undefined;\n  this.errors = undefined;\n  _this = this;\n  this.schema.requiredPaths().forEach(function(path) {\n    _this.$__.activePaths.require(path);\n  });\n\n  return this;\n}',
  init: 'function (doc, opts, fn) {\n  // do not prefix this method with $__ since its\n  // used by public hooks\n\n  if (typeof opts === \'function\') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.isNew = false;\n\n  // handle docs with populated paths\n  // If doc._id is not null or undefined\n  if (doc._id !== null && doc._id !== undefined &&\n    opts && opts.populated && opts.populated.length) {\n    var id = String(doc._id);\n    for (var i = 0; i < opts.populated.length; ++i) {\n      var item = opts.populated[i];\n      if (item.isVirtual) {\n        this.populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.populated(item.path, item._docs[id], item);\n      }\n    }\n  }\n\n  init(this, doc, this._doc);\n  this.$__storeShard();\n\n  this.emit(\'init\', this);\n  this.constructor.emit(\'init\', this);\n\n  if (fn) {\n    fn(null);\n  }\n  return this;\n}',
  setMaxListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  initializeTimestamps: 'function () {\n      if (!this.get(createdAt)) {\n        this.set(createdAt, new Date());\n      }\n      if (!this.get(updatedAt)) {\n        this.set(updatedAt, new Date());\n      }\n      return this;\n    }',
  once: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  __v: '0',
  '$toObject': 'function (options, json) {\n  var defaultOptions = {\n    transform: true,\n    json: json,\n    retainKeyOrder: this.schema.options.retainKeyOrder,\n    flattenDecimals: true\n  };\n\n  // _isNested will only be true if this is not the top level document, we\n  // should never depopulate\n  if (options && options.depopulate && options._isNested && this.$__.wasPopulated) {\n    // populated paths that we set to a document\n    return clone(this._id, options);\n  }\n\n  // When internally saving this document we always pass options,\n  // bypassing the custom schema options.\n  if (!(options && utils.getFunctionName(options.constructor) === \'Object\') ||\n      (options && options._useSchemaOptions)) {\n    if (json) {\n      options = this.schema.options.toJSON ?\n        clone(this.schema.options.toJSON) :\n        {};\n      options.json = true;\n      options._useSchemaOptions = true;\n    } else {\n      options = this.schema.options.toObject ?\n        clone(this.schema.options.toObject) :\n        {};\n      options.json = false;\n      options._useSchemaOptions = true;\n    }\n  }\n\n  for (var key in defaultOptions) {\n    if (options[key] === undefined) {\n      options[key] = defaultOptions[key];\n    }\n  }\n\n  (\'minimize\' in options) || (options.minimize = this.schema.options.minimize);\n\n  // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n  var originalTransform = options.transform;\n\n  options._isNested = true;\n\n  var ret = clone(this._doc, options) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, \'paths\', options);\n    // applyGetters for paths will add nested empty objects;\n    // if minimize is set, we need to remove them.\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || options.getters && options.virtuals !== false) {\n    applyGetters(this, ret, \'virtuals\', options);\n  }\n\n  if (options.versionKey === false && this.schema.options.versionKey) {\n    delete ret[this.schema.options.versionKey];\n  }\n\n  var transform = options.transform;\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema\'s transform and\n  // not the parent schema\'s\n  if (transform === true ||\n      (this.schema.options.toObject && transform)) {\n    var opts = options.json ? this.schema.options.toJSON : this.schema.options.toObject;\n\n    if (opts) {\n      transform = (typeof options.transform === \'function\' ? options.transform : opts.transform);\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === \'function\') {\n    var xformed = transform(this, ret, options);\n    if (typeof xformed !== \'undefined\') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n}',
  '$hook': 'function (name, fn, errorCb) {\n    if (arguments.length === 1 && typeof name === \'object\') {\n      for (var k in name) { // `name` is a hash of hookName->hookFn\n        this.$hook(k, name[k]);\n      }\n      return;\n    }\n\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {}\n      , posts = proto._posts = proto._posts || {};\n    pres[name] = pres[name] || [];\n    posts[name] = posts[name] || [];\n\n    proto[name] = function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    };\n    \n    proto[name].numAsyncPres = 0;\n\n    return this;\n  }',
  '$__set': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  var shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts,\n    schema, val, priorVal);\n  var _this = this;\n\n  if (shouldModify) {\n    this.markModified(pathToMark, val);\n\n    // handle directly setting arrays (gh-1126)\n    MongooseArray || (MongooseArray = require(\'./types/array\'));\n    if (val && val.isMongooseArray) {\n      val._registerAtomic(\'$set\', val);\n\n      // Update embedded document parent references (gh-5189)\n      if (val.isMongooseDocumentArray) {\n        val.forEach(function(item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      }\n\n      // Small hack for gh-1638: if we\'re overwriting the entire array, ignore\n      // paths that were modified before the array overwrite\n      this.$__.activePaths.forEach(function(modifiedPath) {\n        if (modifiedPath.indexOf(path + \'.\') === 0) {\n          _this.$__.activePaths.ignore(modifiedPath);\n        }\n      });\n    }\n  }\n\n  var obj = this._doc;\n  var i = 0;\n  var l = parts.length;\n  var cur = \'\';\n\n  for (; i < l; i++) {\n    var next = i + 1;\n    var last = next === l;\n    cur += (cur ? \'.\' + parts[i] : parts[i]);\n\n    if (last) {\n      obj[parts[i]] = val;\n    } else {\n      if (obj[parts[i]] && utils.getFunctionName(obj[parts[i]].constructor) === \'Object\') {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        this.set(cur, {});\n        obj = obj[parts[i]];\n      }\n    }\n  }\n}',
  name: '111',
  isNew: 'false',
  unmarkModified: 'function (path) {\n  this.$__.activePaths.init(path);\n}',
  validateSync: 'function (pathsToValidate) {\n  var _this = this;\n\n  if (typeof pathsToValidate === \'string\') {\n    pathsToValidate = pathsToValidate.split(\' \');\n  }\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (pathsToValidate && pathsToValidate.length) {\n    var tmp = [];\n    for (var i = 0; i < paths.length; ++i) {\n      if (pathsToValidate.indexOf(paths[i]) !== -1) {\n        tmp.push(paths[i]);\n      }\n    }\n    paths = tmp;\n  }\n\n  var validating = {};\n\n  paths.forEach(function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n\n    var p = _this.schema.path(path);\n    if (!p) {\n      return;\n    }\n    if (!_this.$isValid(path)) {\n      return;\n    }\n\n    var val = _this.getValue(path);\n    var err = p.doValidateSync(val, _this);\n    if (err) {\n      _this.invalidate(path, err, undefined, true);\n    }\n  });\n\n  var err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n  _this.emit(\'validate\', _this);\n  _this.constructor.emit(\'validate\', _this);\n\n  if (err) {\n    for (var key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n}',
  errors: 'undefined',
  addListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  setValue: 'function (path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n}',
  '$__where': 'function _where(where) {\n  where || (where = {});\n\n  var paths,\n      len;\n\n  if (!where._id) {\n    where._id = this._doc._id;\n  }\n\n  if (this.$__.shardval) {\n    paths = Object.keys(this.$__.shardval);\n    len = paths.length;\n\n    for (var i = 0; i < len; ++i) {\n      where[paths[i]] = this.$__.shardval[paths[i]];\n    }\n  }\n\n  if (this._doc._id == null) {\n    return new Error(\'No _id found on document!\');\n  }\n\n  return where;\n}',
  invalidate: 'function (path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === \'string\') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || \'user defined\',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.errors[path] = err;\n  return this.$__.validationError;\n}',
  execPopulate: 'function () {\n  var Promise = PromiseProvider.get();\n  var _this = this;\n  return new Promise.ES6(function(resolve, reject) {\n    _this.populate(function(error, res) {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(res);\n      }\n    });\n  });\n}',
  isSelected: 'function isSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    i = paths.length;\n    var pathDot = path + \'.\';\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n\n      if (cur.indexOf(pathDot) === 0) {\n        return inclusive || cur !== pathDot;\n      }\n\n      if (pathDot.indexOf(cur + \'.\') === 0) {\n        return inclusive;\n      }\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  toString: 'function () {\n  return inspect(this.inspect());\n}',
  toJSON: 'function (options) {\n  return this.$toObject(options, true);\n}',
  '$__handleReject': 'function handleReject(err) {\n  // emit on the Model if listening\n  if (this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  } else if (this.constructor.listeners && this.constructor.listeners(\'error\').length) {\n    this.constructor.emit(\'error\', err);\n  } else if (this.listeners && this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  }\n}' }
[2017-05-04 16:15:40.193] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:15:40.205] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:15:40.207] [INFO] app - Redis client default is ready {}
[2017-05-04 16:15:40.398] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:15:43.252] [DEBUG] app - 2017-5-4 16:15:43 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:15:43.256] [WARN] console - this is a logger middleware.
[2017-05-04 16:15:43.280] [WARN] console - { '$post': 'function (name, isAsync, fn) {\n    if (arguments.length === 2) {\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , posts = proto._posts = proto._posts || {};\n    \n    this._lazySetupHooks(proto, name);\n    (posts[name] = posts[name] || []).push(fn);\n    return this;\n  }',
  getValue: 'function (path) {\n  return utils.getValue(path, this._doc);\n}',
  '$__handleSave': 'function (options, callback) {\n  var _this = this;\n  var i;\n  var keys;\n  var len;\n  if (!options.safe && this.schema.options.safe) {\n    options.safe = this.schema.options.safe;\n  }\n  if (typeof options.safe === \'boolean\') {\n    options.safe = null;\n  }\n\n  if (this.isNew) {\n    // send entire doc\n    var toObjectOptions = {};\n\n    toObjectOptions.retainKeyOrder = this.schema.options.retainKeyOrder;\n    toObjectOptions.depopulate = 1;\n    toObjectOptions._skipDepopulateTopLevel = true;\n    toObjectOptions.transform = false;\n    toObjectOptions.flattenDecimals = false;\n\n    var obj = this.toObject(toObjectOptions);\n\n    if (!utils.object.hasOwnProperty(obj || {}, \'_id\')) {\n      // documents must have an _id else mongoose won\'t know\n      // what to update later if more changes are made. the user\n      // wouldn\'t know what _id was generated by mongodb either\n      // nor would the ObjectId generated my mongodb necessarily\n      // match the schema definition.\n      setTimeout(function() {\n        callback(new Error(\'document must have an _id before saving\'));\n      }, 0);\n      return;\n    }\n\n    this.$__version(true, obj);\n    this.collection.insert(obj, options.safe, function(err, ret) {\n      if (err) {\n        _this.isNew = true;\n        _this.emit(\'isNew\', true);\n        _this.constructor.emit(\'isNew\', true);\n\n        callback(err);\n        return;\n      }\n\n      callback(null, ret);\n    });\n    this.$__reset();\n    this.isNew = false;\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n    // Make it possible to retry the insert\n    this.$__.inserting = true;\n  } else {\n    // Make sure we don\'t treat it as a new object on error,\n    // since it already exists\n    this.$__.inserting = false;\n\n    var delta = this.$__delta();\n\n    if (delta) {\n      if (delta instanceof Error) {\n        callback(delta);\n        return;\n      }\n\n      var where = this.$__where(delta[0]);\n      if (where instanceof Error) {\n        callback(where);\n        return;\n      }\n\n      if (this.$where) {\n        keys = Object.keys(this.$where);\n        len = keys.length;\n        for (i = 0; i < len; ++i) {\n          where[keys[i]] = this.$where[keys[i]];\n        }\n      }\n\n      this.collection.update(where, delta[1], options.safe, function(err, ret) {\n        if (err) {\n          callback(err);\n          return;\n        }\n        ret.$where = where;\n        callback(null, ret);\n      });\n    } else {\n      this.$__reset();\n      callback();\n      return;\n    }\n\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n  }\n}',
  '$__buildDoc': 'function (obj, fields, skipId) {\n  var doc = {};\n  var exclude = null;\n  var keys;\n  var ki;\n  var _this = this;\n\n  // determine if this doc is a result of a query with\n  // excluded fields\n\n  if (fields && utils.getFunctionName(fields.constructor) === \'Object\') {\n    keys = Object.keys(fields);\n    ki = keys.length;\n\n    if (ki === 1 && keys[0] === \'_id\') {\n      exclude = !!fields[keys[ki]];\n    } else {\n      while (ki--) {\n        if (keys[ki] !== \'_id\' &&\n            (!fields[keys[ki]] || typeof fields[keys[ki]] !== \'object\')) {\n          exclude = !fields[keys[ki]];\n          break;\n        }\n      }\n    }\n  }\n\n  var paths = Object.keys(this.schema.paths);\n  var plen = paths.length;\n  var ii = 0;\n\n  var hasIncludedChildren = {};\n  if (exclude === false && fields) {\n    keys = Object.keys(fields);\n    for (var j = 0; j < keys.length; ++j) {\n      var parts = keys[j].split(\'.\');\n      var c = [];\n      for (var k = 0; k < parts.length; ++k) {\n        c.push(parts[k]);\n        hasIncludedChildren[c.join(\'.\')] = 1;\n      }\n    }\n  }\n\n  for (; ii < plen; ++ii) {\n    var p = paths[ii];\n\n    if (p === \'_id\') {\n      if (skipId) {\n        continue;\n      }\n      if (obj && \'_id\' in obj) {\n        continue;\n      }\n    }\n\n    var type = this.schema.paths[p];\n    var path = p.split(\'.\');\n    var len = path.length;\n    var last = len - 1;\n    var curPath = \'\';\n    var doc_ = doc;\n    var i = 0;\n    var included = false;\n\n    for (; i < len; ++i) {\n      var piece = path[i],\n          def;\n\n      curPath += (!curPath.length ? \'\' : \'.\') + piece;\n\n      // support excluding intermediary levels\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i === last) {\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          } else if (included) {\n            // selected field\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          }\n        } else {\n          def = type.getDefault(_this, false);\n          if (typeof def !== \'undefined\') {\n            doc_[piece] = def;\n            _this.$__.activePaths.default(p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  return doc;\n}',
  '$ignore': 'function (path) {\n  this.$__.activePaths.ignore(path);\n}',
  removePre: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , pres = proto._pres || (proto._pres || {});\n    if (!pres[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all pre callbacks for hook `name`\n      pres[name].length = 0;\n    } else {\n      pres[name] = pres[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  collection: '[object Object]',
  emit: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  createdAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  '$__version': 'function (where, delta) {\n  var key = this.schema.options.versionKey;\n\n  if (where === true) {\n    // this is an insert\n    if (key) this.setValue(key, delta[key] = 0);\n    return;\n  }\n\n  // updates\n\n  // only apply versioning if our versionKey was selected. else\n  // there is no way to select the correct version. we could fail\n  // fast here and force them to include the versionKey but\n  // thats a bit intrusive. can we do this automatically?\n  if (!this.isSelected(key)) {\n    return;\n  }\n\n  // $push $addToSet don\'t need the where clause set\n  if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {\n    where[key] = this.getValue(key);\n  }\n\n  if (VERSION_INC === (VERSION_INC & this.$__.version)) {\n    if (!delta.$set || typeof delta.$set[key] === \'undefined\') {\n      delta.$inc || (delta.$inc = {});\n      delta.$inc[key] = 1;\n    }\n  }\n}',
  '$isMongooseModelPrototype': 'true',
  set: 'function (path, val, type, options) {\n  if (type && utils.getFunctionName(type.constructor) === \'Object\') {\n    options = type;\n    type = undefined;\n  }\n\n  var merge = options && options.merge,\n      adhoc = type && type !== true,\n      constructing = type === true,\n      adhocs;\n\n  var strict = options && \'strict\' in options\n      ? options.strict\n      : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  if (typeof path !== \'string\') {\n    // new Document({ key: val })\n\n    if (path === null || path === void 0) {\n      var _ = path;\n      path = val;\n      val = _;\n    } else {\n      var prefix = val\n          ? val + \'.\'\n          : \'\';\n\n      if (path instanceof Document) {\n        if (path.$__isNested) {\n          path = path.toObject();\n        } else {\n          path = path._doc;\n        }\n      }\n\n      var keys = Object.keys(path);\n      var len = keys.length;\n      var i = 0;\n      var pathtype;\n      var key;\n\n      if (len === 0 && !this.schema.options.minimize) {\n        if (val) {\n          this.set(val, {});\n        }\n        return this;\n      }\n\n      if (this.schema.options.retainKeyOrder) {\n        while (i < len) {\n          _handleIndex.call(this, i++);\n        }\n      } else {\n        while (len--) {\n          _handleIndex.call(this, len);\n        }\n      }\n\n      return this;\n    }\n  }\n\n  function _handleIndex(i) {\n    key = keys[i];\n    var pathName = prefix + key;\n    pathtype = this.schema.pathType(pathName);\n\n    if (path[key] !== null\n        && path[key] !== void 0\n          // need to know if plain object - no Buffer, ObjectId, ref, etc\n        && utils.isObject(path[key])\n        && (!path[key].constructor || utils.getFunctionName(path[key].constructor) === \'Object\')\n        && pathtype !== \'virtual\'\n        && pathtype !== \'real\'\n        && !(this.$__path(pathName) instanceof MixedSchema)\n        && !(this.schema.paths[pathName] &&\n        this.schema.paths[pathName].options &&\n        this.schema.paths[pathName].options.ref)) {\n      this.set(path[key], prefix + key, constructing);\n    } else if (strict) {\n      // Don\'t overwrite defaults with undefined keys (gh-3981)\n      if (constructing && path[key] === void 0 &&\n          this.get(key) !== void 0) {\n        return;\n      }\n\n      if (pathtype === \'real\' || pathtype === \'virtual\') {\n        // Check for setting single embedded schema to document (gh-3535)\n        var p = path[key];\n        if (this.schema.paths[pathName] &&\n            this.schema.paths[pathName].$isSingleNested &&\n            path[key] instanceof Document) {\n          p = p.toObject({ virtuals: false, transform: false });\n        }\n        this.set(prefix + key, p, constructing);\n      } else if (pathtype === \'nested\' && path[key] instanceof Document) {\n        this.set(prefix + key,\n            path[key].toObject({transform: false}), constructing);\n      } else if (strict === \'throw\') {\n        if (pathtype === \'nested\') {\n          throw new ObjectExpectedError(key, path[key]);\n        } else {\n          throw new StrictModeError(key);\n        }\n      }\n    } else if (path[key] !== void 0) {\n      this.set(prefix + key, path[key], constructing);\n    }\n  }\n\n  var pathType = this.schema.pathType(path);\n  if (pathType === \'nested\' && val) {\n    if (utils.isObject(val) &&\n        (!val.constructor || utils.getFunctionName(val.constructor) === \'Object\')) {\n      if (!merge) {\n        this.setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      }\n\n      if (Object.keys(val).length === 0) {\n        this.setValue(path, {});\n        this.markModified(path);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        this.set(val, path, constructing);\n      }\n      return this;\n    }\n    this.invalidate(path, new MongooseError.CastError(\'Object\', val, path));\n    return this;\n  }\n\n  var schema;\n  var parts = path.split(\'.\');\n\n  if (pathType === \'adhocOrUndefined\' && strict) {\n    // check for roots that are Mixed types\n    var mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      var subpath = parts.slice(0, i + 1).join(\'.\');\n      schema = this.schema.path(subpath);\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n\n      // If path is underneath a virtual, bypass everything and just set it.\n      if (i + 1 < parts.length && this.schema.pathType(subpath) === \'virtual\') {\n        mpath.set(path, val, this);\n        return this;\n      }\n    }\n\n    if (!mixed) {\n      if (strict === \'throw\') {\n        throw new StrictModeError(path);\n      }\n      return this;\n    }\n  } else if (pathType === \'virtual\') {\n    schema = this.schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  var pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: "LEFT_SUBFIELD only supports Object"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    for (i = 0; i < parts.length; ++i) {\n      subpath = parts.slice(0, i + 1).join(\'.\');\n      if (this.isDirectModified(subpath) // earlier prefixes that are already\n            // marked as dirty have precedence\n          || this.get(subpath) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n\n  // if this doc is being constructed we should not trigger getters\n  var priorVal = constructing\n      ? undefined\n      : this.getValue(path);\n\n  if (!schema) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n    return this;\n  }\n\n  var shouldSet = true;\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    var didPopulate = false;\n    if (schema.options &&\n        schema.options.ref &&\n        val instanceof Document &&\n        (schema.options.ref === val.constructor.modelName || schema.options.ref === val.constructor.baseModelName)) {\n      if (this.ownerDocument) {\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val._id, {model: val.constructor});\n      } else {\n        this.populated(path, val._id, {model: val.constructor});\n      }\n      didPopulate = true;\n    }\n\n    var popOpts;\n    if (schema.options &&\n        Array.isArray(schema.options.type) &&\n        schema.options.type.length &&\n        schema.options.type[0].ref &&\n        Array.isArray(val) &&\n        val.length > 0 &&\n        val[0] instanceof Document &&\n        val[0].constructor.modelName &&\n        (schema.options.type[0].ref === val[0].constructor.baseModelName || schema.options.type[0].ref === val[0].constructor.modelName)) {\n      if (this.ownerDocument) {\n        popOpts = { model: val[0].constructor };\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val.map(function(v) { return v._id; }), popOpts);\n      } else {\n        popOpts = { model: val[0].constructor };\n        this.populated(path, val.map(function(v) { return v._id; }), popOpts);\n      }\n      didPopulate = true;\n    }\n    val = schema.applySetters(val, this, false, priorVal);\n\n    if (!didPopulate && this.$__.populated) {\n      delete this.$__.populated[path];\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    this.invalidate(path,\n      new MongooseError.CastError(schema.instance, val, path, e));\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n}',
  modifiedPaths: 'function () {\n  var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n  return directModifiedPaths.reduce(function(list, path) {\n    var parts = path.split(\'.\');\n    return list.concat(parts.reduce(function(chains, part, i) {\n      return chains.concat(parts.slice(0, i).concat(part).join(\'.\'));\n    }, []).filter(function(chain) {\n      return (list.indexOf(chain) === -1);\n    }));\n  }, []);\n}',
  get: 'function (path, type) {\n  var adhoc;\n  if (type) {\n    adhoc = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  var schema = this.$__path(path) || this.schema.virtualpath(path),\n      pieces = path.split(\'.\'),\n      obj = this._doc;\n\n  for (var i = 0, l = pieces.length; i < l; i++) {\n    obj = obj === null || obj === void 0\n        ? undefined\n        : obj[pieces[i]];\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  // Check if this path is populated - don\'t apply getters if it is,\n  // because otherwise its a nested object. See gh-3357\n  if (schema && !this.populated(path)) {\n    obj = schema.applyGetters(obj, this);\n  }\n\n  return obj;\n}',
  updatedAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  '$__path': 'function (path) {\n  var adhocs = this.$__.adhocPaths,\n      adhocType = adhocs && adhocs[path];\n\n  if (adhocType) {\n    return adhocType;\n  }\n  return this.schema.path(path);\n}',
  '$__save': 'function (options, callback) {\n  var _this = this;\n\n  _this.$__handleSave(options, function(error, result) {\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.$__reset();\n    _this.$__storeShard();\n\n    var numAffected = 0;\n    if (result) {\n      if (Array.isArray(result)) {\n        numAffected = result.length;\n      } else if (result.result && result.result.n !== undefined) {\n        numAffected = result.result.n;\n      } else if (result.result && result.result.nModified !== undefined) {\n        numAffected = result.result.nModified;\n      } else {\n        numAffected = result;\n      }\n    }\n\n    // was this an update that required a version bump?\n    if (_this.$__.version && !_this.$__.inserting) {\n      var doIncrement = VERSION_INC === (VERSION_INC & _this.$__.version);\n      _this.$__.version = undefined;\n\n      if (numAffected <= 0) {\n        // the update failed. pass an error back\n        var err = new VersionError(_this);\n        return callback(err);\n      }\n\n      // increment version if was successful\n      if (doIncrement) {\n        var key = _this.schema.options.versionKey;\n        var version = _this.getValue(key) | 0;\n        _this.setValue(key, version + 1);\n      }\n    }\n\n    if (_this.schema.options &&\n        _this.schema.options.saveErrorIfNotFound &&\n        numAffected <= 0) {\n      error = new DocumentNotFoundError(result.$where);\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.emit(\'save\', _this, numAffected);\n    _this.constructor.emit(\'save\', _this, numAffected);\n    callback(null, _this, numAffected);\n  });\n}',
  '$__delta': 'function () {\n  var dirty = this.$__dirty();\n  if (!dirty.length && VERSION_ALL !== this.$__.version) return;\n\n  var where = {},\n      delta = {},\n      len = dirty.length,\n      divergent = [],\n      d = 0;\n\n  where._id = this._doc._id;\n  if (where._id.toObject) {\n    where._id = where._id.toObject({ transform: false, depopulate: true });\n  }\n\n  for (; d < len; ++d) {\n    var data = dirty[d];\n    var value = data.value;\n\n    var match = checkDivergentArray(this, data.path, value);\n    if (match) {\n      divergent.push(match);\n      continue;\n    }\n\n    var pop = this.populated(data.path, true);\n    if (!pop && this.$__.selected) {\n      // If any array was selected using an $elemMatch projection, we alter the path and where clause\n      // NOTE: MongoDB only supports projected $elemMatch on top level array.\n      var pathSplit = data.path.split(\'.\');\n      var top = pathSplit[0];\n      if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {\n        // If the selected array entry was modified\n        if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === \'undefined\') {\n          where[top] = this.$__.selected[top];\n          pathSplit[1] = \'$\';\n          data.path = pathSplit.join(\'.\');\n        }\n        // if the selected array was modified in any other way throw an error\n        else {\n          divergent.push(data.path);\n          continue;\n        }\n      }\n    }\n\n    if (divergent.length) continue;\n\n    if (undefined === value) {\n      operand(this, where, delta, data, 1, \'$unset\');\n    } else if (value === null) {\n      operand(this, where, delta, data, null);\n    } else if (value._path && value._atomics) {\n      // arrays and other custom types (support plugins etc)\n      handleAtomics(this, where, delta, data, value);\n    } else if (value._path && Buffer.isBuffer(value)) {\n      // MongooseBuffer\n      value = value.toObject();\n      operand(this, where, delta, data, value);\n    } else {\n      value = utils.clone(value, {depopulate: 1, _isNested: true});\n      operand(this, where, delta, data, value);\n    }\n  }\n\n  if (divergent.length) {\n    return new DivergentArrayError(divergent);\n  }\n\n  if (this.$__.version) {\n    this.$__version(where, delta);\n  }\n\n  return [where, delta];\n}',
  '$__storeShard': 'function () {\n  // backwards compat\n  var key = this.schema.options.shardKey || this.schema.options.shardkey;\n  if (!(key && utils.getFunctionName(key.constructor) === \'Object\')) {\n    return;\n  }\n\n  var orig = this.$__.shardval = {},\n      paths = Object.keys(key),\n      len = paths.length,\n      val;\n\n  for (var i = 0; i < len; ++i) {\n    val = this.getValue(paths[i]);\n    if (isMongooseObject(val)) {\n      orig[paths[i]] = val.toObject({depopulate: true, _isNested: true});\n    } else if (val !== null && val !== undefined && val.valueOf &&\n          // Explicitly don\'t take value of dates\n        (!val.constructor || utils.getFunctionName(val.constructor) !== \'Date\')) {\n      orig[paths[i]] = val.valueOf();\n    } else {\n      orig[paths[i]] = val;\n    }\n  }\n}',
  listeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  depopulate: 'function (path) {\n  var populatedIds = this.populated(path);\n  if (!populatedIds) {\n    return;\n  }\n  delete this.$__.populated[path];\n  this.set(path, populatedIds);\n  return this;\n}',
  equals: 'function (doc) {\n  if (!doc) {\n    return false;\n  }\n\n  var tid = this.get(\'_id\');\n  var docid = doc.get ? doc.get(\'_id\') : doc;\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals\n      ? tid.equals(docid)\n      : tid === docid;\n}',
  _posts: '[object Object]',
  '$__getAllSubdocs': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  function docReducer(seed, path) {\n    var val = this[path];\n\n    if (val instanceof Embedded) {\n      seed.push(val);\n    }\n    if (val && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(docReducer.bind(val._doc), seed);\n      seed.push(val);\n    }\n    if (val && val.isMongooseDocumentArray) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n        seed = Object.keys(doc._doc).reduce(docReducer.bind(doc._doc), seed);\n      });\n    } else if (val instanceof Document && val.$__isNested) {\n      if (val) {\n        seed = Object.keys(val).reduce(docReducer.bind(val), seed);\n      }\n    }\n    return seed;\n  }\n\n  var subDocs = Object.keys(this._doc).reduce(docReducer.bind(this), []);\n\n  return subDocs;\n}',
  '$__original_save': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  removeListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  '$__getArrayPathsToValidate': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  // validate all document arrays.\n  return this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return this.getValue(i);\n  }.bind(this))\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  }).reduce(function(seed, array) {\n    return seed.concat(array);\n  }, [])\n  .filter(function(doc) {\n    return doc;\n  });\n}',
  schema: '[object Object]',
  removeAllListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  save: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  isDirectSelected: 'function isDirectSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  removePost: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , posts = proto._posts || (proto._posts || {});\n    if (!posts[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all post callbacks for hook `name`\n      posts[name].length = 0;\n    } else {\n      posts[name] = posts[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  _lazySetupHooks: 'function (proto, methodName, errorCb) {\n    if (\'undefined\' === typeof proto[methodName].numAsyncPres) {\n      this.$hook(methodName, proto[methodName], errorCb);\n    }\n  }',
  toBSON: 'function () {\n  return this.toObject({\n    transform: false,\n    virtuals: false,\n    _skipDepopulateTopLevel: true,\n    depopulate: true,\n    flattenDecimals: false\n  });\n}',
  markModified: 'function (path) {\n  this.$__.activePaths.modify(path);\n}',
  on: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  increment: 'function increment() {\n  this.$__.version = VERSION_ALL;\n  return this;\n}',
  validate: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populated: 'function (path, val, options) {\n  // val and options are internal\n\n  if (val === null || val === void 0) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    var v = this.$__.populated[path];\n    if (v) {\n      return v.value;\n    }\n    return undefined;\n  }\n\n  // internal\n\n  if (val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    return this.$__.populated[path];\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = {value: val, options: options};\n  return val;\n}',
  update: 'function update() {\n  var args = utils.args(arguments);\n  args.unshift({_id: this._id});\n  return this.constructor.update.apply(this.constructor, args);\n}',
  id: '5902b753c5756d72945d90b3',
  '$__setSchema': 'function (schema) {\n  compile(schema.tree, this, undefined, schema.options);\n  this.schema = schema;\n}',
  isInit: 'function (path) {\n  return (path in this.$__.activePaths.states.init);\n}',
  '$__validate': 'function (callback) {\n  var _this = this;\n  var _complete = function() {\n    var err = _this.$__.validationError;\n    _this.$__.validationError = undefined;\n    _this.emit(\'validate\', _this);\n    _this.constructor.emit(\'validate\', _this);\n    if (err) {\n      for (var key in err.errors) {\n        // Make sure cast errors persist\n        if (!_this.__parent && err.errors[key] instanceof MongooseError.CastError) {\n          _this.invalidate(key, err.errors[key]);\n        }\n      }\n\n      return err;\n    }\n  };\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (paths.length === 0) {\n    process.nextTick(function() {\n      var error = _complete();\n      if (error) {\n        return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n          callback(error);\n        });\n      }\n      callback();\n    });\n  }\n\n  var validating = {},\n      total = 0;\n\n  var complete = function() {\n    var error = _complete();\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n    callback();\n  };\n\n  var validatePath = function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n    total++;\n\n    process.nextTick(function() {\n      var p = _this.schema.path(path);\n      if (!p) {\n        return --total || complete();\n      }\n\n      // If user marked as invalid or there was a cast error, don\'t validate\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      var val = _this.getValue(path);\n      p.doValidate(val, function(err) {\n        if (err) {\n          _this.invalidate(path, err, undefined, true);\n        }\n        --total || complete();\n      }, _this);\n    });\n  };\n\n  paths.forEach(validatePath);\n}',
  db: '[object Object]',
  username: '222',
  '$__original_validate': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  discriminators: 'undefined',
  isModified: 'function (paths) {\n  if (paths) {\n    if (!Array.isArray(paths)) {\n      paths = paths.split(\' \');\n    }\n    var modified = this.modifiedPaths();\n    var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n    var isModifiedChild = paths.some(function(path) {\n      return !!~modified.indexOf(path);\n    });\n    return isModifiedChild || paths.some(function(path) {\n      return directModifiedPaths.some(function(mod) {\n        return mod === path || path.indexOf(mod + \'.\') === 0;\n      });\n    });\n  }\n  return this.$__.activePaths.some(\'modify\');\n}',
  '$pre': 'function (name, isAsync, fn, errorCb) {\n    if (\'boolean\' !== typeof arguments[1]) {\n      errorCb = fn;\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {};\n\n    this._lazySetupHooks(proto, name, errorCb);\n\n    if (fn.isAsync = isAsync) {\n      proto[name].numAsyncPres++;\n    }\n\n    (pres[name] = pres[name] || []).push(fn);\n    return this;\n  }',
  toObject: 'function (options) {\n  return this.$toObject(options);\n}',
  '$markValid': 'function (path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n}',
  '$isValid': 'function (path) {\n  return !this.$__.validationError || !this.$__.validationError.errors[path];\n}',
  isDirectModified: 'function (path) {\n  return (path in this.$__.activePaths.states.modify);\n}',
  '$__dirty': 'function () {\n  var _this = this;\n\n  var all = this.$__.activePaths.map(\'modify\', function(path) {\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  });\n\n  // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n  all = all.concat(this.$__.activePaths.map(\'default\', function(path) {\n    if (path === \'_id\' || !_this.getValue(path)) {\n      return;\n    }\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n\n  // Sort dirty paths in a flat hierarchy.\n  all.sort(function(a, b) {\n    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));\n  });\n\n  // Ignore "foo.a" if "foo" is dirty already.\n  var minimal = [],\n      lastPath,\n      top;\n\n  all.forEach(function(item) {\n    if (!item) {\n      return;\n    }\n    if (item.path.indexOf(lastPath) !== 0) {\n      lastPath = item.path + \'.\';\n      minimal.push(item);\n      top = item;\n    } else {\n      // special case for top level MongooseArrays\n      if (top.value && top.value._atomics && top.value.hasAtomics()) {\n        // the `top` array itself and a sub path of `top` are being modified.\n        // the only way to honor all of both modifications is through a $set\n        // of entire array.\n        top.value._atomics = {};\n        top.value._atomics.$set = top.value;\n      }\n    }\n  });\n\n  top = lastPath = null;\n  return minimal;\n}',
  model: 'function model(name) {\n  return this.db.model(name);\n}',
  '$isDefault': 'function (path) {\n  return (path in this.$__.activePaths.states.default);\n}',
  '$__original_remove': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  remove: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populate: 'function populate() {\n  if (arguments.length === 0) {\n    return this;\n  }\n\n  var pop = this.$__.populate || (this.$__.populate = {});\n  var args = utils.args(arguments);\n  var fn;\n\n  if (typeof args[args.length - 1] === \'function\') {\n    fn = args.pop();\n  }\n\n  // allow `doc.populate(callback)`\n  if (args.length) {\n    // use hash to remove duplicate paths\n    var res = utils.populate.apply(null, args);\n    for (var i = 0; i < res.length; ++i) {\n      pop[res[i].path] = res[i];\n    }\n  }\n\n  if (fn) {\n    var paths = utils.object.vals(pop);\n    this.$__.populate = undefined;\n    paths.__noPromise = true;\n    this.constructor.populate(this, paths, fn);\n  }\n\n  return this;\n}',
  '$__shouldModify': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  if (this.isNew) {\n    return true;\n  }\n\n  if (undefined === val && !this.isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (undefined === val && path in this.$__.activePaths.states.default) {\n    // we\'re just unsetting the default value which was never saved\n    return false;\n  }\n\n  // gh-3992: if setting a populated field to a doc, don\'t mark modified\n  // if they have the same _id\n  if (this.populated(path) &&\n      val instanceof Document &&\n      deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal || this.get(path))) {\n    return true;\n  }\n\n  if (!constructing &&\n      val !== null &&\n      val !== undefined &&\n      path in this.$__.activePaths.states.default &&\n      deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n  return false;\n}',
  '$__': '[object Object]',
  '$__fullPath': 'function (path) {\n  // overridden in SubDocuments\n  return path || \'\';\n}',
  _pres: '[object Object]',
  inspect: 'function (options) {\n  var isPOJO = options &&\n    utils.getFunctionName(options.constructor) === \'Object\';\n  var opts;\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n    opts.retainKeyOrder = true;\n  }\n  return this.toObject(opts);\n}',
  '$__reset': 'function reset() {\n  var _this = this;\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return _this.getValue(i);\n  })\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  })\n  .forEach(function(array) {\n    var i = array.length;\n    while (i--) {\n      var doc = array[i];\n      if (!doc) {\n        continue;\n      }\n      doc.$__reset();\n    }\n  });\n\n  // clear atomics\n  this.$__dirty().forEach(function(dirt) {\n    var type = dirt.value;\n    if (type && type._atomics) {\n      type._atomics = {};\n    }\n  });\n\n  // Clear \'dirty\' cache\n  this.$__.activePaths.clear(\'modify\');\n  this.$__.activePaths.clear(\'default\');\n  this.$__.validationError = undefined;\n  this.errors = undefined;\n  _this = this;\n  this.schema.requiredPaths().forEach(function(path) {\n    _this.$__.activePaths.require(path);\n  });\n\n  return this;\n}',
  init: 'function (doc, opts, fn) {\n  // do not prefix this method with $__ since its\n  // used by public hooks\n\n  if (typeof opts === \'function\') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.isNew = false;\n\n  // handle docs with populated paths\n  // If doc._id is not null or undefined\n  if (doc._id !== null && doc._id !== undefined &&\n    opts && opts.populated && opts.populated.length) {\n    var id = String(doc._id);\n    for (var i = 0; i < opts.populated.length; ++i) {\n      var item = opts.populated[i];\n      if (item.isVirtual) {\n        this.populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.populated(item.path, item._docs[id], item);\n      }\n    }\n  }\n\n  init(this, doc, this._doc);\n  this.$__storeShard();\n\n  this.emit(\'init\', this);\n  this.constructor.emit(\'init\', this);\n\n  if (fn) {\n    fn(null);\n  }\n  return this;\n}',
  setMaxListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  initializeTimestamps: 'function () {\n      if (!this.get(createdAt)) {\n        this.set(createdAt, new Date());\n      }\n      if (!this.get(updatedAt)) {\n        this.set(updatedAt, new Date());\n      }\n      return this;\n    }',
  once: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  __v: '0',
  '$toObject': 'function (options, json) {\n  var defaultOptions = {\n    transform: true,\n    json: json,\n    retainKeyOrder: this.schema.options.retainKeyOrder,\n    flattenDecimals: true\n  };\n\n  // _isNested will only be true if this is not the top level document, we\n  // should never depopulate\n  if (options && options.depopulate && options._isNested && this.$__.wasPopulated) {\n    // populated paths that we set to a document\n    return clone(this._id, options);\n  }\n\n  // When internally saving this document we always pass options,\n  // bypassing the custom schema options.\n  if (!(options && utils.getFunctionName(options.constructor) === \'Object\') ||\n      (options && options._useSchemaOptions)) {\n    if (json) {\n      options = this.schema.options.toJSON ?\n        clone(this.schema.options.toJSON) :\n        {};\n      options.json = true;\n      options._useSchemaOptions = true;\n    } else {\n      options = this.schema.options.toObject ?\n        clone(this.schema.options.toObject) :\n        {};\n      options.json = false;\n      options._useSchemaOptions = true;\n    }\n  }\n\n  for (var key in defaultOptions) {\n    if (options[key] === undefined) {\n      options[key] = defaultOptions[key];\n    }\n  }\n\n  (\'minimize\' in options) || (options.minimize = this.schema.options.minimize);\n\n  // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n  var originalTransform = options.transform;\n\n  options._isNested = true;\n\n  var ret = clone(this._doc, options) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, \'paths\', options);\n    // applyGetters for paths will add nested empty objects;\n    // if minimize is set, we need to remove them.\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || options.getters && options.virtuals !== false) {\n    applyGetters(this, ret, \'virtuals\', options);\n  }\n\n  if (options.versionKey === false && this.schema.options.versionKey) {\n    delete ret[this.schema.options.versionKey];\n  }\n\n  var transform = options.transform;\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema\'s transform and\n  // not the parent schema\'s\n  if (transform === true ||\n      (this.schema.options.toObject && transform)) {\n    var opts = options.json ? this.schema.options.toJSON : this.schema.options.toObject;\n\n    if (opts) {\n      transform = (typeof options.transform === \'function\' ? options.transform : opts.transform);\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === \'function\') {\n    var xformed = transform(this, ret, options);\n    if (typeof xformed !== \'undefined\') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n}',
  '$hook': 'function (name, fn, errorCb) {\n    if (arguments.length === 1 && typeof name === \'object\') {\n      for (var k in name) { // `name` is a hash of hookName->hookFn\n        this.$hook(k, name[k]);\n      }\n      return;\n    }\n\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {}\n      , posts = proto._posts = proto._posts || {};\n    pres[name] = pres[name] || [];\n    posts[name] = posts[name] || [];\n\n    proto[name] = function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    };\n    \n    proto[name].numAsyncPres = 0;\n\n    return this;\n  }',
  '$__set': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  var shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts,\n    schema, val, priorVal);\n  var _this = this;\n\n  if (shouldModify) {\n    this.markModified(pathToMark, val);\n\n    // handle directly setting arrays (gh-1126)\n    MongooseArray || (MongooseArray = require(\'./types/array\'));\n    if (val && val.isMongooseArray) {\n      val._registerAtomic(\'$set\', val);\n\n      // Update embedded document parent references (gh-5189)\n      if (val.isMongooseDocumentArray) {\n        val.forEach(function(item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      }\n\n      // Small hack for gh-1638: if we\'re overwriting the entire array, ignore\n      // paths that were modified before the array overwrite\n      this.$__.activePaths.forEach(function(modifiedPath) {\n        if (modifiedPath.indexOf(path + \'.\') === 0) {\n          _this.$__.activePaths.ignore(modifiedPath);\n        }\n      });\n    }\n  }\n\n  var obj = this._doc;\n  var i = 0;\n  var l = parts.length;\n  var cur = \'\';\n\n  for (; i < l; i++) {\n    var next = i + 1;\n    var last = next === l;\n    cur += (cur ? \'.\' + parts[i] : parts[i]);\n\n    if (last) {\n      obj[parts[i]] = val;\n    } else {\n      if (obj[parts[i]] && utils.getFunctionName(obj[parts[i]].constructor) === \'Object\') {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        this.set(cur, {});\n        obj = obj[parts[i]];\n      }\n    }\n  }\n}',
  name: '111',
  isNew: 'false',
  unmarkModified: 'function (path) {\n  this.$__.activePaths.init(path);\n}',
  validateSync: 'function (pathsToValidate) {\n  var _this = this;\n\n  if (typeof pathsToValidate === \'string\') {\n    pathsToValidate = pathsToValidate.split(\' \');\n  }\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (pathsToValidate && pathsToValidate.length) {\n    var tmp = [];\n    for (var i = 0; i < paths.length; ++i) {\n      if (pathsToValidate.indexOf(paths[i]) !== -1) {\n        tmp.push(paths[i]);\n      }\n    }\n    paths = tmp;\n  }\n\n  var validating = {};\n\n  paths.forEach(function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n\n    var p = _this.schema.path(path);\n    if (!p) {\n      return;\n    }\n    if (!_this.$isValid(path)) {\n      return;\n    }\n\n    var val = _this.getValue(path);\n    var err = p.doValidateSync(val, _this);\n    if (err) {\n      _this.invalidate(path, err, undefined, true);\n    }\n  });\n\n  var err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n  _this.emit(\'validate\', _this);\n  _this.constructor.emit(\'validate\', _this);\n\n  if (err) {\n    for (var key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n}',
  errors: 'undefined',
  addListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  setValue: 'function (path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n}',
  '$__where': 'function _where(where) {\n  where || (where = {});\n\n  var paths,\n      len;\n\n  if (!where._id) {\n    where._id = this._doc._id;\n  }\n\n  if (this.$__.shardval) {\n    paths = Object.keys(this.$__.shardval);\n    len = paths.length;\n\n    for (var i = 0; i < len; ++i) {\n      where[paths[i]] = this.$__.shardval[paths[i]];\n    }\n  }\n\n  if (this._doc._id == null) {\n    return new Error(\'No _id found on document!\');\n  }\n\n  return where;\n}',
  invalidate: 'function (path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === \'string\') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || \'user defined\',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.errors[path] = err;\n  return this.$__.validationError;\n}',
  _doc: '[object Object]',
  execPopulate: 'function () {\n  var Promise = PromiseProvider.get();\n  var _this = this;\n  return new Promise.ES6(function(resolve, reject) {\n    _this.populate(function(error, res) {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(res);\n      }\n    });\n  });\n}',
  isSelected: 'function isSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    i = paths.length;\n    var pathDot = path + \'.\';\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n\n      if (cur.indexOf(pathDot) === 0) {\n        return inclusive || cur !== pathDot;\n      }\n\n      if (pathDot.indexOf(cur + \'.\') === 0) {\n        return inclusive;\n      }\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  _id: '5902b753c5756d72945d90b3',
  toString: 'function () {\n  return inspect(this.inspect());\n}',
  toJSON: 'function (options) {\n  return this.$toObject(options, true);\n}',
  '$__handleReject': 'function handleReject(err) {\n  // emit on the Model if listening\n  if (this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  } else if (this.constructor.listeners && this.constructor.listeners(\'error\').length) {\n    this.constructor.emit(\'error\', err);\n  } else if (this.listeners && this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  }\n}' }
[2017-05-04 16:16:04.989] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:16:05.010] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:16:05.016] [INFO] app - Redis client default is ready {}
[2017-05-04 16:16:05.234] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:16:06.080] [DEBUG] app - 2017-5-4 16:16:06 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:16:06.083] [WARN] console - this is a logger middleware.
[2017-05-04 16:16:06.113] [WARN] console - { '$ignore': 'function (path) {\n  this.$__.activePaths.ignore(path);\n}',
  removePre: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , pres = proto._pres || (proto._pres || {});\n    if (!pres[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all pre callbacks for hook `name`\n      pres[name].length = 0;\n    } else {\n      pres[name] = pres[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  collection: '[object Object]',
  emit: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  createdAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  '$__version': 'function (where, delta) {\n  var key = this.schema.options.versionKey;\n\n  if (where === true) {\n    // this is an insert\n    if (key) this.setValue(key, delta[key] = 0);\n    return;\n  }\n\n  // updates\n\n  // only apply versioning if our versionKey was selected. else\n  // there is no way to select the correct version. we could fail\n  // fast here and force them to include the versionKey but\n  // thats a bit intrusive. can we do this automatically?\n  if (!this.isSelected(key)) {\n    return;\n  }\n\n  // $push $addToSet don\'t need the where clause set\n  if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {\n    where[key] = this.getValue(key);\n  }\n\n  if (VERSION_INC === (VERSION_INC & this.$__.version)) {\n    if (!delta.$set || typeof delta.$set[key] === \'undefined\') {\n      delta.$inc || (delta.$inc = {});\n      delta.$inc[key] = 1;\n    }\n  }\n}',
  '$isMongooseModelPrototype': 'true',
  set: 'function (path, val, type, options) {\n  if (type && utils.getFunctionName(type.constructor) === \'Object\') {\n    options = type;\n    type = undefined;\n  }\n\n  var merge = options && options.merge,\n      adhoc = type && type !== true,\n      constructing = type === true,\n      adhocs;\n\n  var strict = options && \'strict\' in options\n      ? options.strict\n      : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  if (typeof path !== \'string\') {\n    // new Document({ key: val })\n\n    if (path === null || path === void 0) {\n      var _ = path;\n      path = val;\n      val = _;\n    } else {\n      var prefix = val\n          ? val + \'.\'\n          : \'\';\n\n      if (path instanceof Document) {\n        if (path.$__isNested) {\n          path = path.toObject();\n        } else {\n          path = path._doc;\n        }\n      }\n\n      var keys = Object.keys(path);\n      var len = keys.length;\n      var i = 0;\n      var pathtype;\n      var key;\n\n      if (len === 0 && !this.schema.options.minimize) {\n        if (val) {\n          this.set(val, {});\n        }\n        return this;\n      }\n\n      if (this.schema.options.retainKeyOrder) {\n        while (i < len) {\n          _handleIndex.call(this, i++);\n        }\n      } else {\n        while (len--) {\n          _handleIndex.call(this, len);\n        }\n      }\n\n      return this;\n    }\n  }\n\n  function _handleIndex(i) {\n    key = keys[i];\n    var pathName = prefix + key;\n    pathtype = this.schema.pathType(pathName);\n\n    if (path[key] !== null\n        && path[key] !== void 0\n          // need to know if plain object - no Buffer, ObjectId, ref, etc\n        && utils.isObject(path[key])\n        && (!path[key].constructor || utils.getFunctionName(path[key].constructor) === \'Object\')\n        && pathtype !== \'virtual\'\n        && pathtype !== \'real\'\n        && !(this.$__path(pathName) instanceof MixedSchema)\n        && !(this.schema.paths[pathName] &&\n        this.schema.paths[pathName].options &&\n        this.schema.paths[pathName].options.ref)) {\n      this.set(path[key], prefix + key, constructing);\n    } else if (strict) {\n      // Don\'t overwrite defaults with undefined keys (gh-3981)\n      if (constructing && path[key] === void 0 &&\n          this.get(key) !== void 0) {\n        return;\n      }\n\n      if (pathtype === \'real\' || pathtype === \'virtual\') {\n        // Check for setting single embedded schema to document (gh-3535)\n        var p = path[key];\n        if (this.schema.paths[pathName] &&\n            this.schema.paths[pathName].$isSingleNested &&\n            path[key] instanceof Document) {\n          p = p.toObject({ virtuals: false, transform: false });\n        }\n        this.set(prefix + key, p, constructing);\n      } else if (pathtype === \'nested\' && path[key] instanceof Document) {\n        this.set(prefix + key,\n            path[key].toObject({transform: false}), constructing);\n      } else if (strict === \'throw\') {\n        if (pathtype === \'nested\') {\n          throw new ObjectExpectedError(key, path[key]);\n        } else {\n          throw new StrictModeError(key);\n        }\n      }\n    } else if (path[key] !== void 0) {\n      this.set(prefix + key, path[key], constructing);\n    }\n  }\n\n  var pathType = this.schema.pathType(path);\n  if (pathType === \'nested\' && val) {\n    if (utils.isObject(val) &&\n        (!val.constructor || utils.getFunctionName(val.constructor) === \'Object\')) {\n      if (!merge) {\n        this.setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      }\n\n      if (Object.keys(val).length === 0) {\n        this.setValue(path, {});\n        this.markModified(path);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        this.set(val, path, constructing);\n      }\n      return this;\n    }\n    this.invalidate(path, new MongooseError.CastError(\'Object\', val, path));\n    return this;\n  }\n\n  var schema;\n  var parts = path.split(\'.\');\n\n  if (pathType === \'adhocOrUndefined\' && strict) {\n    // check for roots that are Mixed types\n    var mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      var subpath = parts.slice(0, i + 1).join(\'.\');\n      schema = this.schema.path(subpath);\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n\n      // If path is underneath a virtual, bypass everything and just set it.\n      if (i + 1 < parts.length && this.schema.pathType(subpath) === \'virtual\') {\n        mpath.set(path, val, this);\n        return this;\n      }\n    }\n\n    if (!mixed) {\n      if (strict === \'throw\') {\n        throw new StrictModeError(path);\n      }\n      return this;\n    }\n  } else if (pathType === \'virtual\') {\n    schema = this.schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  var pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: "LEFT_SUBFIELD only supports Object"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    for (i = 0; i < parts.length; ++i) {\n      subpath = parts.slice(0, i + 1).join(\'.\');\n      if (this.isDirectModified(subpath) // earlier prefixes that are already\n            // marked as dirty have precedence\n          || this.get(subpath) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n\n  // if this doc is being constructed we should not trigger getters\n  var priorVal = constructing\n      ? undefined\n      : this.getValue(path);\n\n  if (!schema) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n    return this;\n  }\n\n  var shouldSet = true;\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    var didPopulate = false;\n    if (schema.options &&\n        schema.options.ref &&\n        val instanceof Document &&\n        (schema.options.ref === val.constructor.modelName || schema.options.ref === val.constructor.baseModelName)) {\n      if (this.ownerDocument) {\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val._id, {model: val.constructor});\n      } else {\n        this.populated(path, val._id, {model: val.constructor});\n      }\n      didPopulate = true;\n    }\n\n    var popOpts;\n    if (schema.options &&\n        Array.isArray(schema.options.type) &&\n        schema.options.type.length &&\n        schema.options.type[0].ref &&\n        Array.isArray(val) &&\n        val.length > 0 &&\n        val[0] instanceof Document &&\n        val[0].constructor.modelName &&\n        (schema.options.type[0].ref === val[0].constructor.baseModelName || schema.options.type[0].ref === val[0].constructor.modelName)) {\n      if (this.ownerDocument) {\n        popOpts = { model: val[0].constructor };\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val.map(function(v) { return v._id; }), popOpts);\n      } else {\n        popOpts = { model: val[0].constructor };\n        this.populated(path, val.map(function(v) { return v._id; }), popOpts);\n      }\n      didPopulate = true;\n    }\n    val = schema.applySetters(val, this, false, priorVal);\n\n    if (!didPopulate && this.$__.populated) {\n      delete this.$__.populated[path];\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    this.invalidate(path,\n      new MongooseError.CastError(schema.instance, val, path, e));\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n}',
  modifiedPaths: 'function () {\n  var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n  return directModifiedPaths.reduce(function(list, path) {\n    var parts = path.split(\'.\');\n    return list.concat(parts.reduce(function(chains, part, i) {\n      return chains.concat(parts.slice(0, i).concat(part).join(\'.\'));\n    }, []).filter(function(chain) {\n      return (list.indexOf(chain) === -1);\n    }));\n  }, []);\n}',
  get: 'function (path, type) {\n  var adhoc;\n  if (type) {\n    adhoc = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  var schema = this.$__path(path) || this.schema.virtualpath(path),\n      pieces = path.split(\'.\'),\n      obj = this._doc;\n\n  for (var i = 0, l = pieces.length; i < l; i++) {\n    obj = obj === null || obj === void 0\n        ? undefined\n        : obj[pieces[i]];\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  // Check if this path is populated - don\'t apply getters if it is,\n  // because otherwise its a nested object. See gh-3357\n  if (schema && !this.populated(path)) {\n    obj = schema.applyGetters(obj, this);\n  }\n\n  return obj;\n}',
  updatedAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  '$__path': 'function (path) {\n  var adhocs = this.$__.adhocPaths,\n      adhocType = adhocs && adhocs[path];\n\n  if (adhocType) {\n    return adhocType;\n  }\n  return this.schema.path(path);\n}',
  '$__save': 'function (options, callback) {\n  var _this = this;\n\n  _this.$__handleSave(options, function(error, result) {\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.$__reset();\n    _this.$__storeShard();\n\n    var numAffected = 0;\n    if (result) {\n      if (Array.isArray(result)) {\n        numAffected = result.length;\n      } else if (result.result && result.result.n !== undefined) {\n        numAffected = result.result.n;\n      } else if (result.result && result.result.nModified !== undefined) {\n        numAffected = result.result.nModified;\n      } else {\n        numAffected = result;\n      }\n    }\n\n    // was this an update that required a version bump?\n    if (_this.$__.version && !_this.$__.inserting) {\n      var doIncrement = VERSION_INC === (VERSION_INC & _this.$__.version);\n      _this.$__.version = undefined;\n\n      if (numAffected <= 0) {\n        // the update failed. pass an error back\n        var err = new VersionError(_this);\n        return callback(err);\n      }\n\n      // increment version if was successful\n      if (doIncrement) {\n        var key = _this.schema.options.versionKey;\n        var version = _this.getValue(key) | 0;\n        _this.setValue(key, version + 1);\n      }\n    }\n\n    if (_this.schema.options &&\n        _this.schema.options.saveErrorIfNotFound &&\n        numAffected <= 0) {\n      error = new DocumentNotFoundError(result.$where);\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.emit(\'save\', _this, numAffected);\n    _this.constructor.emit(\'save\', _this, numAffected);\n    callback(null, _this, numAffected);\n  });\n}',
  '$__delta': 'function () {\n  var dirty = this.$__dirty();\n  if (!dirty.length && VERSION_ALL !== this.$__.version) return;\n\n  var where = {},\n      delta = {},\n      len = dirty.length,\n      divergent = [],\n      d = 0;\n\n  where._id = this._doc._id;\n  if (where._id.toObject) {\n    where._id = where._id.toObject({ transform: false, depopulate: true });\n  }\n\n  for (; d < len; ++d) {\n    var data = dirty[d];\n    var value = data.value;\n\n    var match = checkDivergentArray(this, data.path, value);\n    if (match) {\n      divergent.push(match);\n      continue;\n    }\n\n    var pop = this.populated(data.path, true);\n    if (!pop && this.$__.selected) {\n      // If any array was selected using an $elemMatch projection, we alter the path and where clause\n      // NOTE: MongoDB only supports projected $elemMatch on top level array.\n      var pathSplit = data.path.split(\'.\');\n      var top = pathSplit[0];\n      if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {\n        // If the selected array entry was modified\n        if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === \'undefined\') {\n          where[top] = this.$__.selected[top];\n          pathSplit[1] = \'$\';\n          data.path = pathSplit.join(\'.\');\n        }\n        // if the selected array was modified in any other way throw an error\n        else {\n          divergent.push(data.path);\n          continue;\n        }\n      }\n    }\n\n    if (divergent.length) continue;\n\n    if (undefined === value) {\n      operand(this, where, delta, data, 1, \'$unset\');\n    } else if (value === null) {\n      operand(this, where, delta, data, null);\n    } else if (value._path && value._atomics) {\n      // arrays and other custom types (support plugins etc)\n      handleAtomics(this, where, delta, data, value);\n    } else if (value._path && Buffer.isBuffer(value)) {\n      // MongooseBuffer\n      value = value.toObject();\n      operand(this, where, delta, data, value);\n    } else {\n      value = utils.clone(value, {depopulate: 1, _isNested: true});\n      operand(this, where, delta, data, value);\n    }\n  }\n\n  if (divergent.length) {\n    return new DivergentArrayError(divergent);\n  }\n\n  if (this.$__.version) {\n    this.$__version(where, delta);\n  }\n\n  return [where, delta];\n}',
  '$__storeShard': 'function () {\n  // backwards compat\n  var key = this.schema.options.shardKey || this.schema.options.shardkey;\n  if (!(key && utils.getFunctionName(key.constructor) === \'Object\')) {\n    return;\n  }\n\n  var orig = this.$__.shardval = {},\n      paths = Object.keys(key),\n      len = paths.length,\n      val;\n\n  for (var i = 0; i < len; ++i) {\n    val = this.getValue(paths[i]);\n    if (isMongooseObject(val)) {\n      orig[paths[i]] = val.toObject({depopulate: true, _isNested: true});\n    } else if (val !== null && val !== undefined && val.valueOf &&\n          // Explicitly don\'t take value of dates\n        (!val.constructor || utils.getFunctionName(val.constructor) !== \'Date\')) {\n      orig[paths[i]] = val.valueOf();\n    } else {\n      orig[paths[i]] = val;\n    }\n  }\n}',
  listeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  depopulate: 'function (path) {\n  var populatedIds = this.populated(path);\n  if (!populatedIds) {\n    return;\n  }\n  delete this.$__.populated[path];\n  this.set(path, populatedIds);\n  return this;\n}',
  equals: 'function (doc) {\n  if (!doc) {\n    return false;\n  }\n\n  var tid = this.get(\'_id\');\n  var docid = doc.get ? doc.get(\'_id\') : doc;\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals\n      ? tid.equals(docid)\n      : tid === docid;\n}',
  _posts: '[object Object]',
  '$__getAllSubdocs': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  function docReducer(seed, path) {\n    var val = this[path];\n\n    if (val instanceof Embedded) {\n      seed.push(val);\n    }\n    if (val && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(docReducer.bind(val._doc), seed);\n      seed.push(val);\n    }\n    if (val && val.isMongooseDocumentArray) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n        seed = Object.keys(doc._doc).reduce(docReducer.bind(doc._doc), seed);\n      });\n    } else if (val instanceof Document && val.$__isNested) {\n      if (val) {\n        seed = Object.keys(val).reduce(docReducer.bind(val), seed);\n      }\n    }\n    return seed;\n  }\n\n  var subDocs = Object.keys(this._doc).reduce(docReducer.bind(this), []);\n\n  return subDocs;\n}',
  '$__original_save': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  removeListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  '$__getArrayPathsToValidate': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  // validate all document arrays.\n  return this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return this.getValue(i);\n  }.bind(this))\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  }).reduce(function(seed, array) {\n    return seed.concat(array);\n  }, [])\n  .filter(function(doc) {\n    return doc;\n  });\n}',
  schema: '[object Object]',
  removeAllListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  save: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  isDirectSelected: 'function isDirectSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  removePost: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , posts = proto._posts || (proto._posts || {});\n    if (!posts[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all post callbacks for hook `name`\n      posts[name].length = 0;\n    } else {\n      posts[name] = posts[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  _lazySetupHooks: 'function (proto, methodName, errorCb) {\n    if (\'undefined\' === typeof proto[methodName].numAsyncPres) {\n      this.$hook(methodName, proto[methodName], errorCb);\n    }\n  }',
  toBSON: 'function () {\n  return this.toObject({\n    transform: false,\n    virtuals: false,\n    _skipDepopulateTopLevel: true,\n    depopulate: true,\n    flattenDecimals: false\n  });\n}',
  markModified: 'function (path) {\n  this.$__.activePaths.modify(path);\n}',
  on: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  increment: 'function increment() {\n  this.$__.version = VERSION_ALL;\n  return this;\n}',
  validate: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populated: 'function (path, val, options) {\n  // val and options are internal\n\n  if (val === null || val === void 0) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    var v = this.$__.populated[path];\n    if (v) {\n      return v.value;\n    }\n    return undefined;\n  }\n\n  // internal\n\n  if (val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    return this.$__.populated[path];\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = {value: val, options: options};\n  return val;\n}',
  update: 'function update() {\n  var args = utils.args(arguments);\n  args.unshift({_id: this._id});\n  return this.constructor.update.apply(this.constructor, args);\n}',
  id: '5902b753c5756d72945d90b3',
  '$__setSchema': 'function (schema) {\n  compile(schema.tree, this, undefined, schema.options);\n  this.schema = schema;\n}',
  isInit: 'function (path) {\n  return (path in this.$__.activePaths.states.init);\n}',
  '$__validate': 'function (callback) {\n  var _this = this;\n  var _complete = function() {\n    var err = _this.$__.validationError;\n    _this.$__.validationError = undefined;\n    _this.emit(\'validate\', _this);\n    _this.constructor.emit(\'validate\', _this);\n    if (err) {\n      for (var key in err.errors) {\n        // Make sure cast errors persist\n        if (!_this.__parent && err.errors[key] instanceof MongooseError.CastError) {\n          _this.invalidate(key, err.errors[key]);\n        }\n      }\n\n      return err;\n    }\n  };\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (paths.length === 0) {\n    process.nextTick(function() {\n      var error = _complete();\n      if (error) {\n        return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n          callback(error);\n        });\n      }\n      callback();\n    });\n  }\n\n  var validating = {},\n      total = 0;\n\n  var complete = function() {\n    var error = _complete();\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n    callback();\n  };\n\n  var validatePath = function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n    total++;\n\n    process.nextTick(function() {\n      var p = _this.schema.path(path);\n      if (!p) {\n        return --total || complete();\n      }\n\n      // If user marked as invalid or there was a cast error, don\'t validate\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      var val = _this.getValue(path);\n      p.doValidate(val, function(err) {\n        if (err) {\n          _this.invalidate(path, err, undefined, true);\n        }\n        --total || complete();\n      }, _this);\n    });\n  };\n\n  paths.forEach(validatePath);\n}',
  db: '[object Object]',
  username: '222',
  '$__original_validate': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  discriminators: 'undefined',
  isModified: 'function (paths) {\n  if (paths) {\n    if (!Array.isArray(paths)) {\n      paths = paths.split(\' \');\n    }\n    var modified = this.modifiedPaths();\n    var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n    var isModifiedChild = paths.some(function(path) {\n      return !!~modified.indexOf(path);\n    });\n    return isModifiedChild || paths.some(function(path) {\n      return directModifiedPaths.some(function(mod) {\n        return mod === path || path.indexOf(mod + \'.\') === 0;\n      });\n    });\n  }\n  return this.$__.activePaths.some(\'modify\');\n}',
  '$pre': 'function (name, isAsync, fn, errorCb) {\n    if (\'boolean\' !== typeof arguments[1]) {\n      errorCb = fn;\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {};\n\n    this._lazySetupHooks(proto, name, errorCb);\n\n    if (fn.isAsync = isAsync) {\n      proto[name].numAsyncPres++;\n    }\n\n    (pres[name] = pres[name] || []).push(fn);\n    return this;\n  }',
  toObject: 'function (options) {\n  return this.$toObject(options);\n}',
  '$markValid': 'function (path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n}',
  '$__buildDoc': 'function (obj, fields, skipId) {\n  var doc = {};\n  var exclude = null;\n  var keys;\n  var ki;\n  var _this = this;\n\n  // determine if this doc is a result of a query with\n  // excluded fields\n\n  if (fields && utils.getFunctionName(fields.constructor) === \'Object\') {\n    keys = Object.keys(fields);\n    ki = keys.length;\n\n    if (ki === 1 && keys[0] === \'_id\') {\n      exclude = !!fields[keys[ki]];\n    } else {\n      while (ki--) {\n        if (keys[ki] !== \'_id\' &&\n            (!fields[keys[ki]] || typeof fields[keys[ki]] !== \'object\')) {\n          exclude = !fields[keys[ki]];\n          break;\n        }\n      }\n    }\n  }\n\n  var paths = Object.keys(this.schema.paths);\n  var plen = paths.length;\n  var ii = 0;\n\n  var hasIncludedChildren = {};\n  if (exclude === false && fields) {\n    keys = Object.keys(fields);\n    for (var j = 0; j < keys.length; ++j) {\n      var parts = keys[j].split(\'.\');\n      var c = [];\n      for (var k = 0; k < parts.length; ++k) {\n        c.push(parts[k]);\n        hasIncludedChildren[c.join(\'.\')] = 1;\n      }\n    }\n  }\n\n  for (; ii < plen; ++ii) {\n    var p = paths[ii];\n\n    if (p === \'_id\') {\n      if (skipId) {\n        continue;\n      }\n      if (obj && \'_id\' in obj) {\n        continue;\n      }\n    }\n\n    var type = this.schema.paths[p];\n    var path = p.split(\'.\');\n    var len = path.length;\n    var last = len - 1;\n    var curPath = \'\';\n    var doc_ = doc;\n    var i = 0;\n    var included = false;\n\n    for (; i < len; ++i) {\n      var piece = path[i],\n          def;\n\n      curPath += (!curPath.length ? \'\' : \'.\') + piece;\n\n      // support excluding intermediary levels\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i === last) {\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          } else if (included) {\n            // selected field\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          }\n        } else {\n          def = type.getDefault(_this, false);\n          if (typeof def !== \'undefined\') {\n            doc_[piece] = def;\n            _this.$__.activePaths.default(p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  return doc;\n}',
  getValue: 'function (path) {\n  return utils.getValue(path, this._doc);\n}',
  '$isValid': 'function (path) {\n  return !this.$__.validationError || !this.$__.validationError.errors[path];\n}',
  isDirectModified: 'function (path) {\n  return (path in this.$__.activePaths.states.modify);\n}',
  '$__dirty': 'function () {\n  var _this = this;\n\n  var all = this.$__.activePaths.map(\'modify\', function(path) {\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  });\n\n  // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n  all = all.concat(this.$__.activePaths.map(\'default\', function(path) {\n    if (path === \'_id\' || !_this.getValue(path)) {\n      return;\n    }\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n\n  // Sort dirty paths in a flat hierarchy.\n  all.sort(function(a, b) {\n    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));\n  });\n\n  // Ignore "foo.a" if "foo" is dirty already.\n  var minimal = [],\n      lastPath,\n      top;\n\n  all.forEach(function(item) {\n    if (!item) {\n      return;\n    }\n    if (item.path.indexOf(lastPath) !== 0) {\n      lastPath = item.path + \'.\';\n      minimal.push(item);\n      top = item;\n    } else {\n      // special case for top level MongooseArrays\n      if (top.value && top.value._atomics && top.value.hasAtomics()) {\n        // the `top` array itself and a sub path of `top` are being modified.\n        // the only way to honor all of both modifications is through a $set\n        // of entire array.\n        top.value._atomics = {};\n        top.value._atomics.$set = top.value;\n      }\n    }\n  });\n\n  top = lastPath = null;\n  return minimal;\n}',
  model: 'function model(name) {\n  return this.db.model(name);\n}',
  '$isDefault': 'function (path) {\n  return (path in this.$__.activePaths.states.default);\n}',
  '$__original_remove': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  remove: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populate: 'function populate() {\n  if (arguments.length === 0) {\n    return this;\n  }\n\n  var pop = this.$__.populate || (this.$__.populate = {});\n  var args = utils.args(arguments);\n  var fn;\n\n  if (typeof args[args.length - 1] === \'function\') {\n    fn = args.pop();\n  }\n\n  // allow `doc.populate(callback)`\n  if (args.length) {\n    // use hash to remove duplicate paths\n    var res = utils.populate.apply(null, args);\n    for (var i = 0; i < res.length; ++i) {\n      pop[res[i].path] = res[i];\n    }\n  }\n\n  if (fn) {\n    var paths = utils.object.vals(pop);\n    this.$__.populate = undefined;\n    paths.__noPromise = true;\n    this.constructor.populate(this, paths, fn);\n  }\n\n  return this;\n}',
  '$__shouldModify': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  if (this.isNew) {\n    return true;\n  }\n\n  if (undefined === val && !this.isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (undefined === val && path in this.$__.activePaths.states.default) {\n    // we\'re just unsetting the default value which was never saved\n    return false;\n  }\n\n  // gh-3992: if setting a populated field to a doc, don\'t mark modified\n  // if they have the same _id\n  if (this.populated(path) &&\n      val instanceof Document &&\n      deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal || this.get(path))) {\n    return true;\n  }\n\n  if (!constructing &&\n      val !== null &&\n      val !== undefined &&\n      path in this.$__.activePaths.states.default &&\n      deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n  return false;\n}',
  '$__': '[object Object]',
  '$__fullPath': 'function (path) {\n  // overridden in SubDocuments\n  return path || \'\';\n}',
  _pres: '[object Object]',
  inspect: 'function (options) {\n  var isPOJO = options &&\n    utils.getFunctionName(options.constructor) === \'Object\';\n  var opts;\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n    opts.retainKeyOrder = true;\n  }\n  return this.toObject(opts);\n}',
  '$__reset': 'function reset() {\n  var _this = this;\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return _this.getValue(i);\n  })\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  })\n  .forEach(function(array) {\n    var i = array.length;\n    while (i--) {\n      var doc = array[i];\n      if (!doc) {\n        continue;\n      }\n      doc.$__reset();\n    }\n  });\n\n  // clear atomics\n  this.$__dirty().forEach(function(dirt) {\n    var type = dirt.value;\n    if (type && type._atomics) {\n      type._atomics = {};\n    }\n  });\n\n  // Clear \'dirty\' cache\n  this.$__.activePaths.clear(\'modify\');\n  this.$__.activePaths.clear(\'default\');\n  this.$__.validationError = undefined;\n  this.errors = undefined;\n  _this = this;\n  this.schema.requiredPaths().forEach(function(path) {\n    _this.$__.activePaths.require(path);\n  });\n\n  return this;\n}',
  init: 'function (doc, opts, fn) {\n  // do not prefix this method with $__ since its\n  // used by public hooks\n\n  if (typeof opts === \'function\') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.isNew = false;\n\n  // handle docs with populated paths\n  // If doc._id is not null or undefined\n  if (doc._id !== null && doc._id !== undefined &&\n    opts && opts.populated && opts.populated.length) {\n    var id = String(doc._id);\n    for (var i = 0; i < opts.populated.length; ++i) {\n      var item = opts.populated[i];\n      if (item.isVirtual) {\n        this.populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.populated(item.path, item._docs[id], item);\n      }\n    }\n  }\n\n  init(this, doc, this._doc);\n  this.$__storeShard();\n\n  this.emit(\'init\', this);\n  this.constructor.emit(\'init\', this);\n\n  if (fn) {\n    fn(null);\n  }\n  return this;\n}',
  setMaxListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  initializeTimestamps: 'function () {\n      if (!this.get(createdAt)) {\n        this.set(createdAt, new Date());\n      }\n      if (!this.get(updatedAt)) {\n        this.set(updatedAt, new Date());\n      }\n      return this;\n    }',
  once: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  __v: '0',
  '$toObject': 'function (options, json) {\n  var defaultOptions = {\n    transform: true,\n    json: json,\n    retainKeyOrder: this.schema.options.retainKeyOrder,\n    flattenDecimals: true\n  };\n\n  // _isNested will only be true if this is not the top level document, we\n  // should never depopulate\n  if (options && options.depopulate && options._isNested && this.$__.wasPopulated) {\n    // populated paths that we set to a document\n    return clone(this._id, options);\n  }\n\n  // When internally saving this document we always pass options,\n  // bypassing the custom schema options.\n  if (!(options && utils.getFunctionName(options.constructor) === \'Object\') ||\n      (options && options._useSchemaOptions)) {\n    if (json) {\n      options = this.schema.options.toJSON ?\n        clone(this.schema.options.toJSON) :\n        {};\n      options.json = true;\n      options._useSchemaOptions = true;\n    } else {\n      options = this.schema.options.toObject ?\n        clone(this.schema.options.toObject) :\n        {};\n      options.json = false;\n      options._useSchemaOptions = true;\n    }\n  }\n\n  for (var key in defaultOptions) {\n    if (options[key] === undefined) {\n      options[key] = defaultOptions[key];\n    }\n  }\n\n  (\'minimize\' in options) || (options.minimize = this.schema.options.minimize);\n\n  // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n  var originalTransform = options.transform;\n\n  options._isNested = true;\n\n  var ret = clone(this._doc, options) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, \'paths\', options);\n    // applyGetters for paths will add nested empty objects;\n    // if minimize is set, we need to remove them.\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || options.getters && options.virtuals !== false) {\n    applyGetters(this, ret, \'virtuals\', options);\n  }\n\n  if (options.versionKey === false && this.schema.options.versionKey) {\n    delete ret[this.schema.options.versionKey];\n  }\n\n  var transform = options.transform;\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema\'s transform and\n  // not the parent schema\'s\n  if (transform === true ||\n      (this.schema.options.toObject && transform)) {\n    var opts = options.json ? this.schema.options.toJSON : this.schema.options.toObject;\n\n    if (opts) {\n      transform = (typeof options.transform === \'function\' ? options.transform : opts.transform);\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === \'function\') {\n    var xformed = transform(this, ret, options);\n    if (typeof xformed !== \'undefined\') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n}',
  '$hook': 'function (name, fn, errorCb) {\n    if (arguments.length === 1 && typeof name === \'object\') {\n      for (var k in name) { // `name` is a hash of hookName->hookFn\n        this.$hook(k, name[k]);\n      }\n      return;\n    }\n\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {}\n      , posts = proto._posts = proto._posts || {};\n    pres[name] = pres[name] || [];\n    posts[name] = posts[name] || [];\n\n    proto[name] = function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    };\n    \n    proto[name].numAsyncPres = 0;\n\n    return this;\n  }',
  '$__set': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  var shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts,\n    schema, val, priorVal);\n  var _this = this;\n\n  if (shouldModify) {\n    this.markModified(pathToMark, val);\n\n    // handle directly setting arrays (gh-1126)\n    MongooseArray || (MongooseArray = require(\'./types/array\'));\n    if (val && val.isMongooseArray) {\n      val._registerAtomic(\'$set\', val);\n\n      // Update embedded document parent references (gh-5189)\n      if (val.isMongooseDocumentArray) {\n        val.forEach(function(item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      }\n\n      // Small hack for gh-1638: if we\'re overwriting the entire array, ignore\n      // paths that were modified before the array overwrite\n      this.$__.activePaths.forEach(function(modifiedPath) {\n        if (modifiedPath.indexOf(path + \'.\') === 0) {\n          _this.$__.activePaths.ignore(modifiedPath);\n        }\n      });\n    }\n  }\n\n  var obj = this._doc;\n  var i = 0;\n  var l = parts.length;\n  var cur = \'\';\n\n  for (; i < l; i++) {\n    var next = i + 1;\n    var last = next === l;\n    cur += (cur ? \'.\' + parts[i] : parts[i]);\n\n    if (last) {\n      obj[parts[i]] = val;\n    } else {\n      if (obj[parts[i]] && utils.getFunctionName(obj[parts[i]].constructor) === \'Object\') {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        this.set(cur, {});\n        obj = obj[parts[i]];\n      }\n    }\n  }\n}',
  name: '222',
  isNew: 'false',
  unmarkModified: 'function (path) {\n  this.$__.activePaths.init(path);\n}',
  validateSync: 'function (pathsToValidate) {\n  var _this = this;\n\n  if (typeof pathsToValidate === \'string\') {\n    pathsToValidate = pathsToValidate.split(\' \');\n  }\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (pathsToValidate && pathsToValidate.length) {\n    var tmp = [];\n    for (var i = 0; i < paths.length; ++i) {\n      if (pathsToValidate.indexOf(paths[i]) !== -1) {\n        tmp.push(paths[i]);\n      }\n    }\n    paths = tmp;\n  }\n\n  var validating = {};\n\n  paths.forEach(function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n\n    var p = _this.schema.path(path);\n    if (!p) {\n      return;\n    }\n    if (!_this.$isValid(path)) {\n      return;\n    }\n\n    var val = _this.getValue(path);\n    var err = p.doValidateSync(val, _this);\n    if (err) {\n      _this.invalidate(path, err, undefined, true);\n    }\n  });\n\n  var err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n  _this.emit(\'validate\', _this);\n  _this.constructor.emit(\'validate\', _this);\n\n  if (err) {\n    for (var key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n}',
  errors: 'undefined',
  addListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  setValue: 'function (path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n}',
  '$__where': 'function _where(where) {\n  where || (where = {});\n\n  var paths,\n      len;\n\n  if (!where._id) {\n    where._id = this._doc._id;\n  }\n\n  if (this.$__.shardval) {\n    paths = Object.keys(this.$__.shardval);\n    len = paths.length;\n\n    for (var i = 0; i < len; ++i) {\n      where[paths[i]] = this.$__.shardval[paths[i]];\n    }\n  }\n\n  if (this._doc._id == null) {\n    return new Error(\'No _id found on document!\');\n  }\n\n  return where;\n}',
  invalidate: 'function (path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === \'string\') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || \'user defined\',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.errors[path] = err;\n  return this.$__.validationError;\n}',
  _doc: '[object Object]',
  execPopulate: 'function () {\n  var Promise = PromiseProvider.get();\n  var _this = this;\n  return new Promise.ES6(function(resolve, reject) {\n    _this.populate(function(error, res) {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(res);\n      }\n    });\n  });\n}',
  isSelected: 'function isSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    i = paths.length;\n    var pathDot = path + \'.\';\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n\n      if (cur.indexOf(pathDot) === 0) {\n        return inclusive || cur !== pathDot;\n      }\n\n      if (pathDot.indexOf(cur + \'.\') === 0) {\n        return inclusive;\n      }\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  _id: '5902b753c5756d72945d90b3',
  toString: 'function () {\n  return inspect(this.inspect());\n}',
  '$post': 'function (name, isAsync, fn) {\n    if (arguments.length === 2) {\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , posts = proto._posts = proto._posts || {};\n    \n    this._lazySetupHooks(proto, name);\n    (posts[name] = posts[name] || []).push(fn);\n    return this;\n  }',
  '$__handleSave': 'function (options, callback) {\n  var _this = this;\n  var i;\n  var keys;\n  var len;\n  if (!options.safe && this.schema.options.safe) {\n    options.safe = this.schema.options.safe;\n  }\n  if (typeof options.safe === \'boolean\') {\n    options.safe = null;\n  }\n\n  if (this.isNew) {\n    // send entire doc\n    var toObjectOptions = {};\n\n    toObjectOptions.retainKeyOrder = this.schema.options.retainKeyOrder;\n    toObjectOptions.depopulate = 1;\n    toObjectOptions._skipDepopulateTopLevel = true;\n    toObjectOptions.transform = false;\n    toObjectOptions.flattenDecimals = false;\n\n    var obj = this.toObject(toObjectOptions);\n\n    if (!utils.object.hasOwnProperty(obj || {}, \'_id\')) {\n      // documents must have an _id else mongoose won\'t know\n      // what to update later if more changes are made. the user\n      // wouldn\'t know what _id was generated by mongodb either\n      // nor would the ObjectId generated my mongodb necessarily\n      // match the schema definition.\n      setTimeout(function() {\n        callback(new Error(\'document must have an _id before saving\'));\n      }, 0);\n      return;\n    }\n\n    this.$__version(true, obj);\n    this.collection.insert(obj, options.safe, function(err, ret) {\n      if (err) {\n        _this.isNew = true;\n        _this.emit(\'isNew\', true);\n        _this.constructor.emit(\'isNew\', true);\n\n        callback(err);\n        return;\n      }\n\n      callback(null, ret);\n    });\n    this.$__reset();\n    this.isNew = false;\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n    // Make it possible to retry the insert\n    this.$__.inserting = true;\n  } else {\n    // Make sure we don\'t treat it as a new object on error,\n    // since it already exists\n    this.$__.inserting = false;\n\n    var delta = this.$__delta();\n\n    if (delta) {\n      if (delta instanceof Error) {\n        callback(delta);\n        return;\n      }\n\n      var where = this.$__where(delta[0]);\n      if (where instanceof Error) {\n        callback(where);\n        return;\n      }\n\n      if (this.$where) {\n        keys = Object.keys(this.$where);\n        len = keys.length;\n        for (i = 0; i < len; ++i) {\n          where[keys[i]] = this.$where[keys[i]];\n        }\n      }\n\n      this.collection.update(where, delta[1], options.safe, function(err, ret) {\n        if (err) {\n          callback(err);\n          return;\n        }\n        ret.$where = where;\n        callback(null, ret);\n      });\n    } else {\n      this.$__reset();\n      callback();\n      return;\n    }\n\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n  }\n}',
  toJSON: 'function (options) {\n  return this.$toObject(options, true);\n}',
  '$__handleReject': 'function handleReject(err) {\n  // emit on the Model if listening\n  if (this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  } else if (this.constructor.listeners && this.constructor.listeners(\'error\').length) {\n    this.constructor.emit(\'error\', err);\n  } else if (this.listeners && this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  }\n}' }
[2017-05-04 16:16:35.732] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:16:35.749] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:16:35.754] [INFO] app - Redis client default is ready {}
[2017-05-04 16:16:35.958] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:16:36.781] [DEBUG] app - 2017-5-4 16:16:36 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:16:36.787] [WARN] console - this is a logger middleware.
[2017-05-04 16:16:36.806] [ERROR] app - TypeError: json.toJson is not a function
    at UserKv._callee2$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:30:25)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:9:437
    at UserKv.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:9:99)
    at UserKv.save (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:113:22)
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:7:34)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:361
    at process._tickDomainCallback (internal/process/next_tick.js:135:7)
[2017-05-04 16:16:36.821] [ERROR] console - TypeError: json.toJson is not a function
    at UserKv._callee2$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:30:25)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:9:437
    at UserKv.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:9:99)
    at UserKv.save (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:113:22)
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:7:34)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:361
    at process._tickDomainCallback (internal/process/next_tick.js:135:7)
[2017-05-04 16:17:12.048] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:17:12.065] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:17:12.073] [INFO] app - Redis client default is ready {}
[2017-05-04 16:17:12.263] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:17:14.972] [DEBUG] app - 2017-5-4 16:17:14 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:17:14.978] [WARN] console - this is a logger middleware.
[2017-05-04 16:17:15.006] [WARN] console - { _id: 5902b753c5756d72945d90b3,
  updatedAt: 2017-04-28T03:30:27.167Z,
  createdAt: 2017-04-28T03:30:27.167Z,
  username: '222',
  __v: 0 }
[2017-05-04 16:17:15.017] [WARN] console - { createdAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  '$__version': 'function (where, delta) {\n  var key = this.schema.options.versionKey;\n\n  if (where === true) {\n    // this is an insert\n    if (key) this.setValue(key, delta[key] = 0);\n    return;\n  }\n\n  // updates\n\n  // only apply versioning if our versionKey was selected. else\n  // there is no way to select the correct version. we could fail\n  // fast here and force them to include the versionKey but\n  // thats a bit intrusive. can we do this automatically?\n  if (!this.isSelected(key)) {\n    return;\n  }\n\n  // $push $addToSet don\'t need the where clause set\n  if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {\n    where[key] = this.getValue(key);\n  }\n\n  if (VERSION_INC === (VERSION_INC & this.$__.version)) {\n    if (!delta.$set || typeof delta.$set[key] === \'undefined\') {\n      delta.$inc || (delta.$inc = {});\n      delta.$inc[key] = 1;\n    }\n  }\n}',
  '$isMongooseModelPrototype': 'true',
  set: 'function (path, val, type, options) {\n  if (type && utils.getFunctionName(type.constructor) === \'Object\') {\n    options = type;\n    type = undefined;\n  }\n\n  var merge = options && options.merge,\n      adhoc = type && type !== true,\n      constructing = type === true,\n      adhocs;\n\n  var strict = options && \'strict\' in options\n      ? options.strict\n      : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  if (typeof path !== \'string\') {\n    // new Document({ key: val })\n\n    if (path === null || path === void 0) {\n      var _ = path;\n      path = val;\n      val = _;\n    } else {\n      var prefix = val\n          ? val + \'.\'\n          : \'\';\n\n      if (path instanceof Document) {\n        if (path.$__isNested) {\n          path = path.toObject();\n        } else {\n          path = path._doc;\n        }\n      }\n\n      var keys = Object.keys(path);\n      var len = keys.length;\n      var i = 0;\n      var pathtype;\n      var key;\n\n      if (len === 0 && !this.schema.options.minimize) {\n        if (val) {\n          this.set(val, {});\n        }\n        return this;\n      }\n\n      if (this.schema.options.retainKeyOrder) {\n        while (i < len) {\n          _handleIndex.call(this, i++);\n        }\n      } else {\n        while (len--) {\n          _handleIndex.call(this, len);\n        }\n      }\n\n      return this;\n    }\n  }\n\n  function _handleIndex(i) {\n    key = keys[i];\n    var pathName = prefix + key;\n    pathtype = this.schema.pathType(pathName);\n\n    if (path[key] !== null\n        && path[key] !== void 0\n          // need to know if plain object - no Buffer, ObjectId, ref, etc\n        && utils.isObject(path[key])\n        && (!path[key].constructor || utils.getFunctionName(path[key].constructor) === \'Object\')\n        && pathtype !== \'virtual\'\n        && pathtype !== \'real\'\n        && !(this.$__path(pathName) instanceof MixedSchema)\n        && !(this.schema.paths[pathName] &&\n        this.schema.paths[pathName].options &&\n        this.schema.paths[pathName].options.ref)) {\n      this.set(path[key], prefix + key, constructing);\n    } else if (strict) {\n      // Don\'t overwrite defaults with undefined keys (gh-3981)\n      if (constructing && path[key] === void 0 &&\n          this.get(key) !== void 0) {\n        return;\n      }\n\n      if (pathtype === \'real\' || pathtype === \'virtual\') {\n        // Check for setting single embedded schema to document (gh-3535)\n        var p = path[key];\n        if (this.schema.paths[pathName] &&\n            this.schema.paths[pathName].$isSingleNested &&\n            path[key] instanceof Document) {\n          p = p.toObject({ virtuals: false, transform: false });\n        }\n        this.set(prefix + key, p, constructing);\n      } else if (pathtype === \'nested\' && path[key] instanceof Document) {\n        this.set(prefix + key,\n            path[key].toObject({transform: false}), constructing);\n      } else if (strict === \'throw\') {\n        if (pathtype === \'nested\') {\n          throw new ObjectExpectedError(key, path[key]);\n        } else {\n          throw new StrictModeError(key);\n        }\n      }\n    } else if (path[key] !== void 0) {\n      this.set(prefix + key, path[key], constructing);\n    }\n  }\n\n  var pathType = this.schema.pathType(path);\n  if (pathType === \'nested\' && val) {\n    if (utils.isObject(val) &&\n        (!val.constructor || utils.getFunctionName(val.constructor) === \'Object\')) {\n      if (!merge) {\n        this.setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      }\n\n      if (Object.keys(val).length === 0) {\n        this.setValue(path, {});\n        this.markModified(path);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        this.set(val, path, constructing);\n      }\n      return this;\n    }\n    this.invalidate(path, new MongooseError.CastError(\'Object\', val, path));\n    return this;\n  }\n\n  var schema;\n  var parts = path.split(\'.\');\n\n  if (pathType === \'adhocOrUndefined\' && strict) {\n    // check for roots that are Mixed types\n    var mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      var subpath = parts.slice(0, i + 1).join(\'.\');\n      schema = this.schema.path(subpath);\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n\n      // If path is underneath a virtual, bypass everything and just set it.\n      if (i + 1 < parts.length && this.schema.pathType(subpath) === \'virtual\') {\n        mpath.set(path, val, this);\n        return this;\n      }\n    }\n\n    if (!mixed) {\n      if (strict === \'throw\') {\n        throw new StrictModeError(path);\n      }\n      return this;\n    }\n  } else if (pathType === \'virtual\') {\n    schema = this.schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  var pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: "LEFT_SUBFIELD only supports Object"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    for (i = 0; i < parts.length; ++i) {\n      subpath = parts.slice(0, i + 1).join(\'.\');\n      if (this.isDirectModified(subpath) // earlier prefixes that are already\n            // marked as dirty have precedence\n          || this.get(subpath) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n\n  // if this doc is being constructed we should not trigger getters\n  var priorVal = constructing\n      ? undefined\n      : this.getValue(path);\n\n  if (!schema) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n    return this;\n  }\n\n  var shouldSet = true;\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    var didPopulate = false;\n    if (schema.options &&\n        schema.options.ref &&\n        val instanceof Document &&\n        (schema.options.ref === val.constructor.modelName || schema.options.ref === val.constructor.baseModelName)) {\n      if (this.ownerDocument) {\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val._id, {model: val.constructor});\n      } else {\n        this.populated(path, val._id, {model: val.constructor});\n      }\n      didPopulate = true;\n    }\n\n    var popOpts;\n    if (schema.options &&\n        Array.isArray(schema.options.type) &&\n        schema.options.type.length &&\n        schema.options.type[0].ref &&\n        Array.isArray(val) &&\n        val.length > 0 &&\n        val[0] instanceof Document &&\n        val[0].constructor.modelName &&\n        (schema.options.type[0].ref === val[0].constructor.baseModelName || schema.options.type[0].ref === val[0].constructor.modelName)) {\n      if (this.ownerDocument) {\n        popOpts = { model: val[0].constructor };\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val.map(function(v) { return v._id; }), popOpts);\n      } else {\n        popOpts = { model: val[0].constructor };\n        this.populated(path, val.map(function(v) { return v._id; }), popOpts);\n      }\n      didPopulate = true;\n    }\n    val = schema.applySetters(val, this, false, priorVal);\n\n    if (!didPopulate && this.$__.populated) {\n      delete this.$__.populated[path];\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    this.invalidate(path,\n      new MongooseError.CastError(schema.instance, val, path, e));\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n}',
  modifiedPaths: 'function () {\n  var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n  return directModifiedPaths.reduce(function(list, path) {\n    var parts = path.split(\'.\');\n    return list.concat(parts.reduce(function(chains, part, i) {\n      return chains.concat(parts.slice(0, i).concat(part).join(\'.\'));\n    }, []).filter(function(chain) {\n      return (list.indexOf(chain) === -1);\n    }));\n  }, []);\n}',
  get: 'function (path, type) {\n  var adhoc;\n  if (type) {\n    adhoc = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  var schema = this.$__path(path) || this.schema.virtualpath(path),\n      pieces = path.split(\'.\'),\n      obj = this._doc;\n\n  for (var i = 0, l = pieces.length; i < l; i++) {\n    obj = obj === null || obj === void 0\n        ? undefined\n        : obj[pieces[i]];\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  // Check if this path is populated - don\'t apply getters if it is,\n  // because otherwise its a nested object. See gh-3357\n  if (schema && !this.populated(path)) {\n    obj = schema.applyGetters(obj, this);\n  }\n\n  return obj;\n}',
  updatedAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  '$__path': 'function (path) {\n  var adhocs = this.$__.adhocPaths,\n      adhocType = adhocs && adhocs[path];\n\n  if (adhocType) {\n    return adhocType;\n  }\n  return this.schema.path(path);\n}',
  '$__save': 'function (options, callback) {\n  var _this = this;\n\n  _this.$__handleSave(options, function(error, result) {\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.$__reset();\n    _this.$__storeShard();\n\n    var numAffected = 0;\n    if (result) {\n      if (Array.isArray(result)) {\n        numAffected = result.length;\n      } else if (result.result && result.result.n !== undefined) {\n        numAffected = result.result.n;\n      } else if (result.result && result.result.nModified !== undefined) {\n        numAffected = result.result.nModified;\n      } else {\n        numAffected = result;\n      }\n    }\n\n    // was this an update that required a version bump?\n    if (_this.$__.version && !_this.$__.inserting) {\n      var doIncrement = VERSION_INC === (VERSION_INC & _this.$__.version);\n      _this.$__.version = undefined;\n\n      if (numAffected <= 0) {\n        // the update failed. pass an error back\n        var err = new VersionError(_this);\n        return callback(err);\n      }\n\n      // increment version if was successful\n      if (doIncrement) {\n        var key = _this.schema.options.versionKey;\n        var version = _this.getValue(key) | 0;\n        _this.setValue(key, version + 1);\n      }\n    }\n\n    if (_this.schema.options &&\n        _this.schema.options.saveErrorIfNotFound &&\n        numAffected <= 0) {\n      error = new DocumentNotFoundError(result.$where);\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.emit(\'save\', _this, numAffected);\n    _this.constructor.emit(\'save\', _this, numAffected);\n    callback(null, _this, numAffected);\n  });\n}',
  '$__delta': 'function () {\n  var dirty = this.$__dirty();\n  if (!dirty.length && VERSION_ALL !== this.$__.version) return;\n\n  var where = {},\n      delta = {},\n      len = dirty.length,\n      divergent = [],\n      d = 0;\n\n  where._id = this._doc._id;\n  if (where._id.toObject) {\n    where._id = where._id.toObject({ transform: false, depopulate: true });\n  }\n\n  for (; d < len; ++d) {\n    var data = dirty[d];\n    var value = data.value;\n\n    var match = checkDivergentArray(this, data.path, value);\n    if (match) {\n      divergent.push(match);\n      continue;\n    }\n\n    var pop = this.populated(data.path, true);\n    if (!pop && this.$__.selected) {\n      // If any array was selected using an $elemMatch projection, we alter the path and where clause\n      // NOTE: MongoDB only supports projected $elemMatch on top level array.\n      var pathSplit = data.path.split(\'.\');\n      var top = pathSplit[0];\n      if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {\n        // If the selected array entry was modified\n        if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === \'undefined\') {\n          where[top] = this.$__.selected[top];\n          pathSplit[1] = \'$\';\n          data.path = pathSplit.join(\'.\');\n        }\n        // if the selected array was modified in any other way throw an error\n        else {\n          divergent.push(data.path);\n          continue;\n        }\n      }\n    }\n\n    if (divergent.length) continue;\n\n    if (undefined === value) {\n      operand(this, where, delta, data, 1, \'$unset\');\n    } else if (value === null) {\n      operand(this, where, delta, data, null);\n    } else if (value._path && value._atomics) {\n      // arrays and other custom types (support plugins etc)\n      handleAtomics(this, where, delta, data, value);\n    } else if (value._path && Buffer.isBuffer(value)) {\n      // MongooseBuffer\n      value = value.toObject();\n      operand(this, where, delta, data, value);\n    } else {\n      value = utils.clone(value, {depopulate: 1, _isNested: true});\n      operand(this, where, delta, data, value);\n    }\n  }\n\n  if (divergent.length) {\n    return new DivergentArrayError(divergent);\n  }\n\n  if (this.$__.version) {\n    this.$__version(where, delta);\n  }\n\n  return [where, delta];\n}',
  '$__storeShard': 'function () {\n  // backwards compat\n  var key = this.schema.options.shardKey || this.schema.options.shardkey;\n  if (!(key && utils.getFunctionName(key.constructor) === \'Object\')) {\n    return;\n  }\n\n  var orig = this.$__.shardval = {},\n      paths = Object.keys(key),\n      len = paths.length,\n      val;\n\n  for (var i = 0; i < len; ++i) {\n    val = this.getValue(paths[i]);\n    if (isMongooseObject(val)) {\n      orig[paths[i]] = val.toObject({depopulate: true, _isNested: true});\n    } else if (val !== null && val !== undefined && val.valueOf &&\n          // Explicitly don\'t take value of dates\n        (!val.constructor || utils.getFunctionName(val.constructor) !== \'Date\')) {\n      orig[paths[i]] = val.valueOf();\n    } else {\n      orig[paths[i]] = val;\n    }\n  }\n}',
  listeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  depopulate: 'function (path) {\n  var populatedIds = this.populated(path);\n  if (!populatedIds) {\n    return;\n  }\n  delete this.$__.populated[path];\n  this.set(path, populatedIds);\n  return this;\n}',
  equals: 'function (doc) {\n  if (!doc) {\n    return false;\n  }\n\n  var tid = this.get(\'_id\');\n  var docid = doc.get ? doc.get(\'_id\') : doc;\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals\n      ? tid.equals(docid)\n      : tid === docid;\n}',
  _posts: '[object Object]',
  '$__getAllSubdocs': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  function docReducer(seed, path) {\n    var val = this[path];\n\n    if (val instanceof Embedded) {\n      seed.push(val);\n    }\n    if (val && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(docReducer.bind(val._doc), seed);\n      seed.push(val);\n    }\n    if (val && val.isMongooseDocumentArray) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n        seed = Object.keys(doc._doc).reduce(docReducer.bind(doc._doc), seed);\n      });\n    } else if (val instanceof Document && val.$__isNested) {\n      if (val) {\n        seed = Object.keys(val).reduce(docReducer.bind(val), seed);\n      }\n    }\n    return seed;\n  }\n\n  var subDocs = Object.keys(this._doc).reduce(docReducer.bind(this), []);\n\n  return subDocs;\n}',
  '$__original_save': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  removeListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  '$__getArrayPathsToValidate': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  // validate all document arrays.\n  return this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return this.getValue(i);\n  }.bind(this))\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  }).reduce(function(seed, array) {\n    return seed.concat(array);\n  }, [])\n  .filter(function(doc) {\n    return doc;\n  });\n}',
  schema: '[object Object]',
  removeAllListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  save: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  isDirectSelected: 'function isDirectSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  removePost: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , posts = proto._posts || (proto._posts || {});\n    if (!posts[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all post callbacks for hook `name`\n      posts[name].length = 0;\n    } else {\n      posts[name] = posts[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  _lazySetupHooks: 'function (proto, methodName, errorCb) {\n    if (\'undefined\' === typeof proto[methodName].numAsyncPres) {\n      this.$hook(methodName, proto[methodName], errorCb);\n    }\n  }',
  toBSON: 'function () {\n  return this.toObject({\n    transform: false,\n    virtuals: false,\n    _skipDepopulateTopLevel: true,\n    depopulate: true,\n    flattenDecimals: false\n  });\n}',
  markModified: 'function (path) {\n  this.$__.activePaths.modify(path);\n}',
  on: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  increment: 'function increment() {\n  this.$__.version = VERSION_ALL;\n  return this;\n}',
  validate: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populated: 'function (path, val, options) {\n  // val and options are internal\n\n  if (val === null || val === void 0) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    var v = this.$__.populated[path];\n    if (v) {\n      return v.value;\n    }\n    return undefined;\n  }\n\n  // internal\n\n  if (val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    return this.$__.populated[path];\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = {value: val, options: options};\n  return val;\n}',
  update: 'function update() {\n  var args = utils.args(arguments);\n  args.unshift({_id: this._id});\n  return this.constructor.update.apply(this.constructor, args);\n}',
  id: '5902b753c5756d72945d90b3',
  '$__setSchema': 'function (schema) {\n  compile(schema.tree, this, undefined, schema.options);\n  this.schema = schema;\n}',
  isInit: 'function (path) {\n  return (path in this.$__.activePaths.states.init);\n}',
  '$__validate': 'function (callback) {\n  var _this = this;\n  var _complete = function() {\n    var err = _this.$__.validationError;\n    _this.$__.validationError = undefined;\n    _this.emit(\'validate\', _this);\n    _this.constructor.emit(\'validate\', _this);\n    if (err) {\n      for (var key in err.errors) {\n        // Make sure cast errors persist\n        if (!_this.__parent && err.errors[key] instanceof MongooseError.CastError) {\n          _this.invalidate(key, err.errors[key]);\n        }\n      }\n\n      return err;\n    }\n  };\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (paths.length === 0) {\n    process.nextTick(function() {\n      var error = _complete();\n      if (error) {\n        return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n          callback(error);\n        });\n      }\n      callback();\n    });\n  }\n\n  var validating = {},\n      total = 0;\n\n  var complete = function() {\n    var error = _complete();\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n    callback();\n  };\n\n  var validatePath = function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n    total++;\n\n    process.nextTick(function() {\n      var p = _this.schema.path(path);\n      if (!p) {\n        return --total || complete();\n      }\n\n      // If user marked as invalid or there was a cast error, don\'t validate\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      var val = _this.getValue(path);\n      p.doValidate(val, function(err) {\n        if (err) {\n          _this.invalidate(path, err, undefined, true);\n        }\n        --total || complete();\n      }, _this);\n    });\n  };\n\n  paths.forEach(validatePath);\n}',
  db: '[object Object]',
  username: '222',
  '$__original_validate': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  discriminators: 'undefined',
  isModified: 'function (paths) {\n  if (paths) {\n    if (!Array.isArray(paths)) {\n      paths = paths.split(\' \');\n    }\n    var modified = this.modifiedPaths();\n    var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n    var isModifiedChild = paths.some(function(path) {\n      return !!~modified.indexOf(path);\n    });\n    return isModifiedChild || paths.some(function(path) {\n      return directModifiedPaths.some(function(mod) {\n        return mod === path || path.indexOf(mod + \'.\') === 0;\n      });\n    });\n  }\n  return this.$__.activePaths.some(\'modify\');\n}',
  '$pre': 'function (name, isAsync, fn, errorCb) {\n    if (\'boolean\' !== typeof arguments[1]) {\n      errorCb = fn;\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {};\n\n    this._lazySetupHooks(proto, name, errorCb);\n\n    if (fn.isAsync = isAsync) {\n      proto[name].numAsyncPres++;\n    }\n\n    (pres[name] = pres[name] || []).push(fn);\n    return this;\n  }',
  toObject: 'function (options) {\n  return this.$toObject(options);\n}',
  '$markValid': 'function (path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n}',
  '$__buildDoc': 'function (obj, fields, skipId) {\n  var doc = {};\n  var exclude = null;\n  var keys;\n  var ki;\n  var _this = this;\n\n  // determine if this doc is a result of a query with\n  // excluded fields\n\n  if (fields && utils.getFunctionName(fields.constructor) === \'Object\') {\n    keys = Object.keys(fields);\n    ki = keys.length;\n\n    if (ki === 1 && keys[0] === \'_id\') {\n      exclude = !!fields[keys[ki]];\n    } else {\n      while (ki--) {\n        if (keys[ki] !== \'_id\' &&\n            (!fields[keys[ki]] || typeof fields[keys[ki]] !== \'object\')) {\n          exclude = !fields[keys[ki]];\n          break;\n        }\n      }\n    }\n  }\n\n  var paths = Object.keys(this.schema.paths);\n  var plen = paths.length;\n  var ii = 0;\n\n  var hasIncludedChildren = {};\n  if (exclude === false && fields) {\n    keys = Object.keys(fields);\n    for (var j = 0; j < keys.length; ++j) {\n      var parts = keys[j].split(\'.\');\n      var c = [];\n      for (var k = 0; k < parts.length; ++k) {\n        c.push(parts[k]);\n        hasIncludedChildren[c.join(\'.\')] = 1;\n      }\n    }\n  }\n\n  for (; ii < plen; ++ii) {\n    var p = paths[ii];\n\n    if (p === \'_id\') {\n      if (skipId) {\n        continue;\n      }\n      if (obj && \'_id\' in obj) {\n        continue;\n      }\n    }\n\n    var type = this.schema.paths[p];\n    var path = p.split(\'.\');\n    var len = path.length;\n    var last = len - 1;\n    var curPath = \'\';\n    var doc_ = doc;\n    var i = 0;\n    var included = false;\n\n    for (; i < len; ++i) {\n      var piece = path[i],\n          def;\n\n      curPath += (!curPath.length ? \'\' : \'.\') + piece;\n\n      // support excluding intermediary levels\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i === last) {\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          } else if (included) {\n            // selected field\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          }\n        } else {\n          def = type.getDefault(_this, false);\n          if (typeof def !== \'undefined\') {\n            doc_[piece] = def;\n            _this.$__.activePaths.default(p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  return doc;\n}',
  getValue: 'function (path) {\n  return utils.getValue(path, this._doc);\n}',
  collection: '[object Object]',
  '$isValid': 'function (path) {\n  return !this.$__.validationError || !this.$__.validationError.errors[path];\n}',
  isDirectModified: 'function (path) {\n  return (path in this.$__.activePaths.states.modify);\n}',
  '$__dirty': 'function () {\n  var _this = this;\n\n  var all = this.$__.activePaths.map(\'modify\', function(path) {\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  });\n\n  // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n  all = all.concat(this.$__.activePaths.map(\'default\', function(path) {\n    if (path === \'_id\' || !_this.getValue(path)) {\n      return;\n    }\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n\n  // Sort dirty paths in a flat hierarchy.\n  all.sort(function(a, b) {\n    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));\n  });\n\n  // Ignore "foo.a" if "foo" is dirty already.\n  var minimal = [],\n      lastPath,\n      top;\n\n  all.forEach(function(item) {\n    if (!item) {\n      return;\n    }\n    if (item.path.indexOf(lastPath) !== 0) {\n      lastPath = item.path + \'.\';\n      minimal.push(item);\n      top = item;\n    } else {\n      // special case for top level MongooseArrays\n      if (top.value && top.value._atomics && top.value.hasAtomics()) {\n        // the `top` array itself and a sub path of `top` are being modified.\n        // the only way to honor all of both modifications is through a $set\n        // of entire array.\n        top.value._atomics = {};\n        top.value._atomics.$set = top.value;\n      }\n    }\n  });\n\n  top = lastPath = null;\n  return minimal;\n}',
  model: 'function model(name) {\n  return this.db.model(name);\n}',
  '$isDefault': 'function (path) {\n  return (path in this.$__.activePaths.states.default);\n}',
  '$__original_remove': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  remove: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populate: 'function populate() {\n  if (arguments.length === 0) {\n    return this;\n  }\n\n  var pop = this.$__.populate || (this.$__.populate = {});\n  var args = utils.args(arguments);\n  var fn;\n\n  if (typeof args[args.length - 1] === \'function\') {\n    fn = args.pop();\n  }\n\n  // allow `doc.populate(callback)`\n  if (args.length) {\n    // use hash to remove duplicate paths\n    var res = utils.populate.apply(null, args);\n    for (var i = 0; i < res.length; ++i) {\n      pop[res[i].path] = res[i];\n    }\n  }\n\n  if (fn) {\n    var paths = utils.object.vals(pop);\n    this.$__.populate = undefined;\n    paths.__noPromise = true;\n    this.constructor.populate(this, paths, fn);\n  }\n\n  return this;\n}',
  '$__shouldModify': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  if (this.isNew) {\n    return true;\n  }\n\n  if (undefined === val && !this.isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (undefined === val && path in this.$__.activePaths.states.default) {\n    // we\'re just unsetting the default value which was never saved\n    return false;\n  }\n\n  // gh-3992: if setting a populated field to a doc, don\'t mark modified\n  // if they have the same _id\n  if (this.populated(path) &&\n      val instanceof Document &&\n      deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal || this.get(path))) {\n    return true;\n  }\n\n  if (!constructing &&\n      val !== null &&\n      val !== undefined &&\n      path in this.$__.activePaths.states.default &&\n      deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n  return false;\n}',
  '$__': '[object Object]',
  '$__fullPath': 'function (path) {\n  // overridden in SubDocuments\n  return path || \'\';\n}',
  _pres: '[object Object]',
  inspect: 'function (options) {\n  var isPOJO = options &&\n    utils.getFunctionName(options.constructor) === \'Object\';\n  var opts;\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n    opts.retainKeyOrder = true;\n  }\n  return this.toObject(opts);\n}',
  '$__reset': 'function reset() {\n  var _this = this;\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return _this.getValue(i);\n  })\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  })\n  .forEach(function(array) {\n    var i = array.length;\n    while (i--) {\n      var doc = array[i];\n      if (!doc) {\n        continue;\n      }\n      doc.$__reset();\n    }\n  });\n\n  // clear atomics\n  this.$__dirty().forEach(function(dirt) {\n    var type = dirt.value;\n    if (type && type._atomics) {\n      type._atomics = {};\n    }\n  });\n\n  // Clear \'dirty\' cache\n  this.$__.activePaths.clear(\'modify\');\n  this.$__.activePaths.clear(\'default\');\n  this.$__.validationError = undefined;\n  this.errors = undefined;\n  _this = this;\n  this.schema.requiredPaths().forEach(function(path) {\n    _this.$__.activePaths.require(path);\n  });\n\n  return this;\n}',
  init: 'function (doc, opts, fn) {\n  // do not prefix this method with $__ since its\n  // used by public hooks\n\n  if (typeof opts === \'function\') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.isNew = false;\n\n  // handle docs with populated paths\n  // If doc._id is not null or undefined\n  if (doc._id !== null && doc._id !== undefined &&\n    opts && opts.populated && opts.populated.length) {\n    var id = String(doc._id);\n    for (var i = 0; i < opts.populated.length; ++i) {\n      var item = opts.populated[i];\n      if (item.isVirtual) {\n        this.populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.populated(item.path, item._docs[id], item);\n      }\n    }\n  }\n\n  init(this, doc, this._doc);\n  this.$__storeShard();\n\n  this.emit(\'init\', this);\n  this.constructor.emit(\'init\', this);\n\n  if (fn) {\n    fn(null);\n  }\n  return this;\n}',
  setMaxListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  initializeTimestamps: 'function () {\n      if (!this.get(createdAt)) {\n        this.set(createdAt, new Date());\n      }\n      if (!this.get(updatedAt)) {\n        this.set(updatedAt, new Date());\n      }\n      return this;\n    }',
  once: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  __v: '0',
  '$toObject': 'function (options, json) {\n  var defaultOptions = {\n    transform: true,\n    json: json,\n    retainKeyOrder: this.schema.options.retainKeyOrder,\n    flattenDecimals: true\n  };\n\n  // _isNested will only be true if this is not the top level document, we\n  // should never depopulate\n  if (options && options.depopulate && options._isNested && this.$__.wasPopulated) {\n    // populated paths that we set to a document\n    return clone(this._id, options);\n  }\n\n  // When internally saving this document we always pass options,\n  // bypassing the custom schema options.\n  if (!(options && utils.getFunctionName(options.constructor) === \'Object\') ||\n      (options && options._useSchemaOptions)) {\n    if (json) {\n      options = this.schema.options.toJSON ?\n        clone(this.schema.options.toJSON) :\n        {};\n      options.json = true;\n      options._useSchemaOptions = true;\n    } else {\n      options = this.schema.options.toObject ?\n        clone(this.schema.options.toObject) :\n        {};\n      options.json = false;\n      options._useSchemaOptions = true;\n    }\n  }\n\n  for (var key in defaultOptions) {\n    if (options[key] === undefined) {\n      options[key] = defaultOptions[key];\n    }\n  }\n\n  (\'minimize\' in options) || (options.minimize = this.schema.options.minimize);\n\n  // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n  var originalTransform = options.transform;\n\n  options._isNested = true;\n\n  var ret = clone(this._doc, options) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, \'paths\', options);\n    // applyGetters for paths will add nested empty objects;\n    // if minimize is set, we need to remove them.\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || options.getters && options.virtuals !== false) {\n    applyGetters(this, ret, \'virtuals\', options);\n  }\n\n  if (options.versionKey === false && this.schema.options.versionKey) {\n    delete ret[this.schema.options.versionKey];\n  }\n\n  var transform = options.transform;\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema\'s transform and\n  // not the parent schema\'s\n  if (transform === true ||\n      (this.schema.options.toObject && transform)) {\n    var opts = options.json ? this.schema.options.toJSON : this.schema.options.toObject;\n\n    if (opts) {\n      transform = (typeof options.transform === \'function\' ? options.transform : opts.transform);\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === \'function\') {\n    var xformed = transform(this, ret, options);\n    if (typeof xformed !== \'undefined\') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n}',
  '$hook': 'function (name, fn, errorCb) {\n    if (arguments.length === 1 && typeof name === \'object\') {\n      for (var k in name) { // `name` is a hash of hookName->hookFn\n        this.$hook(k, name[k]);\n      }\n      return;\n    }\n\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {}\n      , posts = proto._posts = proto._posts || {};\n    pres[name] = pres[name] || [];\n    posts[name] = posts[name] || [];\n\n    proto[name] = function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    };\n    \n    proto[name].numAsyncPres = 0;\n\n    return this;\n  }',
  '$__set': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  var shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts,\n    schema, val, priorVal);\n  var _this = this;\n\n  if (shouldModify) {\n    this.markModified(pathToMark, val);\n\n    // handle directly setting arrays (gh-1126)\n    MongooseArray || (MongooseArray = require(\'./types/array\'));\n    if (val && val.isMongooseArray) {\n      val._registerAtomic(\'$set\', val);\n\n      // Update embedded document parent references (gh-5189)\n      if (val.isMongooseDocumentArray) {\n        val.forEach(function(item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      }\n\n      // Small hack for gh-1638: if we\'re overwriting the entire array, ignore\n      // paths that were modified before the array overwrite\n      this.$__.activePaths.forEach(function(modifiedPath) {\n        if (modifiedPath.indexOf(path + \'.\') === 0) {\n          _this.$__.activePaths.ignore(modifiedPath);\n        }\n      });\n    }\n  }\n\n  var obj = this._doc;\n  var i = 0;\n  var l = parts.length;\n  var cur = \'\';\n\n  for (; i < l; i++) {\n    var next = i + 1;\n    var last = next === l;\n    cur += (cur ? \'.\' + parts[i] : parts[i]);\n\n    if (last) {\n      obj[parts[i]] = val;\n    } else {\n      if (obj[parts[i]] && utils.getFunctionName(obj[parts[i]].constructor) === \'Object\') {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        this.set(cur, {});\n        obj = obj[parts[i]];\n      }\n    }\n  }\n}',
  name: '222',
  isNew: 'false',
  unmarkModified: 'function (path) {\n  this.$__.activePaths.init(path);\n}',
  validateSync: 'function (pathsToValidate) {\n  var _this = this;\n\n  if (typeof pathsToValidate === \'string\') {\n    pathsToValidate = pathsToValidate.split(\' \');\n  }\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (pathsToValidate && pathsToValidate.length) {\n    var tmp = [];\n    for (var i = 0; i < paths.length; ++i) {\n      if (pathsToValidate.indexOf(paths[i]) !== -1) {\n        tmp.push(paths[i]);\n      }\n    }\n    paths = tmp;\n  }\n\n  var validating = {};\n\n  paths.forEach(function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n\n    var p = _this.schema.path(path);\n    if (!p) {\n      return;\n    }\n    if (!_this.$isValid(path)) {\n      return;\n    }\n\n    var val = _this.getValue(path);\n    var err = p.doValidateSync(val, _this);\n    if (err) {\n      _this.invalidate(path, err, undefined, true);\n    }\n  });\n\n  var err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n  _this.emit(\'validate\', _this);\n  _this.constructor.emit(\'validate\', _this);\n\n  if (err) {\n    for (var key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n}',
  errors: 'undefined',
  addListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  setValue: 'function (path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n}',
  '$__where': 'function _where(where) {\n  where || (where = {});\n\n  var paths,\n      len;\n\n  if (!where._id) {\n    where._id = this._doc._id;\n  }\n\n  if (this.$__.shardval) {\n    paths = Object.keys(this.$__.shardval);\n    len = paths.length;\n\n    for (var i = 0; i < len; ++i) {\n      where[paths[i]] = this.$__.shardval[paths[i]];\n    }\n  }\n\n  if (this._doc._id == null) {\n    return new Error(\'No _id found on document!\');\n  }\n\n  return where;\n}',
  invalidate: 'function (path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === \'string\') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || \'user defined\',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.errors[path] = err;\n  return this.$__.validationError;\n}',
  _doc: '[object Object]',
  execPopulate: 'function () {\n  var Promise = PromiseProvider.get();\n  var _this = this;\n  return new Promise.ES6(function(resolve, reject) {\n    _this.populate(function(error, res) {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(res);\n      }\n    });\n  });\n}',
  isSelected: 'function isSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    i = paths.length;\n    var pathDot = path + \'.\';\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n\n      if (cur.indexOf(pathDot) === 0) {\n        return inclusive || cur !== pathDot;\n      }\n\n      if (pathDot.indexOf(cur + \'.\') === 0) {\n        return inclusive;\n      }\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  _id: '5902b753c5756d72945d90b3',
  toString: 'function () {\n  return inspect(this.inspect());\n}',
  '$post': 'function (name, isAsync, fn) {\n    if (arguments.length === 2) {\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , posts = proto._posts = proto._posts || {};\n    \n    this._lazySetupHooks(proto, name);\n    (posts[name] = posts[name] || []).push(fn);\n    return this;\n  }',
  '$__handleSave': 'function (options, callback) {\n  var _this = this;\n  var i;\n  var keys;\n  var len;\n  if (!options.safe && this.schema.options.safe) {\n    options.safe = this.schema.options.safe;\n  }\n  if (typeof options.safe === \'boolean\') {\n    options.safe = null;\n  }\n\n  if (this.isNew) {\n    // send entire doc\n    var toObjectOptions = {};\n\n    toObjectOptions.retainKeyOrder = this.schema.options.retainKeyOrder;\n    toObjectOptions.depopulate = 1;\n    toObjectOptions._skipDepopulateTopLevel = true;\n    toObjectOptions.transform = false;\n    toObjectOptions.flattenDecimals = false;\n\n    var obj = this.toObject(toObjectOptions);\n\n    if (!utils.object.hasOwnProperty(obj || {}, \'_id\')) {\n      // documents must have an _id else mongoose won\'t know\n      // what to update later if more changes are made. the user\n      // wouldn\'t know what _id was generated by mongodb either\n      // nor would the ObjectId generated my mongodb necessarily\n      // match the schema definition.\n      setTimeout(function() {\n        callback(new Error(\'document must have an _id before saving\'));\n      }, 0);\n      return;\n    }\n\n    this.$__version(true, obj);\n    this.collection.insert(obj, options.safe, function(err, ret) {\n      if (err) {\n        _this.isNew = true;\n        _this.emit(\'isNew\', true);\n        _this.constructor.emit(\'isNew\', true);\n\n        callback(err);\n        return;\n      }\n\n      callback(null, ret);\n    });\n    this.$__reset();\n    this.isNew = false;\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n    // Make it possible to retry the insert\n    this.$__.inserting = true;\n  } else {\n    // Make sure we don\'t treat it as a new object on error,\n    // since it already exists\n    this.$__.inserting = false;\n\n    var delta = this.$__delta();\n\n    if (delta) {\n      if (delta instanceof Error) {\n        callback(delta);\n        return;\n      }\n\n      var where = this.$__where(delta[0]);\n      if (where instanceof Error) {\n        callback(where);\n        return;\n      }\n\n      if (this.$where) {\n        keys = Object.keys(this.$where);\n        len = keys.length;\n        for (i = 0; i < len; ++i) {\n          where[keys[i]] = this.$where[keys[i]];\n        }\n      }\n\n      this.collection.update(where, delta[1], options.safe, function(err, ret) {\n        if (err) {\n          callback(err);\n          return;\n        }\n        ret.$where = where;\n        callback(null, ret);\n      });\n    } else {\n      this.$__reset();\n      callback();\n      return;\n    }\n\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n  }\n}',
  '$ignore': 'function (path) {\n  this.$__.activePaths.ignore(path);\n}',
  emit: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  removePre: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , pres = proto._pres || (proto._pres || {});\n    if (!pres[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all pre callbacks for hook `name`\n      pres[name].length = 0;\n    } else {\n      pres[name] = pres[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  toJSON: 'function (options) {\n  return this.$toObject(options, true);\n}',
  '$__handleReject': 'function handleReject(err) {\n  // emit on the Model if listening\n  if (this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  } else if (this.constructor.listeners && this.constructor.listeners(\'error\').length) {\n    this.constructor.emit(\'error\', err);\n  } else if (this.listeners && this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  }\n}' }
[2017-05-04 16:17:36.971] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:17:36.985] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:17:36.989] [INFO] app - Redis client default is ready {}
[2017-05-04 16:17:37.193] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:17:39.635] [DEBUG] app - 2017-5-4 16:17:39 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:17:39.639] [WARN] console - this is a logger middleware.
[2017-05-04 16:17:39.655] [WARN] console - { _id: 5902b753c5756d72945d90b3,
  updatedAt: 2017-04-28T03:30:27.167Z,
  createdAt: 2017-04-28T03:30:27.167Z,
  username: '222',
  __v: 0 }
[2017-05-04 16:18:03.964] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:18:03.978] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:18:03.981] [INFO] app - Redis client default is ready {}
[2017-05-04 16:18:04.202] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:18:04.915] [DEBUG] app - 2017-5-4 16:18:04 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:18:04.919] [WARN] console - this is a logger middleware.
[2017-05-04 16:18:04.941] [WARN] console - { username: '222', id: '5902b753c5756d72945d90b3' }
[2017-05-04 16:18:19.559] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:18:19.574] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:18:19.577] [INFO] app - Redis client default is ready {}
[2017-05-04 16:18:19.812] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:18:20.678] [DEBUG] app - 2017-5-4 16:18:20 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:18:20.681] [WARN] console - this is a logger middleware.
[2017-05-04 16:18:20.700] [WARN] console - { username: '222', id: '5902b753c5756d72945d90b3' }
[2017-05-04 16:18:23.346] [DEBUG] app - 2017-5-4 16:18:23 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:18:23.346] [WARN] console - this is a logger middleware.
[2017-05-04 16:18:23.349] [WARN] console - { username: '222', id: '5902b753c5756d72945d90b3' }
[2017-05-04 16:18:38.763] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:18:38.775] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:18:38.780] [INFO] app - Redis client default is ready {}
[2017-05-04 16:18:38.977] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:18:39.665] [DEBUG] app - 2017-5-4 16:18:39 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:18:39.669] [WARN] console - this is a logger middleware.
[2017-05-04 16:18:39.688] [WARN] console - json ********* { username: '222', id: '5902b753c5756d72945d90b3' }
[2017-05-04 16:18:48.853] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:18:48.865] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:18:48.868] [INFO] app - Redis client default is ready {}
[2017-05-04 16:18:49.048] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:18:50.164] [DEBUG] app - 2017-5-4 16:18:50 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:18:50.168] [WARN] console - this is a logger middleware.
[2017-05-04 16:18:50.186] [WARN] console - json ********* { username: '222', id: '5902b753c5756d72945d90b3' }
[2017-05-04 16:18:50.192] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type InternalCache.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:18:50.192] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:18:50.192] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Object.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:18:50.192] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type NativeConnection.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:18:50.192] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:18:50.193] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type ObjectID.
This is converted to "5902b753c5756d72945d90b3" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:18:50.194] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Schema.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:18:50.194] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type NativeCollection.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:18:50.196] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Object.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:18:50.196] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Object.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:19:09.416] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:19:09.427] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:19:09.430] [INFO] app - Redis client default is ready {}
[2017-05-04 16:19:09.614] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:19:11.476] [DEBUG] app - 2017-5-4 16:19:11 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:19:11.480] [WARN] console - this is a logger middleware.
[2017-05-04 16:19:11.499] [WARN] console - json ********* { username: '222', id: '5902b753c5756d72945d90b3' }
[2017-05-04 16:19:11.504] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type InternalCache.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:19:11.504] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:19:11.504] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Object.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:19:11.504] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type NativeConnection.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:19:11.505] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:19:11.505] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type ObjectID.
This is converted to "5902b753c5756d72945d90b3" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:19:11.505] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Schema.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:19:11.505] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type NativeCollection.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:19:11.506] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Object.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:19:11.507] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Object.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:19:11.513] [WARN] console - { depopulate: 'function (path) {\n  var populatedIds = this.populated(path);\n  if (!populatedIds) {\n    return;\n  }\n  delete this.$__.populated[path];\n  this.set(path, populatedIds);\n  return this;\n}',
  equals: 'function (doc) {\n  if (!doc) {\n    return false;\n  }\n\n  var tid = this.get(\'_id\');\n  var docid = doc.get ? doc.get(\'_id\') : doc;\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals\n      ? tid.equals(docid)\n      : tid === docid;\n}',
  _posts: '[object Object]',
  '$__getAllSubdocs': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  function docReducer(seed, path) {\n    var val = this[path];\n\n    if (val instanceof Embedded) {\n      seed.push(val);\n    }\n    if (val && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(docReducer.bind(val._doc), seed);\n      seed.push(val);\n    }\n    if (val && val.isMongooseDocumentArray) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n        seed = Object.keys(doc._doc).reduce(docReducer.bind(doc._doc), seed);\n      });\n    } else if (val instanceof Document && val.$__isNested) {\n      if (val) {\n        seed = Object.keys(val).reduce(docReducer.bind(val), seed);\n      }\n    }\n    return seed;\n  }\n\n  var subDocs = Object.keys(this._doc).reduce(docReducer.bind(this), []);\n\n  return subDocs;\n}',
  '$__original_save': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  removeListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  '$__getArrayPathsToValidate': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  // validate all document arrays.\n  return this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return this.getValue(i);\n  }.bind(this))\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  }).reduce(function(seed, array) {\n    return seed.concat(array);\n  }, [])\n  .filter(function(doc) {\n    return doc;\n  });\n}',
  schema: '[object Object]',
  removeAllListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  save: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  isDirectSelected: 'function isDirectSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  removePost: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , posts = proto._posts || (proto._posts || {});\n    if (!posts[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all post callbacks for hook `name`\n      posts[name].length = 0;\n    } else {\n      posts[name] = posts[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  _lazySetupHooks: 'function (proto, methodName, errorCb) {\n    if (\'undefined\' === typeof proto[methodName].numAsyncPres) {\n      this.$hook(methodName, proto[methodName], errorCb);\n    }\n  }',
  toBSON: 'function () {\n  return this.toObject({\n    transform: false,\n    virtuals: false,\n    _skipDepopulateTopLevel: true,\n    depopulate: true,\n    flattenDecimals: false\n  });\n}',
  markModified: 'function (path) {\n  this.$__.activePaths.modify(path);\n}',
  on: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  increment: 'function increment() {\n  this.$__.version = VERSION_ALL;\n  return this;\n}',
  validate: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populated: 'function (path, val, options) {\n  // val and options are internal\n\n  if (val === null || val === void 0) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    var v = this.$__.populated[path];\n    if (v) {\n      return v.value;\n    }\n    return undefined;\n  }\n\n  // internal\n\n  if (val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    return this.$__.populated[path];\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = {value: val, options: options};\n  return val;\n}',
  update: 'function update() {\n  var args = utils.args(arguments);\n  args.unshift({_id: this._id});\n  return this.constructor.update.apply(this.constructor, args);\n}',
  id: '5902b753c5756d72945d90b3',
  '$__setSchema': 'function (schema) {\n  compile(schema.tree, this, undefined, schema.options);\n  this.schema = schema;\n}',
  isInit: 'function (path) {\n  return (path in this.$__.activePaths.states.init);\n}',
  '$__validate': 'function (callback) {\n  var _this = this;\n  var _complete = function() {\n    var err = _this.$__.validationError;\n    _this.$__.validationError = undefined;\n    _this.emit(\'validate\', _this);\n    _this.constructor.emit(\'validate\', _this);\n    if (err) {\n      for (var key in err.errors) {\n        // Make sure cast errors persist\n        if (!_this.__parent && err.errors[key] instanceof MongooseError.CastError) {\n          _this.invalidate(key, err.errors[key]);\n        }\n      }\n\n      return err;\n    }\n  };\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (paths.length === 0) {\n    process.nextTick(function() {\n      var error = _complete();\n      if (error) {\n        return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n          callback(error);\n        });\n      }\n      callback();\n    });\n  }\n\n  var validating = {},\n      total = 0;\n\n  var complete = function() {\n    var error = _complete();\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n    callback();\n  };\n\n  var validatePath = function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n    total++;\n\n    process.nextTick(function() {\n      var p = _this.schema.path(path);\n      if (!p) {\n        return --total || complete();\n      }\n\n      // If user marked as invalid or there was a cast error, don\'t validate\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      var val = _this.getValue(path);\n      p.doValidate(val, function(err) {\n        if (err) {\n          _this.invalidate(path, err, undefined, true);\n        }\n        --total || complete();\n      }, _this);\n    });\n  };\n\n  paths.forEach(validatePath);\n}',
  db: '[object Object]',
  username: '222',
  '$__original_validate': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  discriminators: 'undefined',
  isModified: 'function (paths) {\n  if (paths) {\n    if (!Array.isArray(paths)) {\n      paths = paths.split(\' \');\n    }\n    var modified = this.modifiedPaths();\n    var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n    var isModifiedChild = paths.some(function(path) {\n      return !!~modified.indexOf(path);\n    });\n    return isModifiedChild || paths.some(function(path) {\n      return directModifiedPaths.some(function(mod) {\n        return mod === path || path.indexOf(mod + \'.\') === 0;\n      });\n    });\n  }\n  return this.$__.activePaths.some(\'modify\');\n}',
  '$pre': 'function (name, isAsync, fn, errorCb) {\n    if (\'boolean\' !== typeof arguments[1]) {\n      errorCb = fn;\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {};\n\n    this._lazySetupHooks(proto, name, errorCb);\n\n    if (fn.isAsync = isAsync) {\n      proto[name].numAsyncPres++;\n    }\n\n    (pres[name] = pres[name] || []).push(fn);\n    return this;\n  }',
  toObject: 'function (options) {\n  return this.$toObject(options);\n}',
  '$markValid': 'function (path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n}',
  '$__buildDoc': 'function (obj, fields, skipId) {\n  var doc = {};\n  var exclude = null;\n  var keys;\n  var ki;\n  var _this = this;\n\n  // determine if this doc is a result of a query with\n  // excluded fields\n\n  if (fields && utils.getFunctionName(fields.constructor) === \'Object\') {\n    keys = Object.keys(fields);\n    ki = keys.length;\n\n    if (ki === 1 && keys[0] === \'_id\') {\n      exclude = !!fields[keys[ki]];\n    } else {\n      while (ki--) {\n        if (keys[ki] !== \'_id\' &&\n            (!fields[keys[ki]] || typeof fields[keys[ki]] !== \'object\')) {\n          exclude = !fields[keys[ki]];\n          break;\n        }\n      }\n    }\n  }\n\n  var paths = Object.keys(this.schema.paths);\n  var plen = paths.length;\n  var ii = 0;\n\n  var hasIncludedChildren = {};\n  if (exclude === false && fields) {\n    keys = Object.keys(fields);\n    for (var j = 0; j < keys.length; ++j) {\n      var parts = keys[j].split(\'.\');\n      var c = [];\n      for (var k = 0; k < parts.length; ++k) {\n        c.push(parts[k]);\n        hasIncludedChildren[c.join(\'.\')] = 1;\n      }\n    }\n  }\n\n  for (; ii < plen; ++ii) {\n    var p = paths[ii];\n\n    if (p === \'_id\') {\n      if (skipId) {\n        continue;\n      }\n      if (obj && \'_id\' in obj) {\n        continue;\n      }\n    }\n\n    var type = this.schema.paths[p];\n    var path = p.split(\'.\');\n    var len = path.length;\n    var last = len - 1;\n    var curPath = \'\';\n    var doc_ = doc;\n    var i = 0;\n    var included = false;\n\n    for (; i < len; ++i) {\n      var piece = path[i],\n          def;\n\n      curPath += (!curPath.length ? \'\' : \'.\') + piece;\n\n      // support excluding intermediary levels\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i === last) {\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          } else if (included) {\n            // selected field\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          }\n        } else {\n          def = type.getDefault(_this, false);\n          if (typeof def !== \'undefined\') {\n            doc_[piece] = def;\n            _this.$__.activePaths.default(p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  return doc;\n}',
  getValue: 'function (path) {\n  return utils.getValue(path, this._doc);\n}',
  collection: '[object Object]',
  createdAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  '$isValid': 'function (path) {\n  return !this.$__.validationError || !this.$__.validationError.errors[path];\n}',
  '$__version': 'function (where, delta) {\n  var key = this.schema.options.versionKey;\n\n  if (where === true) {\n    // this is an insert\n    if (key) this.setValue(key, delta[key] = 0);\n    return;\n  }\n\n  // updates\n\n  // only apply versioning if our versionKey was selected. else\n  // there is no way to select the correct version. we could fail\n  // fast here and force them to include the versionKey but\n  // thats a bit intrusive. can we do this automatically?\n  if (!this.isSelected(key)) {\n    return;\n  }\n\n  // $push $addToSet don\'t need the where clause set\n  if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {\n    where[key] = this.getValue(key);\n  }\n\n  if (VERSION_INC === (VERSION_INC & this.$__.version)) {\n    if (!delta.$set || typeof delta.$set[key] === \'undefined\') {\n      delta.$inc || (delta.$inc = {});\n      delta.$inc[key] = 1;\n    }\n  }\n}',
  isDirectModified: 'function (path) {\n  return (path in this.$__.activePaths.states.modify);\n}',
  '$isMongooseModelPrototype': 'true',
  modifiedPaths: 'function () {\n  var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n  return directModifiedPaths.reduce(function(list, path) {\n    var parts = path.split(\'.\');\n    return list.concat(parts.reduce(function(chains, part, i) {\n      return chains.concat(parts.slice(0, i).concat(part).join(\'.\'));\n    }, []).filter(function(chain) {\n      return (list.indexOf(chain) === -1);\n    }));\n  }, []);\n}',
  updatedAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  get: 'function (path, type) {\n  var adhoc;\n  if (type) {\n    adhoc = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  var schema = this.$__path(path) || this.schema.virtualpath(path),\n      pieces = path.split(\'.\'),\n      obj = this._doc;\n\n  for (var i = 0, l = pieces.length; i < l; i++) {\n    obj = obj === null || obj === void 0\n        ? undefined\n        : obj[pieces[i]];\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  // Check if this path is populated - don\'t apply getters if it is,\n  // because otherwise its a nested object. See gh-3357\n  if (schema && !this.populated(path)) {\n    obj = schema.applyGetters(obj, this);\n  }\n\n  return obj;\n}',
  '$__path': 'function (path) {\n  var adhocs = this.$__.adhocPaths,\n      adhocType = adhocs && adhocs[path];\n\n  if (adhocType) {\n    return adhocType;\n  }\n  return this.schema.path(path);\n}',
  listeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  '$__storeShard': 'function () {\n  // backwards compat\n  var key = this.schema.options.shardKey || this.schema.options.shardkey;\n  if (!(key && utils.getFunctionName(key.constructor) === \'Object\')) {\n    return;\n  }\n\n  var orig = this.$__.shardval = {},\n      paths = Object.keys(key),\n      len = paths.length,\n      val;\n\n  for (var i = 0; i < len; ++i) {\n    val = this.getValue(paths[i]);\n    if (isMongooseObject(val)) {\n      orig[paths[i]] = val.toObject({depopulate: true, _isNested: true});\n    } else if (val !== null && val !== undefined && val.valueOf &&\n          // Explicitly don\'t take value of dates\n        (!val.constructor || utils.getFunctionName(val.constructor) !== \'Date\')) {\n      orig[paths[i]] = val.valueOf();\n    } else {\n      orig[paths[i]] = val;\n    }\n  }\n}',
  '$__dirty': 'function () {\n  var _this = this;\n\n  var all = this.$__.activePaths.map(\'modify\', function(path) {\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  });\n\n  // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n  all = all.concat(this.$__.activePaths.map(\'default\', function(path) {\n    if (path === \'_id\' || !_this.getValue(path)) {\n      return;\n    }\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n\n  // Sort dirty paths in a flat hierarchy.\n  all.sort(function(a, b) {\n    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));\n  });\n\n  // Ignore "foo.a" if "foo" is dirty already.\n  var minimal = [],\n      lastPath,\n      top;\n\n  all.forEach(function(item) {\n    if (!item) {\n      return;\n    }\n    if (item.path.indexOf(lastPath) !== 0) {\n      lastPath = item.path + \'.\';\n      minimal.push(item);\n      top = item;\n    } else {\n      // special case for top level MongooseArrays\n      if (top.value && top.value._atomics && top.value.hasAtomics()) {\n        // the `top` array itself and a sub path of `top` are being modified.\n        // the only way to honor all of both modifications is through a $set\n        // of entire array.\n        top.value._atomics = {};\n        top.value._atomics.$set = top.value;\n      }\n    }\n  });\n\n  top = lastPath = null;\n  return minimal;\n}',
  model: 'function model(name) {\n  return this.db.model(name);\n}',
  '$isDefault': 'function (path) {\n  return (path in this.$__.activePaths.states.default);\n}',
  '$__original_remove': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  remove: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populate: 'function populate() {\n  if (arguments.length === 0) {\n    return this;\n  }\n\n  var pop = this.$__.populate || (this.$__.populate = {});\n  var args = utils.args(arguments);\n  var fn;\n\n  if (typeof args[args.length - 1] === \'function\') {\n    fn = args.pop();\n  }\n\n  // allow `doc.populate(callback)`\n  if (args.length) {\n    // use hash to remove duplicate paths\n    var res = utils.populate.apply(null, args);\n    for (var i = 0; i < res.length; ++i) {\n      pop[res[i].path] = res[i];\n    }\n  }\n\n  if (fn) {\n    var paths = utils.object.vals(pop);\n    this.$__.populate = undefined;\n    paths.__noPromise = true;\n    this.constructor.populate(this, paths, fn);\n  }\n\n  return this;\n}',
  '$__shouldModify': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  if (this.isNew) {\n    return true;\n  }\n\n  if (undefined === val && !this.isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (undefined === val && path in this.$__.activePaths.states.default) {\n    // we\'re just unsetting the default value which was never saved\n    return false;\n  }\n\n  // gh-3992: if setting a populated field to a doc, don\'t mark modified\n  // if they have the same _id\n  if (this.populated(path) &&\n      val instanceof Document &&\n      deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal || this.get(path))) {\n    return true;\n  }\n\n  if (!constructing &&\n      val !== null &&\n      val !== undefined &&\n      path in this.$__.activePaths.states.default &&\n      deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n  return false;\n}',
  '$__': '[object Object]',
  '$__fullPath': 'function (path) {\n  // overridden in SubDocuments\n  return path || \'\';\n}',
  _pres: '[object Object]',
  inspect: 'function (options) {\n  var isPOJO = options &&\n    utils.getFunctionName(options.constructor) === \'Object\';\n  var opts;\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n    opts.retainKeyOrder = true;\n  }\n  return this.toObject(opts);\n}',
  '$__reset': 'function reset() {\n  var _this = this;\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return _this.getValue(i);\n  })\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  })\n  .forEach(function(array) {\n    var i = array.length;\n    while (i--) {\n      var doc = array[i];\n      if (!doc) {\n        continue;\n      }\n      doc.$__reset();\n    }\n  });\n\n  // clear atomics\n  this.$__dirty().forEach(function(dirt) {\n    var type = dirt.value;\n    if (type && type._atomics) {\n      type._atomics = {};\n    }\n  });\n\n  // Clear \'dirty\' cache\n  this.$__.activePaths.clear(\'modify\');\n  this.$__.activePaths.clear(\'default\');\n  this.$__.validationError = undefined;\n  this.errors = undefined;\n  _this = this;\n  this.schema.requiredPaths().forEach(function(path) {\n    _this.$__.activePaths.require(path);\n  });\n\n  return this;\n}',
  init: 'function (doc, opts, fn) {\n  // do not prefix this method with $__ since its\n  // used by public hooks\n\n  if (typeof opts === \'function\') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.isNew = false;\n\n  // handle docs with populated paths\n  // If doc._id is not null or undefined\n  if (doc._id !== null && doc._id !== undefined &&\n    opts && opts.populated && opts.populated.length) {\n    var id = String(doc._id);\n    for (var i = 0; i < opts.populated.length; ++i) {\n      var item = opts.populated[i];\n      if (item.isVirtual) {\n        this.populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.populated(item.path, item._docs[id], item);\n      }\n    }\n  }\n\n  init(this, doc, this._doc);\n  this.$__storeShard();\n\n  this.emit(\'init\', this);\n  this.constructor.emit(\'init\', this);\n\n  if (fn) {\n    fn(null);\n  }\n  return this;\n}',
  setMaxListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  initializeTimestamps: 'function () {\n      if (!this.get(createdAt)) {\n        this.set(createdAt, new Date());\n      }\n      if (!this.get(updatedAt)) {\n        this.set(updatedAt, new Date());\n      }\n      return this;\n    }',
  once: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  __v: '0',
  '$toObject': 'function (options, json) {\n  var defaultOptions = {\n    transform: true,\n    json: json,\n    retainKeyOrder: this.schema.options.retainKeyOrder,\n    flattenDecimals: true\n  };\n\n  // _isNested will only be true if this is not the top level document, we\n  // should never depopulate\n  if (options && options.depopulate && options._isNested && this.$__.wasPopulated) {\n    // populated paths that we set to a document\n    return clone(this._id, options);\n  }\n\n  // When internally saving this document we always pass options,\n  // bypassing the custom schema options.\n  if (!(options && utils.getFunctionName(options.constructor) === \'Object\') ||\n      (options && options._useSchemaOptions)) {\n    if (json) {\n      options = this.schema.options.toJSON ?\n        clone(this.schema.options.toJSON) :\n        {};\n      options.json = true;\n      options._useSchemaOptions = true;\n    } else {\n      options = this.schema.options.toObject ?\n        clone(this.schema.options.toObject) :\n        {};\n      options.json = false;\n      options._useSchemaOptions = true;\n    }\n  }\n\n  for (var key in defaultOptions) {\n    if (options[key] === undefined) {\n      options[key] = defaultOptions[key];\n    }\n  }\n\n  (\'minimize\' in options) || (options.minimize = this.schema.options.minimize);\n\n  // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n  var originalTransform = options.transform;\n\n  options._isNested = true;\n\n  var ret = clone(this._doc, options) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, \'paths\', options);\n    // applyGetters for paths will add nested empty objects;\n    // if minimize is set, we need to remove them.\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || options.getters && options.virtuals !== false) {\n    applyGetters(this, ret, \'virtuals\', options);\n  }\n\n  if (options.versionKey === false && this.schema.options.versionKey) {\n    delete ret[this.schema.options.versionKey];\n  }\n\n  var transform = options.transform;\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema\'s transform and\n  // not the parent schema\'s\n  if (transform === true ||\n      (this.schema.options.toObject && transform)) {\n    var opts = options.json ? this.schema.options.toJSON : this.schema.options.toObject;\n\n    if (opts) {\n      transform = (typeof options.transform === \'function\' ? options.transform : opts.transform);\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === \'function\') {\n    var xformed = transform(this, ret, options);\n    if (typeof xformed !== \'undefined\') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n}',
  '$hook': 'function (name, fn, errorCb) {\n    if (arguments.length === 1 && typeof name === \'object\') {\n      for (var k in name) { // `name` is a hash of hookName->hookFn\n        this.$hook(k, name[k]);\n      }\n      return;\n    }\n\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {}\n      , posts = proto._posts = proto._posts || {};\n    pres[name] = pres[name] || [];\n    posts[name] = posts[name] || [];\n\n    proto[name] = function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    };\n    \n    proto[name].numAsyncPres = 0;\n\n    return this;\n  }',
  '$__set': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  var shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts,\n    schema, val, priorVal);\n  var _this = this;\n\n  if (shouldModify) {\n    this.markModified(pathToMark, val);\n\n    // handle directly setting arrays (gh-1126)\n    MongooseArray || (MongooseArray = require(\'./types/array\'));\n    if (val && val.isMongooseArray) {\n      val._registerAtomic(\'$set\', val);\n\n      // Update embedded document parent references (gh-5189)\n      if (val.isMongooseDocumentArray) {\n        val.forEach(function(item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      }\n\n      // Small hack for gh-1638: if we\'re overwriting the entire array, ignore\n      // paths that were modified before the array overwrite\n      this.$__.activePaths.forEach(function(modifiedPath) {\n        if (modifiedPath.indexOf(path + \'.\') === 0) {\n          _this.$__.activePaths.ignore(modifiedPath);\n        }\n      });\n    }\n  }\n\n  var obj = this._doc;\n  var i = 0;\n  var l = parts.length;\n  var cur = \'\';\n\n  for (; i < l; i++) {\n    var next = i + 1;\n    var last = next === l;\n    cur += (cur ? \'.\' + parts[i] : parts[i]);\n\n    if (last) {\n      obj[parts[i]] = val;\n    } else {\n      if (obj[parts[i]] && utils.getFunctionName(obj[parts[i]].constructor) === \'Object\') {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        this.set(cur, {});\n        obj = obj[parts[i]];\n      }\n    }\n  }\n}',
  name: '222',
  isNew: 'false',
  unmarkModified: 'function (path) {\n  this.$__.activePaths.init(path);\n}',
  validateSync: 'function (pathsToValidate) {\n  var _this = this;\n\n  if (typeof pathsToValidate === \'string\') {\n    pathsToValidate = pathsToValidate.split(\' \');\n  }\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (pathsToValidate && pathsToValidate.length) {\n    var tmp = [];\n    for (var i = 0; i < paths.length; ++i) {\n      if (pathsToValidate.indexOf(paths[i]) !== -1) {\n        tmp.push(paths[i]);\n      }\n    }\n    paths = tmp;\n  }\n\n  var validating = {};\n\n  paths.forEach(function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n\n    var p = _this.schema.path(path);\n    if (!p) {\n      return;\n    }\n    if (!_this.$isValid(path)) {\n      return;\n    }\n\n    var val = _this.getValue(path);\n    var err = p.doValidateSync(val, _this);\n    if (err) {\n      _this.invalidate(path, err, undefined, true);\n    }\n  });\n\n  var err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n  _this.emit(\'validate\', _this);\n  _this.constructor.emit(\'validate\', _this);\n\n  if (err) {\n    for (var key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n}',
  errors: 'undefined',
  addListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  setValue: 'function (path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n}',
  '$__where': 'function _where(where) {\n  where || (where = {});\n\n  var paths,\n      len;\n\n  if (!where._id) {\n    where._id = this._doc._id;\n  }\n\n  if (this.$__.shardval) {\n    paths = Object.keys(this.$__.shardval);\n    len = paths.length;\n\n    for (var i = 0; i < len; ++i) {\n      where[paths[i]] = this.$__.shardval[paths[i]];\n    }\n  }\n\n  if (this._doc._id == null) {\n    return new Error(\'No _id found on document!\');\n  }\n\n  return where;\n}',
  invalidate: 'function (path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === \'string\') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || \'user defined\',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.errors[path] = err;\n  return this.$__.validationError;\n}',
  _doc: '[object Object]',
  execPopulate: 'function () {\n  var Promise = PromiseProvider.get();\n  var _this = this;\n  return new Promise.ES6(function(resolve, reject) {\n    _this.populate(function(error, res) {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(res);\n      }\n    });\n  });\n}',
  isSelected: 'function isSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    i = paths.length;\n    var pathDot = path + \'.\';\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n\n      if (cur.indexOf(pathDot) === 0) {\n        return inclusive || cur !== pathDot;\n      }\n\n      if (pathDot.indexOf(cur + \'.\') === 0) {\n        return inclusive;\n      }\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  _id: '5902b753c5756d72945d90b3',
  toString: 'function () {\n  return inspect(this.inspect());\n}',
  '$post': 'function (name, isAsync, fn) {\n    if (arguments.length === 2) {\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , posts = proto._posts = proto._posts || {};\n    \n    this._lazySetupHooks(proto, name);\n    (posts[name] = posts[name] || []).push(fn);\n    return this;\n  }',
  '$__handleSave': 'function (options, callback) {\n  var _this = this;\n  var i;\n  var keys;\n  var len;\n  if (!options.safe && this.schema.options.safe) {\n    options.safe = this.schema.options.safe;\n  }\n  if (typeof options.safe === \'boolean\') {\n    options.safe = null;\n  }\n\n  if (this.isNew) {\n    // send entire doc\n    var toObjectOptions = {};\n\n    toObjectOptions.retainKeyOrder = this.schema.options.retainKeyOrder;\n    toObjectOptions.depopulate = 1;\n    toObjectOptions._skipDepopulateTopLevel = true;\n    toObjectOptions.transform = false;\n    toObjectOptions.flattenDecimals = false;\n\n    var obj = this.toObject(toObjectOptions);\n\n    if (!utils.object.hasOwnProperty(obj || {}, \'_id\')) {\n      // documents must have an _id else mongoose won\'t know\n      // what to update later if more changes are made. the user\n      // wouldn\'t know what _id was generated by mongodb either\n      // nor would the ObjectId generated my mongodb necessarily\n      // match the schema definition.\n      setTimeout(function() {\n        callback(new Error(\'document must have an _id before saving\'));\n      }, 0);\n      return;\n    }\n\n    this.$__version(true, obj);\n    this.collection.insert(obj, options.safe, function(err, ret) {\n      if (err) {\n        _this.isNew = true;\n        _this.emit(\'isNew\', true);\n        _this.constructor.emit(\'isNew\', true);\n\n        callback(err);\n        return;\n      }\n\n      callback(null, ret);\n    });\n    this.$__reset();\n    this.isNew = false;\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n    // Make it possible to retry the insert\n    this.$__.inserting = true;\n  } else {\n    // Make sure we don\'t treat it as a new object on error,\n    // since it already exists\n    this.$__.inserting = false;\n\n    var delta = this.$__delta();\n\n    if (delta) {\n      if (delta instanceof Error) {\n        callback(delta);\n        return;\n      }\n\n      var where = this.$__where(delta[0]);\n      if (where instanceof Error) {\n        callback(where);\n        return;\n      }\n\n      if (this.$where) {\n        keys = Object.keys(this.$where);\n        len = keys.length;\n        for (i = 0; i < len; ++i) {\n          where[keys[i]] = this.$where[keys[i]];\n        }\n      }\n\n      this.collection.update(where, delta[1], options.safe, function(err, ret) {\n        if (err) {\n          callback(err);\n          return;\n        }\n        ret.$where = where;\n        callback(null, ret);\n      });\n    } else {\n      this.$__reset();\n      callback();\n      return;\n    }\n\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n  }\n}',
  '$ignore': 'function (path) {\n  this.$__.activePaths.ignore(path);\n}',
  emit: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  removePre: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , pres = proto._pres || (proto._pres || {});\n    if (!pres[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all pre callbacks for hook `name`\n      pres[name].length = 0;\n    } else {\n      pres[name] = pres[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  toJSON: 'function (options) {\n  return this.$toObject(options, true);\n}',
  '$__handleReject': 'function handleReject(err) {\n  // emit on the Model if listening\n  if (this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  } else if (this.constructor.listeners && this.constructor.listeners(\'error\').length) {\n    this.constructor.emit(\'error\', err);\n  } else if (this.listeners && this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  }\n}',
  set: 'function (path, val, type, options) {\n  if (type && utils.getFunctionName(type.constructor) === \'Object\') {\n    options = type;\n    type = undefined;\n  }\n\n  var merge = options && options.merge,\n      adhoc = type && type !== true,\n      constructing = type === true,\n      adhocs;\n\n  var strict = options && \'strict\' in options\n      ? options.strict\n      : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  if (typeof path !== \'string\') {\n    // new Document({ key: val })\n\n    if (path === null || path === void 0) {\n      var _ = path;\n      path = val;\n      val = _;\n    } else {\n      var prefix = val\n          ? val + \'.\'\n          : \'\';\n\n      if (path instanceof Document) {\n        if (path.$__isNested) {\n          path = path.toObject();\n        } else {\n          path = path._doc;\n        }\n      }\n\n      var keys = Object.keys(path);\n      var len = keys.length;\n      var i = 0;\n      var pathtype;\n      var key;\n\n      if (len === 0 && !this.schema.options.minimize) {\n        if (val) {\n          this.set(val, {});\n        }\n        return this;\n      }\n\n      if (this.schema.options.retainKeyOrder) {\n        while (i < len) {\n          _handleIndex.call(this, i++);\n        }\n      } else {\n        while (len--) {\n          _handleIndex.call(this, len);\n        }\n      }\n\n      return this;\n    }\n  }\n\n  function _handleIndex(i) {\n    key = keys[i];\n    var pathName = prefix + key;\n    pathtype = this.schema.pathType(pathName);\n\n    if (path[key] !== null\n        && path[key] !== void 0\n          // need to know if plain object - no Buffer, ObjectId, ref, etc\n        && utils.isObject(path[key])\n        && (!path[key].constructor || utils.getFunctionName(path[key].constructor) === \'Object\')\n        && pathtype !== \'virtual\'\n        && pathtype !== \'real\'\n        && !(this.$__path(pathName) instanceof MixedSchema)\n        && !(this.schema.paths[pathName] &&\n        this.schema.paths[pathName].options &&\n        this.schema.paths[pathName].options.ref)) {\n      this.set(path[key], prefix + key, constructing);\n    } else if (strict) {\n      // Don\'t overwrite defaults with undefined keys (gh-3981)\n      if (constructing && path[key] === void 0 &&\n          this.get(key) !== void 0) {\n        return;\n      }\n\n      if (pathtype === \'real\' || pathtype === \'virtual\') {\n        // Check for setting single embedded schema to document (gh-3535)\n        var p = path[key];\n        if (this.schema.paths[pathName] &&\n            this.schema.paths[pathName].$isSingleNested &&\n            path[key] instanceof Document) {\n          p = p.toObject({ virtuals: false, transform: false });\n        }\n        this.set(prefix + key, p, constructing);\n      } else if (pathtype === \'nested\' && path[key] instanceof Document) {\n        this.set(prefix + key,\n            path[key].toObject({transform: false}), constructing);\n      } else if (strict === \'throw\') {\n        if (pathtype === \'nested\') {\n          throw new ObjectExpectedError(key, path[key]);\n        } else {\n          throw new StrictModeError(key);\n        }\n      }\n    } else if (path[key] !== void 0) {\n      this.set(prefix + key, path[key], constructing);\n    }\n  }\n\n  var pathType = this.schema.pathType(path);\n  if (pathType === \'nested\' && val) {\n    if (utils.isObject(val) &&\n        (!val.constructor || utils.getFunctionName(val.constructor) === \'Object\')) {\n      if (!merge) {\n        this.setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      }\n\n      if (Object.keys(val).length === 0) {\n        this.setValue(path, {});\n        this.markModified(path);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        this.set(val, path, constructing);\n      }\n      return this;\n    }\n    this.invalidate(path, new MongooseError.CastError(\'Object\', val, path));\n    return this;\n  }\n\n  var schema;\n  var parts = path.split(\'.\');\n\n  if (pathType === \'adhocOrUndefined\' && strict) {\n    // check for roots that are Mixed types\n    var mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      var subpath = parts.slice(0, i + 1).join(\'.\');\n      schema = this.schema.path(subpath);\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n\n      // If path is underneath a virtual, bypass everything and just set it.\n      if (i + 1 < parts.length && this.schema.pathType(subpath) === \'virtual\') {\n        mpath.set(path, val, this);\n        return this;\n      }\n    }\n\n    if (!mixed) {\n      if (strict === \'throw\') {\n        throw new StrictModeError(path);\n      }\n      return this;\n    }\n  } else if (pathType === \'virtual\') {\n    schema = this.schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  var pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: "LEFT_SUBFIELD only supports Object"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    for (i = 0; i < parts.length; ++i) {\n      subpath = parts.slice(0, i + 1).join(\'.\');\n      if (this.isDirectModified(subpath) // earlier prefixes that are already\n            // marked as dirty have precedence\n          || this.get(subpath) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n\n  // if this doc is being constructed we should not trigger getters\n  var priorVal = constructing\n      ? undefined\n      : this.getValue(path);\n\n  if (!schema) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n    return this;\n  }\n\n  var shouldSet = true;\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    var didPopulate = false;\n    if (schema.options &&\n        schema.options.ref &&\n        val instanceof Document &&\n        (schema.options.ref === val.constructor.modelName || schema.options.ref === val.constructor.baseModelName)) {\n      if (this.ownerDocument) {\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val._id, {model: val.constructor});\n      } else {\n        this.populated(path, val._id, {model: val.constructor});\n      }\n      didPopulate = true;\n    }\n\n    var popOpts;\n    if (schema.options &&\n        Array.isArray(schema.options.type) &&\n        schema.options.type.length &&\n        schema.options.type[0].ref &&\n        Array.isArray(val) &&\n        val.length > 0 &&\n        val[0] instanceof Document &&\n        val[0].constructor.modelName &&\n        (schema.options.type[0].ref === val[0].constructor.baseModelName || schema.options.type[0].ref === val[0].constructor.modelName)) {\n      if (this.ownerDocument) {\n        popOpts = { model: val[0].constructor };\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val.map(function(v) { return v._id; }), popOpts);\n      } else {\n        popOpts = { model: val[0].constructor };\n        this.populated(path, val.map(function(v) { return v._id; }), popOpts);\n      }\n      didPopulate = true;\n    }\n    val = schema.applySetters(val, this, false, priorVal);\n\n    if (!didPopulate && this.$__.populated) {\n      delete this.$__.populated[path];\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    this.invalidate(path,\n      new MongooseError.CastError(schema.instance, val, path, e));\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n}',
  '$__delta': 'function () {\n  var dirty = this.$__dirty();\n  if (!dirty.length && VERSION_ALL !== this.$__.version) return;\n\n  var where = {},\n      delta = {},\n      len = dirty.length,\n      divergent = [],\n      d = 0;\n\n  where._id = this._doc._id;\n  if (where._id.toObject) {\n    where._id = where._id.toObject({ transform: false, depopulate: true });\n  }\n\n  for (; d < len; ++d) {\n    var data = dirty[d];\n    var value = data.value;\n\n    var match = checkDivergentArray(this, data.path, value);\n    if (match) {\n      divergent.push(match);\n      continue;\n    }\n\n    var pop = this.populated(data.path, true);\n    if (!pop && this.$__.selected) {\n      // If any array was selected using an $elemMatch projection, we alter the path and where clause\n      // NOTE: MongoDB only supports projected $elemMatch on top level array.\n      var pathSplit = data.path.split(\'.\');\n      var top = pathSplit[0];\n      if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {\n        // If the selected array entry was modified\n        if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === \'undefined\') {\n          where[top] = this.$__.selected[top];\n          pathSplit[1] = \'$\';\n          data.path = pathSplit.join(\'.\');\n        }\n        // if the selected array was modified in any other way throw an error\n        else {\n          divergent.push(data.path);\n          continue;\n        }\n      }\n    }\n\n    if (divergent.length) continue;\n\n    if (undefined === value) {\n      operand(this, where, delta, data, 1, \'$unset\');\n    } else if (value === null) {\n      operand(this, where, delta, data, null);\n    } else if (value._path && value._atomics) {\n      // arrays and other custom types (support plugins etc)\n      handleAtomics(this, where, delta, data, value);\n    } else if (value._path && Buffer.isBuffer(value)) {\n      // MongooseBuffer\n      value = value.toObject();\n      operand(this, where, delta, data, value);\n    } else {\n      value = utils.clone(value, {depopulate: 1, _isNested: true});\n      operand(this, where, delta, data, value);\n    }\n  }\n\n  if (divergent.length) {\n    return new DivergentArrayError(divergent);\n  }\n\n  if (this.$__.version) {\n    this.$__version(where, delta);\n  }\n\n  return [where, delta];\n}',
  '$__save': 'function (options, callback) {\n  var _this = this;\n\n  _this.$__handleSave(options, function(error, result) {\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.$__reset();\n    _this.$__storeShard();\n\n    var numAffected = 0;\n    if (result) {\n      if (Array.isArray(result)) {\n        numAffected = result.length;\n      } else if (result.result && result.result.n !== undefined) {\n        numAffected = result.result.n;\n      } else if (result.result && result.result.nModified !== undefined) {\n        numAffected = result.result.nModified;\n      } else {\n        numAffected = result;\n      }\n    }\n\n    // was this an update that required a version bump?\n    if (_this.$__.version && !_this.$__.inserting) {\n      var doIncrement = VERSION_INC === (VERSION_INC & _this.$__.version);\n      _this.$__.version = undefined;\n\n      if (numAffected <= 0) {\n        // the update failed. pass an error back\n        var err = new VersionError(_this);\n        return callback(err);\n      }\n\n      // increment version if was successful\n      if (doIncrement) {\n        var key = _this.schema.options.versionKey;\n        var version = _this.getValue(key) | 0;\n        _this.setValue(key, version + 1);\n      }\n    }\n\n    if (_this.schema.options &&\n        _this.schema.options.saveErrorIfNotFound &&\n        numAffected <= 0) {\n      error = new DocumentNotFoundError(result.$where);\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.emit(\'save\', _this, numAffected);\n    _this.constructor.emit(\'save\', _this, numAffected);\n    callback(null, _this, numAffected);\n  });\n}' }
[2017-05-04 16:19:20.175] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:19:20.186] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:19:20.188] [INFO] app - Redis client default is ready {}
[2017-05-04 16:19:20.391] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:19:22.079] [DEBUG] app - 2017-5-4 16:19:22 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:19:22.083] [WARN] console - this is a logger middleware.
[2017-05-04 16:19:22.101] [WARN] console - json ********* { username: '222', id: '5902b753c5756d72945d90b3' }
[2017-05-04 16:19:22.108] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type InternalCache.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:19:22.108] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:19:22.108] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Object.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:19:22.108] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type NativeConnection.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:19:22.108] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:19:22.109] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type ObjectID.
This is converted to "5902b753c5756d72945d90b3" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:19:22.109] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Schema.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:19:22.110] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type NativeCollection.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:19:22.111] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Object.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:19:22.111] [WARN] console - node_redis: Deprecated: The HMSET command contains a argument of type Object.
This is converted to "[object Object]" by using .toString() now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-04 16:19:22.117] [WARN] console - { isModified: 'function (paths) {\n  if (paths) {\n    if (!Array.isArray(paths)) {\n      paths = paths.split(\' \');\n    }\n    var modified = this.modifiedPaths();\n    var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n    var isModifiedChild = paths.some(function(path) {\n      return !!~modified.indexOf(path);\n    });\n    return isModifiedChild || paths.some(function(path) {\n      return directModifiedPaths.some(function(mod) {\n        return mod === path || path.indexOf(mod + \'.\') === 0;\n      });\n    });\n  }\n  return this.$__.activePaths.some(\'modify\');\n}',
  '$pre': 'function (name, isAsync, fn, errorCb) {\n    if (\'boolean\' !== typeof arguments[1]) {\n      errorCb = fn;\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {};\n\n    this._lazySetupHooks(proto, name, errorCb);\n\n    if (fn.isAsync = isAsync) {\n      proto[name].numAsyncPres++;\n    }\n\n    (pres[name] = pres[name] || []).push(fn);\n    return this;\n  }',
  errors: 'undefined',
  addListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  setValue: 'function (path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n}',
  '$__where': 'function _where(where) {\n  where || (where = {});\n\n  var paths,\n      len;\n\n  if (!where._id) {\n    where._id = this._doc._id;\n  }\n\n  if (this.$__.shardval) {\n    paths = Object.keys(this.$__.shardval);\n    len = paths.length;\n\n    for (var i = 0; i < len; ++i) {\n      where[paths[i]] = this.$__.shardval[paths[i]];\n    }\n  }\n\n  if (this._doc._id == null) {\n    return new Error(\'No _id found on document!\');\n  }\n\n  return where;\n}',
  _doc: '[object Object]',
  _id: '5902b753c5756d72945d90b3',
  '$post': 'function (name, isAsync, fn) {\n    if (arguments.length === 2) {\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , posts = proto._posts = proto._posts || {};\n    \n    this._lazySetupHooks(proto, name);\n    (posts[name] = posts[name] || []).push(fn);\n    return this;\n  }',
  getValue: 'function (path) {\n  return utils.getValue(path, this._doc);\n}',
  '$__handleSave': 'function (options, callback) {\n  var _this = this;\n  var i;\n  var keys;\n  var len;\n  if (!options.safe && this.schema.options.safe) {\n    options.safe = this.schema.options.safe;\n  }\n  if (typeof options.safe === \'boolean\') {\n    options.safe = null;\n  }\n\n  if (this.isNew) {\n    // send entire doc\n    var toObjectOptions = {};\n\n    toObjectOptions.retainKeyOrder = this.schema.options.retainKeyOrder;\n    toObjectOptions.depopulate = 1;\n    toObjectOptions._skipDepopulateTopLevel = true;\n    toObjectOptions.transform = false;\n    toObjectOptions.flattenDecimals = false;\n\n    var obj = this.toObject(toObjectOptions);\n\n    if (!utils.object.hasOwnProperty(obj || {}, \'_id\')) {\n      // documents must have an _id else mongoose won\'t know\n      // what to update later if more changes are made. the user\n      // wouldn\'t know what _id was generated by mongodb either\n      // nor would the ObjectId generated my mongodb necessarily\n      // match the schema definition.\n      setTimeout(function() {\n        callback(new Error(\'document must have an _id before saving\'));\n      }, 0);\n      return;\n    }\n\n    this.$__version(true, obj);\n    this.collection.insert(obj, options.safe, function(err, ret) {\n      if (err) {\n        _this.isNew = true;\n        _this.emit(\'isNew\', true);\n        _this.constructor.emit(\'isNew\', true);\n\n        callback(err);\n        return;\n      }\n\n      callback(null, ret);\n    });\n    this.$__reset();\n    this.isNew = false;\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n    // Make it possible to retry the insert\n    this.$__.inserting = true;\n  } else {\n    // Make sure we don\'t treat it as a new object on error,\n    // since it already exists\n    this.$__.inserting = false;\n\n    var delta = this.$__delta();\n\n    if (delta) {\n      if (delta instanceof Error) {\n        callback(delta);\n        return;\n      }\n\n      var where = this.$__where(delta[0]);\n      if (where instanceof Error) {\n        callback(where);\n        return;\n      }\n\n      if (this.$where) {\n        keys = Object.keys(this.$where);\n        len = keys.length;\n        for (i = 0; i < len; ++i) {\n          where[keys[i]] = this.$where[keys[i]];\n        }\n      }\n\n      this.collection.update(where, delta[1], options.safe, function(err, ret) {\n        if (err) {\n          callback(err);\n          return;\n        }\n        ret.$where = where;\n        callback(null, ret);\n      });\n    } else {\n      this.$__reset();\n      callback();\n      return;\n    }\n\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n  }\n}',
  '$__buildDoc': 'function (obj, fields, skipId) {\n  var doc = {};\n  var exclude = null;\n  var keys;\n  var ki;\n  var _this = this;\n\n  // determine if this doc is a result of a query with\n  // excluded fields\n\n  if (fields && utils.getFunctionName(fields.constructor) === \'Object\') {\n    keys = Object.keys(fields);\n    ki = keys.length;\n\n    if (ki === 1 && keys[0] === \'_id\') {\n      exclude = !!fields[keys[ki]];\n    } else {\n      while (ki--) {\n        if (keys[ki] !== \'_id\' &&\n            (!fields[keys[ki]] || typeof fields[keys[ki]] !== \'object\')) {\n          exclude = !fields[keys[ki]];\n          break;\n        }\n      }\n    }\n  }\n\n  var paths = Object.keys(this.schema.paths);\n  var plen = paths.length;\n  var ii = 0;\n\n  var hasIncludedChildren = {};\n  if (exclude === false && fields) {\n    keys = Object.keys(fields);\n    for (var j = 0; j < keys.length; ++j) {\n      var parts = keys[j].split(\'.\');\n      var c = [];\n      for (var k = 0; k < parts.length; ++k) {\n        c.push(parts[k]);\n        hasIncludedChildren[c.join(\'.\')] = 1;\n      }\n    }\n  }\n\n  for (; ii < plen; ++ii) {\n    var p = paths[ii];\n\n    if (p === \'_id\') {\n      if (skipId) {\n        continue;\n      }\n      if (obj && \'_id\' in obj) {\n        continue;\n      }\n    }\n\n    var type = this.schema.paths[p];\n    var path = p.split(\'.\');\n    var len = path.length;\n    var last = len - 1;\n    var curPath = \'\';\n    var doc_ = doc;\n    var i = 0;\n    var included = false;\n\n    for (; i < len; ++i) {\n      var piece = path[i],\n          def;\n\n      curPath += (!curPath.length ? \'\' : \'.\') + piece;\n\n      // support excluding intermediary levels\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i === last) {\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          } else if (included) {\n            // selected field\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          }\n        } else {\n          def = type.getDefault(_this, false);\n          if (typeof def !== \'undefined\') {\n            doc_[piece] = def;\n            _this.$__.activePaths.default(p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  return doc;\n}',
  '$ignore': 'function (path) {\n  this.$__.activePaths.ignore(path);\n}',
  removePre: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , pres = proto._pres || (proto._pres || {});\n    if (!pres[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all pre callbacks for hook `name`\n      pres[name].length = 0;\n    } else {\n      pres[name] = pres[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  collection: '[object Object]',
  emit: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  createdAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  '$__version': 'function (where, delta) {\n  var key = this.schema.options.versionKey;\n\n  if (where === true) {\n    // this is an insert\n    if (key) this.setValue(key, delta[key] = 0);\n    return;\n  }\n\n  // updates\n\n  // only apply versioning if our versionKey was selected. else\n  // there is no way to select the correct version. we could fail\n  // fast here and force them to include the versionKey but\n  // thats a bit intrusive. can we do this automatically?\n  if (!this.isSelected(key)) {\n    return;\n  }\n\n  // $push $addToSet don\'t need the where clause set\n  if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {\n    where[key] = this.getValue(key);\n  }\n\n  if (VERSION_INC === (VERSION_INC & this.$__.version)) {\n    if (!delta.$set || typeof delta.$set[key] === \'undefined\') {\n      delta.$inc || (delta.$inc = {});\n      delta.$inc[key] = 1;\n    }\n  }\n}',
  isDirectModified: 'function (path) {\n  return (path in this.$__.activePaths.states.modify);\n}',
  '$isMongooseModelPrototype': 'true',
  set: 'function (path, val, type, options) {\n  if (type && utils.getFunctionName(type.constructor) === \'Object\') {\n    options = type;\n    type = undefined;\n  }\n\n  var merge = options && options.merge,\n      adhoc = type && type !== true,\n      constructing = type === true,\n      adhocs;\n\n  var strict = options && \'strict\' in options\n      ? options.strict\n      : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  if (typeof path !== \'string\') {\n    // new Document({ key: val })\n\n    if (path === null || path === void 0) {\n      var _ = path;\n      path = val;\n      val = _;\n    } else {\n      var prefix = val\n          ? val + \'.\'\n          : \'\';\n\n      if (path instanceof Document) {\n        if (path.$__isNested) {\n          path = path.toObject();\n        } else {\n          path = path._doc;\n        }\n      }\n\n      var keys = Object.keys(path);\n      var len = keys.length;\n      var i = 0;\n      var pathtype;\n      var key;\n\n      if (len === 0 && !this.schema.options.minimize) {\n        if (val) {\n          this.set(val, {});\n        }\n        return this;\n      }\n\n      if (this.schema.options.retainKeyOrder) {\n        while (i < len) {\n          _handleIndex.call(this, i++);\n        }\n      } else {\n        while (len--) {\n          _handleIndex.call(this, len);\n        }\n      }\n\n      return this;\n    }\n  }\n\n  function _handleIndex(i) {\n    key = keys[i];\n    var pathName = prefix + key;\n    pathtype = this.schema.pathType(pathName);\n\n    if (path[key] !== null\n        && path[key] !== void 0\n          // need to know if plain object - no Buffer, ObjectId, ref, etc\n        && utils.isObject(path[key])\n        && (!path[key].constructor || utils.getFunctionName(path[key].constructor) === \'Object\')\n        && pathtype !== \'virtual\'\n        && pathtype !== \'real\'\n        && !(this.$__path(pathName) instanceof MixedSchema)\n        && !(this.schema.paths[pathName] &&\n        this.schema.paths[pathName].options &&\n        this.schema.paths[pathName].options.ref)) {\n      this.set(path[key], prefix + key, constructing);\n    } else if (strict) {\n      // Don\'t overwrite defaults with undefined keys (gh-3981)\n      if (constructing && path[key] === void 0 &&\n          this.get(key) !== void 0) {\n        return;\n      }\n\n      if (pathtype === \'real\' || pathtype === \'virtual\') {\n        // Check for setting single embedded schema to document (gh-3535)\n        var p = path[key];\n        if (this.schema.paths[pathName] &&\n            this.schema.paths[pathName].$isSingleNested &&\n            path[key] instanceof Document) {\n          p = p.toObject({ virtuals: false, transform: false });\n        }\n        this.set(prefix + key, p, constructing);\n      } else if (pathtype === \'nested\' && path[key] instanceof Document) {\n        this.set(prefix + key,\n            path[key].toObject({transform: false}), constructing);\n      } else if (strict === \'throw\') {\n        if (pathtype === \'nested\') {\n          throw new ObjectExpectedError(key, path[key]);\n        } else {\n          throw new StrictModeError(key);\n        }\n      }\n    } else if (path[key] !== void 0) {\n      this.set(prefix + key, path[key], constructing);\n    }\n  }\n\n  var pathType = this.schema.pathType(path);\n  if (pathType === \'nested\' && val) {\n    if (utils.isObject(val) &&\n        (!val.constructor || utils.getFunctionName(val.constructor) === \'Object\')) {\n      if (!merge) {\n        this.setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      }\n\n      if (Object.keys(val).length === 0) {\n        this.setValue(path, {});\n        this.markModified(path);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        this.set(val, path, constructing);\n      }\n      return this;\n    }\n    this.invalidate(path, new MongooseError.CastError(\'Object\', val, path));\n    return this;\n  }\n\n  var schema;\n  var parts = path.split(\'.\');\n\n  if (pathType === \'adhocOrUndefined\' && strict) {\n    // check for roots that are Mixed types\n    var mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      var subpath = parts.slice(0, i + 1).join(\'.\');\n      schema = this.schema.path(subpath);\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n\n      // If path is underneath a virtual, bypass everything and just set it.\n      if (i + 1 < parts.length && this.schema.pathType(subpath) === \'virtual\') {\n        mpath.set(path, val, this);\n        return this;\n      }\n    }\n\n    if (!mixed) {\n      if (strict === \'throw\') {\n        throw new StrictModeError(path);\n      }\n      return this;\n    }\n  } else if (pathType === \'virtual\') {\n    schema = this.schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  var pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: "LEFT_SUBFIELD only supports Object"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    for (i = 0; i < parts.length; ++i) {\n      subpath = parts.slice(0, i + 1).join(\'.\');\n      if (this.isDirectModified(subpath) // earlier prefixes that are already\n            // marked as dirty have precedence\n          || this.get(subpath) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n\n  // if this doc is being constructed we should not trigger getters\n  var priorVal = constructing\n      ? undefined\n      : this.getValue(path);\n\n  if (!schema) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n    return this;\n  }\n\n  var shouldSet = true;\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    var didPopulate = false;\n    if (schema.options &&\n        schema.options.ref &&\n        val instanceof Document &&\n        (schema.options.ref === val.constructor.modelName || schema.options.ref === val.constructor.baseModelName)) {\n      if (this.ownerDocument) {\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val._id, {model: val.constructor});\n      } else {\n        this.populated(path, val._id, {model: val.constructor});\n      }\n      didPopulate = true;\n    }\n\n    var popOpts;\n    if (schema.options &&\n        Array.isArray(schema.options.type) &&\n        schema.options.type.length &&\n        schema.options.type[0].ref &&\n        Array.isArray(val) &&\n        val.length > 0 &&\n        val[0] instanceof Document &&\n        val[0].constructor.modelName &&\n        (schema.options.type[0].ref === val[0].constructor.baseModelName || schema.options.type[0].ref === val[0].constructor.modelName)) {\n      if (this.ownerDocument) {\n        popOpts = { model: val[0].constructor };\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val.map(function(v) { return v._id; }), popOpts);\n      } else {\n        popOpts = { model: val[0].constructor };\n        this.populated(path, val.map(function(v) { return v._id; }), popOpts);\n      }\n      didPopulate = true;\n    }\n    val = schema.applySetters(val, this, false, priorVal);\n\n    if (!didPopulate && this.$__.populated) {\n      delete this.$__.populated[path];\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    this.invalidate(path,\n      new MongooseError.CastError(schema.instance, val, path, e));\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n}',
  modifiedPaths: 'function () {\n  var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n  return directModifiedPaths.reduce(function(list, path) {\n    var parts = path.split(\'.\');\n    return list.concat(parts.reduce(function(chains, part, i) {\n      return chains.concat(parts.slice(0, i).concat(part).join(\'.\'));\n    }, []).filter(function(chain) {\n      return (list.indexOf(chain) === -1);\n    }));\n  }, []);\n}',
  get: 'function (path, type) {\n  var adhoc;\n  if (type) {\n    adhoc = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  var schema = this.$__path(path) || this.schema.virtualpath(path),\n      pieces = path.split(\'.\'),\n      obj = this._doc;\n\n  for (var i = 0, l = pieces.length; i < l; i++) {\n    obj = obj === null || obj === void 0\n        ? undefined\n        : obj[pieces[i]];\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  // Check if this path is populated - don\'t apply getters if it is,\n  // because otherwise its a nested object. See gh-3357\n  if (schema && !this.populated(path)) {\n    obj = schema.applyGetters(obj, this);\n  }\n\n  return obj;\n}',
  updatedAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  '$__path': 'function (path) {\n  var adhocs = this.$__.adhocPaths,\n      adhocType = adhocs && adhocs[path];\n\n  if (adhocType) {\n    return adhocType;\n  }\n  return this.schema.path(path);\n}',
  '$__save': 'function (options, callback) {\n  var _this = this;\n\n  _this.$__handleSave(options, function(error, result) {\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.$__reset();\n    _this.$__storeShard();\n\n    var numAffected = 0;\n    if (result) {\n      if (Array.isArray(result)) {\n        numAffected = result.length;\n      } else if (result.result && result.result.n !== undefined) {\n        numAffected = result.result.n;\n      } else if (result.result && result.result.nModified !== undefined) {\n        numAffected = result.result.nModified;\n      } else {\n        numAffected = result;\n      }\n    }\n\n    // was this an update that required a version bump?\n    if (_this.$__.version && !_this.$__.inserting) {\n      var doIncrement = VERSION_INC === (VERSION_INC & _this.$__.version);\n      _this.$__.version = undefined;\n\n      if (numAffected <= 0) {\n        // the update failed. pass an error back\n        var err = new VersionError(_this);\n        return callback(err);\n      }\n\n      // increment version if was successful\n      if (doIncrement) {\n        var key = _this.schema.options.versionKey;\n        var version = _this.getValue(key) | 0;\n        _this.setValue(key, version + 1);\n      }\n    }\n\n    if (_this.schema.options &&\n        _this.schema.options.saveErrorIfNotFound &&\n        numAffected <= 0) {\n      error = new DocumentNotFoundError(result.$where);\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.emit(\'save\', _this, numAffected);\n    _this.constructor.emit(\'save\', _this, numAffected);\n    callback(null, _this, numAffected);\n  });\n}',
  '$__delta': 'function () {\n  var dirty = this.$__dirty();\n  if (!dirty.length && VERSION_ALL !== this.$__.version) return;\n\n  var where = {},\n      delta = {},\n      len = dirty.length,\n      divergent = [],\n      d = 0;\n\n  where._id = this._doc._id;\n  if (where._id.toObject) {\n    where._id = where._id.toObject({ transform: false, depopulate: true });\n  }\n\n  for (; d < len; ++d) {\n    var data = dirty[d];\n    var value = data.value;\n\n    var match = checkDivergentArray(this, data.path, value);\n    if (match) {\n      divergent.push(match);\n      continue;\n    }\n\n    var pop = this.populated(data.path, true);\n    if (!pop && this.$__.selected) {\n      // If any array was selected using an $elemMatch projection, we alter the path and where clause\n      // NOTE: MongoDB only supports projected $elemMatch on top level array.\n      var pathSplit = data.path.split(\'.\');\n      var top = pathSplit[0];\n      if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {\n        // If the selected array entry was modified\n        if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === \'undefined\') {\n          where[top] = this.$__.selected[top];\n          pathSplit[1] = \'$\';\n          data.path = pathSplit.join(\'.\');\n        }\n        // if the selected array was modified in any other way throw an error\n        else {\n          divergent.push(data.path);\n          continue;\n        }\n      }\n    }\n\n    if (divergent.length) continue;\n\n    if (undefined === value) {\n      operand(this, where, delta, data, 1, \'$unset\');\n    } else if (value === null) {\n      operand(this, where, delta, data, null);\n    } else if (value._path && value._atomics) {\n      // arrays and other custom types (support plugins etc)\n      handleAtomics(this, where, delta, data, value);\n    } else if (value._path && Buffer.isBuffer(value)) {\n      // MongooseBuffer\n      value = value.toObject();\n      operand(this, where, delta, data, value);\n    } else {\n      value = utils.clone(value, {depopulate: 1, _isNested: true});\n      operand(this, where, delta, data, value);\n    }\n  }\n\n  if (divergent.length) {\n    return new DivergentArrayError(divergent);\n  }\n\n  if (this.$__.version) {\n    this.$__version(where, delta);\n  }\n\n  return [where, delta];\n}',
  '$__storeShard': 'function () {\n  // backwards compat\n  var key = this.schema.options.shardKey || this.schema.options.shardkey;\n  if (!(key && utils.getFunctionName(key.constructor) === \'Object\')) {\n    return;\n  }\n\n  var orig = this.$__.shardval = {},\n      paths = Object.keys(key),\n      len = paths.length,\n      val;\n\n  for (var i = 0; i < len; ++i) {\n    val = this.getValue(paths[i]);\n    if (isMongooseObject(val)) {\n      orig[paths[i]] = val.toObject({depopulate: true, _isNested: true});\n    } else if (val !== null && val !== undefined && val.valueOf &&\n          // Explicitly don\'t take value of dates\n        (!val.constructor || utils.getFunctionName(val.constructor) !== \'Date\')) {\n      orig[paths[i]] = val.valueOf();\n    } else {\n      orig[paths[i]] = val;\n    }\n  }\n}',
  listeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  depopulate: 'function (path) {\n  var populatedIds = this.populated(path);\n  if (!populatedIds) {\n    return;\n  }\n  delete this.$__.populated[path];\n  this.set(path, populatedIds);\n  return this;\n}',
  equals: 'function (doc) {\n  if (!doc) {\n    return false;\n  }\n\n  var tid = this.get(\'_id\');\n  var docid = doc.get ? doc.get(\'_id\') : doc;\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals\n      ? tid.equals(docid)\n      : tid === docid;\n}',
  _posts: '[object Object]',
  '$__getAllSubdocs': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  function docReducer(seed, path) {\n    var val = this[path];\n\n    if (val instanceof Embedded) {\n      seed.push(val);\n    }\n    if (val && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(docReducer.bind(val._doc), seed);\n      seed.push(val);\n    }\n    if (val && val.isMongooseDocumentArray) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n        seed = Object.keys(doc._doc).reduce(docReducer.bind(doc._doc), seed);\n      });\n    } else if (val instanceof Document && val.$__isNested) {\n      if (val) {\n        seed = Object.keys(val).reduce(docReducer.bind(val), seed);\n      }\n    }\n    return seed;\n  }\n\n  var subDocs = Object.keys(this._doc).reduce(docReducer.bind(this), []);\n\n  return subDocs;\n}',
  removeListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  '$__original_save': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  '$__getArrayPathsToValidate': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  // validate all document arrays.\n  return this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return this.getValue(i);\n  }.bind(this))\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  }).reduce(function(seed, array) {\n    return seed.concat(array);\n  }, [])\n  .filter(function(doc) {\n    return doc;\n  });\n}',
  schema: '[object Object]',
  removeAllListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  save: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  isDirectSelected: 'function isDirectSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  removePost: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , posts = proto._posts || (proto._posts || {});\n    if (!posts[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all post callbacks for hook `name`\n      posts[name].length = 0;\n    } else {\n      posts[name] = posts[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  _lazySetupHooks: 'function (proto, methodName, errorCb) {\n    if (\'undefined\' === typeof proto[methodName].numAsyncPres) {\n      this.$hook(methodName, proto[methodName], errorCb);\n    }\n  }',
  toBSON: 'function () {\n  return this.toObject({\n    transform: false,\n    virtuals: false,\n    _skipDepopulateTopLevel: true,\n    depopulate: true,\n    flattenDecimals: false\n  });\n}',
  markModified: 'function (path) {\n  this.$__.activePaths.modify(path);\n}',
  on: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  increment: 'function increment() {\n  this.$__.version = VERSION_ALL;\n  return this;\n}',
  validate: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populated: 'function (path, val, options) {\n  // val and options are internal\n\n  if (val === null || val === void 0) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    var v = this.$__.populated[path];\n    if (v) {\n      return v.value;\n    }\n    return undefined;\n  }\n\n  // internal\n\n  if (val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    return this.$__.populated[path];\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = {value: val, options: options};\n  return val;\n}',
  update: 'function update() {\n  var args = utils.args(arguments);\n  args.unshift({_id: this._id});\n  return this.constructor.update.apply(this.constructor, args);\n}',
  id: '5902b753c5756d72945d90b3',
  '$__setSchema': 'function (schema) {\n  compile(schema.tree, this, undefined, schema.options);\n  this.schema = schema;\n}',
  isInit: 'function (path) {\n  return (path in this.$__.activePaths.states.init);\n}',
  '$__validate': 'function (callback) {\n  var _this = this;\n  var _complete = function() {\n    var err = _this.$__.validationError;\n    _this.$__.validationError = undefined;\n    _this.emit(\'validate\', _this);\n    _this.constructor.emit(\'validate\', _this);\n    if (err) {\n      for (var key in err.errors) {\n        // Make sure cast errors persist\n        if (!_this.__parent && err.errors[key] instanceof MongooseError.CastError) {\n          _this.invalidate(key, err.errors[key]);\n        }\n      }\n\n      return err;\n    }\n  };\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (paths.length === 0) {\n    process.nextTick(function() {\n      var error = _complete();\n      if (error) {\n        return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n          callback(error);\n        });\n      }\n      callback();\n    });\n  }\n\n  var validating = {},\n      total = 0;\n\n  var complete = function() {\n    var error = _complete();\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n    callback();\n  };\n\n  var validatePath = function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n    total++;\n\n    process.nextTick(function() {\n      var p = _this.schema.path(path);\n      if (!p) {\n        return --total || complete();\n      }\n\n      // If user marked as invalid or there was a cast error, don\'t validate\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      var val = _this.getValue(path);\n      p.doValidate(val, function(err) {\n        if (err) {\n          _this.invalidate(path, err, undefined, true);\n        }\n        --total || complete();\n      }, _this);\n    });\n  };\n\n  paths.forEach(validatePath);\n}',
  username: '222',
  db: '[object Object]',
  '$__original_validate': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  discriminators: 'undefined',
  toObject: 'function (options) {\n  return this.$toObject(options);\n}',
  '$markValid': 'function (path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n}',
  '$isValid': 'function (path) {\n  return !this.$__.validationError || !this.$__.validationError.errors[path];\n}',
  '$__dirty': 'function () {\n  var _this = this;\n\n  var all = this.$__.activePaths.map(\'modify\', function(path) {\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  });\n\n  // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n  all = all.concat(this.$__.activePaths.map(\'default\', function(path) {\n    if (path === \'_id\' || !_this.getValue(path)) {\n      return;\n    }\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n\n  // Sort dirty paths in a flat hierarchy.\n  all.sort(function(a, b) {\n    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));\n  });\n\n  // Ignore "foo.a" if "foo" is dirty already.\n  var minimal = [],\n      lastPath,\n      top;\n\n  all.forEach(function(item) {\n    if (!item) {\n      return;\n    }\n    if (item.path.indexOf(lastPath) !== 0) {\n      lastPath = item.path + \'.\';\n      minimal.push(item);\n      top = item;\n    } else {\n      // special case for top level MongooseArrays\n      if (top.value && top.value._atomics && top.value.hasAtomics()) {\n        // the `top` array itself and a sub path of `top` are being modified.\n        // the only way to honor all of both modifications is through a $set\n        // of entire array.\n        top.value._atomics = {};\n        top.value._atomics.$set = top.value;\n      }\n    }\n  });\n\n  top = lastPath = null;\n  return minimal;\n}',
  model: 'function model(name) {\n  return this.db.model(name);\n}',
  '$isDefault': 'function (path) {\n  return (path in this.$__.activePaths.states.default);\n}',
  '$__original_remove': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  remove: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populate: 'function populate() {\n  if (arguments.length === 0) {\n    return this;\n  }\n\n  var pop = this.$__.populate || (this.$__.populate = {});\n  var args = utils.args(arguments);\n  var fn;\n\n  if (typeof args[args.length - 1] === \'function\') {\n    fn = args.pop();\n  }\n\n  // allow `doc.populate(callback)`\n  if (args.length) {\n    // use hash to remove duplicate paths\n    var res = utils.populate.apply(null, args);\n    for (var i = 0; i < res.length; ++i) {\n      pop[res[i].path] = res[i];\n    }\n  }\n\n  if (fn) {\n    var paths = utils.object.vals(pop);\n    this.$__.populate = undefined;\n    paths.__noPromise = true;\n    this.constructor.populate(this, paths, fn);\n  }\n\n  return this;\n}',
  '$__shouldModify': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  if (this.isNew) {\n    return true;\n  }\n\n  if (undefined === val && !this.isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (undefined === val && path in this.$__.activePaths.states.default) {\n    // we\'re just unsetting the default value which was never saved\n    return false;\n  }\n\n  // gh-3992: if setting a populated field to a doc, don\'t mark modified\n  // if they have the same _id\n  if (this.populated(path) &&\n      val instanceof Document &&\n      deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal || this.get(path))) {\n    return true;\n  }\n\n  if (!constructing &&\n      val !== null &&\n      val !== undefined &&\n      path in this.$__.activePaths.states.default &&\n      deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n  return false;\n}',
  '$__': '[object Object]',
  '$__fullPath': 'function (path) {\n  // overridden in SubDocuments\n  return path || \'\';\n}',
  _pres: '[object Object]',
  inspect: 'function (options) {\n  var isPOJO = options &&\n    utils.getFunctionName(options.constructor) === \'Object\';\n  var opts;\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n    opts.retainKeyOrder = true;\n  }\n  return this.toObject(opts);\n}',
  '$__reset': 'function reset() {\n  var _this = this;\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return _this.getValue(i);\n  })\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  })\n  .forEach(function(array) {\n    var i = array.length;\n    while (i--) {\n      var doc = array[i];\n      if (!doc) {\n        continue;\n      }\n      doc.$__reset();\n    }\n  });\n\n  // clear atomics\n  this.$__dirty().forEach(function(dirt) {\n    var type = dirt.value;\n    if (type && type._atomics) {\n      type._atomics = {};\n    }\n  });\n\n  // Clear \'dirty\' cache\n  this.$__.activePaths.clear(\'modify\');\n  this.$__.activePaths.clear(\'default\');\n  this.$__.validationError = undefined;\n  this.errors = undefined;\n  _this = this;\n  this.schema.requiredPaths().forEach(function(path) {\n    _this.$__.activePaths.require(path);\n  });\n\n  return this;\n}',
  init: 'function (doc, opts, fn) {\n  // do not prefix this method with $__ since its\n  // used by public hooks\n\n  if (typeof opts === \'function\') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.isNew = false;\n\n  // handle docs with populated paths\n  // If doc._id is not null or undefined\n  if (doc._id !== null && doc._id !== undefined &&\n    opts && opts.populated && opts.populated.length) {\n    var id = String(doc._id);\n    for (var i = 0; i < opts.populated.length; ++i) {\n      var item = opts.populated[i];\n      if (item.isVirtual) {\n        this.populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.populated(item.path, item._docs[id], item);\n      }\n    }\n  }\n\n  init(this, doc, this._doc);\n  this.$__storeShard();\n\n  this.emit(\'init\', this);\n  this.constructor.emit(\'init\', this);\n\n  if (fn) {\n    fn(null);\n  }\n  return this;\n}',
  setMaxListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  initializeTimestamps: 'function () {\n      if (!this.get(createdAt)) {\n        this.set(createdAt, new Date());\n      }\n      if (!this.get(updatedAt)) {\n        this.set(updatedAt, new Date());\n      }\n      return this;\n    }',
  once: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  __v: '0',
  '$toObject': 'function (options, json) {\n  var defaultOptions = {\n    transform: true,\n    json: json,\n    retainKeyOrder: this.schema.options.retainKeyOrder,\n    flattenDecimals: true\n  };\n\n  // _isNested will only be true if this is not the top level document, we\n  // should never depopulate\n  if (options && options.depopulate && options._isNested && this.$__.wasPopulated) {\n    // populated paths that we set to a document\n    return clone(this._id, options);\n  }\n\n  // When internally saving this document we always pass options,\n  // bypassing the custom schema options.\n  if (!(options && utils.getFunctionName(options.constructor) === \'Object\') ||\n      (options && options._useSchemaOptions)) {\n    if (json) {\n      options = this.schema.options.toJSON ?\n        clone(this.schema.options.toJSON) :\n        {};\n      options.json = true;\n      options._useSchemaOptions = true;\n    } else {\n      options = this.schema.options.toObject ?\n        clone(this.schema.options.toObject) :\n        {};\n      options.json = false;\n      options._useSchemaOptions = true;\n    }\n  }\n\n  for (var key in defaultOptions) {\n    if (options[key] === undefined) {\n      options[key] = defaultOptions[key];\n    }\n  }\n\n  (\'minimize\' in options) || (options.minimize = this.schema.options.minimize);\n\n  // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n  var originalTransform = options.transform;\n\n  options._isNested = true;\n\n  var ret = clone(this._doc, options) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, \'paths\', options);\n    // applyGetters for paths will add nested empty objects;\n    // if minimize is set, we need to remove them.\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || options.getters && options.virtuals !== false) {\n    applyGetters(this, ret, \'virtuals\', options);\n  }\n\n  if (options.versionKey === false && this.schema.options.versionKey) {\n    delete ret[this.schema.options.versionKey];\n  }\n\n  var transform = options.transform;\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema\'s transform and\n  // not the parent schema\'s\n  if (transform === true ||\n      (this.schema.options.toObject && transform)) {\n    var opts = options.json ? this.schema.options.toJSON : this.schema.options.toObject;\n\n    if (opts) {\n      transform = (typeof options.transform === \'function\' ? options.transform : opts.transform);\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === \'function\') {\n    var xformed = transform(this, ret, options);\n    if (typeof xformed !== \'undefined\') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n}',
  '$hook': 'function (name, fn, errorCb) {\n    if (arguments.length === 1 && typeof name === \'object\') {\n      for (var k in name) { // `name` is a hash of hookName->hookFn\n        this.$hook(k, name[k]);\n      }\n      return;\n    }\n\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {}\n      , posts = proto._posts = proto._posts || {};\n    pres[name] = pres[name] || [];\n    posts[name] = posts[name] || [];\n\n    proto[name] = function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    };\n    \n    proto[name].numAsyncPres = 0;\n\n    return this;\n  }',
  '$__set': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  var shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts,\n    schema, val, priorVal);\n  var _this = this;\n\n  if (shouldModify) {\n    this.markModified(pathToMark, val);\n\n    // handle directly setting arrays (gh-1126)\n    MongooseArray || (MongooseArray = require(\'./types/array\'));\n    if (val && val.isMongooseArray) {\n      val._registerAtomic(\'$set\', val);\n\n      // Update embedded document parent references (gh-5189)\n      if (val.isMongooseDocumentArray) {\n        val.forEach(function(item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      }\n\n      // Small hack for gh-1638: if we\'re overwriting the entire array, ignore\n      // paths that were modified before the array overwrite\n      this.$__.activePaths.forEach(function(modifiedPath) {\n        if (modifiedPath.indexOf(path + \'.\') === 0) {\n          _this.$__.activePaths.ignore(modifiedPath);\n        }\n      });\n    }\n  }\n\n  var obj = this._doc;\n  var i = 0;\n  var l = parts.length;\n  var cur = \'\';\n\n  for (; i < l; i++) {\n    var next = i + 1;\n    var last = next === l;\n    cur += (cur ? \'.\' + parts[i] : parts[i]);\n\n    if (last) {\n      obj[parts[i]] = val;\n    } else {\n      if (obj[parts[i]] && utils.getFunctionName(obj[parts[i]].constructor) === \'Object\') {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        this.set(cur, {});\n        obj = obj[parts[i]];\n      }\n    }\n  }\n}',
  isNew: 'false',
  unmarkModified: 'function (path) {\n  this.$__.activePaths.init(path);\n}',
  validateSync: 'function (pathsToValidate) {\n  var _this = this;\n\n  if (typeof pathsToValidate === \'string\') {\n    pathsToValidate = pathsToValidate.split(\' \');\n  }\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (pathsToValidate && pathsToValidate.length) {\n    var tmp = [];\n    for (var i = 0; i < paths.length; ++i) {\n      if (pathsToValidate.indexOf(paths[i]) !== -1) {\n        tmp.push(paths[i]);\n      }\n    }\n    paths = tmp;\n  }\n\n  var validating = {};\n\n  paths.forEach(function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n\n    var p = _this.schema.path(path);\n    if (!p) {\n      return;\n    }\n    if (!_this.$isValid(path)) {\n      return;\n    }\n\n    var val = _this.getValue(path);\n    var err = p.doValidateSync(val, _this);\n    if (err) {\n      _this.invalidate(path, err, undefined, true);\n    }\n  });\n\n  var err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n  _this.emit(\'validate\', _this);\n  _this.constructor.emit(\'validate\', _this);\n\n  if (err) {\n    for (var key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n}',
  invalidate: 'function (path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === \'string\') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || \'user defined\',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.errors[path] = err;\n  return this.$__.validationError;\n}',
  execPopulate: 'function () {\n  var Promise = PromiseProvider.get();\n  var _this = this;\n  return new Promise.ES6(function(resolve, reject) {\n    _this.populate(function(error, res) {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(res);\n      }\n    });\n  });\n}',
  isSelected: 'function isSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    i = paths.length;\n    var pathDot = path + \'.\';\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n\n      if (cur.indexOf(pathDot) === 0) {\n        return inclusive || cur !== pathDot;\n      }\n\n      if (pathDot.indexOf(cur + \'.\') === 0) {\n        return inclusive;\n      }\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  toString: 'function () {\n  return inspect(this.inspect());\n}',
  toJSON: 'function (options) {\n  return this.$toObject(options, true);\n}',
  '$__handleReject': 'function handleReject(err) {\n  // emit on the Model if listening\n  if (this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  } else if (this.constructor.listeners && this.constructor.listeners(\'error\').length) {\n    this.constructor.emit(\'error\', err);\n  } else if (this.listeners && this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  }\n}' }
[2017-05-04 16:19:39.948] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:19:39.959] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:19:39.962] [INFO] app - Redis client default is ready {}
[2017-05-04 16:19:40.152] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:19:40.809] [DEBUG] app - 2017-5-4 16:19:40 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:19:40.814] [WARN] console - this is a logger middleware.
[2017-05-04 16:19:40.832] [WARN] console - json ********* { username: '222', id: '5902b753c5756d72945d90b3' }
[2017-05-04 16:19:40.842] [WARN] console - { '$pre': 'function (name, isAsync, fn, errorCb) {\n    if (\'boolean\' !== typeof arguments[1]) {\n      errorCb = fn;\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {};\n\n    this._lazySetupHooks(proto, name, errorCb);\n\n    if (fn.isAsync = isAsync) {\n      proto[name].numAsyncPres++;\n    }\n\n    (pres[name] = pres[name] || []).push(fn);\n    return this;\n  }',
  errors: 'undefined',
  addListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  setValue: 'function (path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n}',
  '$__where': 'function _where(where) {\n  where || (where = {});\n\n  var paths,\n      len;\n\n  if (!where._id) {\n    where._id = this._doc._id;\n  }\n\n  if (this.$__.shardval) {\n    paths = Object.keys(this.$__.shardval);\n    len = paths.length;\n\n    for (var i = 0; i < len; ++i) {\n      where[paths[i]] = this.$__.shardval[paths[i]];\n    }\n  }\n\n  if (this._doc._id == null) {\n    return new Error(\'No _id found on document!\');\n  }\n\n  return where;\n}',
  _doc: '[object Object]',
  _id: '5902b753c5756d72945d90b3',
  '$post': 'function (name, isAsync, fn) {\n    if (arguments.length === 2) {\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , posts = proto._posts = proto._posts || {};\n    \n    this._lazySetupHooks(proto, name);\n    (posts[name] = posts[name] || []).push(fn);\n    return this;\n  }',
  getValue: 'function (path) {\n  return utils.getValue(path, this._doc);\n}',
  '$__handleSave': 'function (options, callback) {\n  var _this = this;\n  var i;\n  var keys;\n  var len;\n  if (!options.safe && this.schema.options.safe) {\n    options.safe = this.schema.options.safe;\n  }\n  if (typeof options.safe === \'boolean\') {\n    options.safe = null;\n  }\n\n  if (this.isNew) {\n    // send entire doc\n    var toObjectOptions = {};\n\n    toObjectOptions.retainKeyOrder = this.schema.options.retainKeyOrder;\n    toObjectOptions.depopulate = 1;\n    toObjectOptions._skipDepopulateTopLevel = true;\n    toObjectOptions.transform = false;\n    toObjectOptions.flattenDecimals = false;\n\n    var obj = this.toObject(toObjectOptions);\n\n    if (!utils.object.hasOwnProperty(obj || {}, \'_id\')) {\n      // documents must have an _id else mongoose won\'t know\n      // what to update later if more changes are made. the user\n      // wouldn\'t know what _id was generated by mongodb either\n      // nor would the ObjectId generated my mongodb necessarily\n      // match the schema definition.\n      setTimeout(function() {\n        callback(new Error(\'document must have an _id before saving\'));\n      }, 0);\n      return;\n    }\n\n    this.$__version(true, obj);\n    this.collection.insert(obj, options.safe, function(err, ret) {\n      if (err) {\n        _this.isNew = true;\n        _this.emit(\'isNew\', true);\n        _this.constructor.emit(\'isNew\', true);\n\n        callback(err);\n        return;\n      }\n\n      callback(null, ret);\n    });\n    this.$__reset();\n    this.isNew = false;\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n    // Make it possible to retry the insert\n    this.$__.inserting = true;\n  } else {\n    // Make sure we don\'t treat it as a new object on error,\n    // since it already exists\n    this.$__.inserting = false;\n\n    var delta = this.$__delta();\n\n    if (delta) {\n      if (delta instanceof Error) {\n        callback(delta);\n        return;\n      }\n\n      var where = this.$__where(delta[0]);\n      if (where instanceof Error) {\n        callback(where);\n        return;\n      }\n\n      if (this.$where) {\n        keys = Object.keys(this.$where);\n        len = keys.length;\n        for (i = 0; i < len; ++i) {\n          where[keys[i]] = this.$where[keys[i]];\n        }\n      }\n\n      this.collection.update(where, delta[1], options.safe, function(err, ret) {\n        if (err) {\n          callback(err);\n          return;\n        }\n        ret.$where = where;\n        callback(null, ret);\n      });\n    } else {\n      this.$__reset();\n      callback();\n      return;\n    }\n\n    this.emit(\'isNew\', false);\n    this.constructor.emit(\'isNew\', false);\n  }\n}',
  '$__buildDoc': 'function (obj, fields, skipId) {\n  var doc = {};\n  var exclude = null;\n  var keys;\n  var ki;\n  var _this = this;\n\n  // determine if this doc is a result of a query with\n  // excluded fields\n\n  if (fields && utils.getFunctionName(fields.constructor) === \'Object\') {\n    keys = Object.keys(fields);\n    ki = keys.length;\n\n    if (ki === 1 && keys[0] === \'_id\') {\n      exclude = !!fields[keys[ki]];\n    } else {\n      while (ki--) {\n        if (keys[ki] !== \'_id\' &&\n            (!fields[keys[ki]] || typeof fields[keys[ki]] !== \'object\')) {\n          exclude = !fields[keys[ki]];\n          break;\n        }\n      }\n    }\n  }\n\n  var paths = Object.keys(this.schema.paths);\n  var plen = paths.length;\n  var ii = 0;\n\n  var hasIncludedChildren = {};\n  if (exclude === false && fields) {\n    keys = Object.keys(fields);\n    for (var j = 0; j < keys.length; ++j) {\n      var parts = keys[j].split(\'.\');\n      var c = [];\n      for (var k = 0; k < parts.length; ++k) {\n        c.push(parts[k]);\n        hasIncludedChildren[c.join(\'.\')] = 1;\n      }\n    }\n  }\n\n  for (; ii < plen; ++ii) {\n    var p = paths[ii];\n\n    if (p === \'_id\') {\n      if (skipId) {\n        continue;\n      }\n      if (obj && \'_id\' in obj) {\n        continue;\n      }\n    }\n\n    var type = this.schema.paths[p];\n    var path = p.split(\'.\');\n    var len = path.length;\n    var last = len - 1;\n    var curPath = \'\';\n    var doc_ = doc;\n    var i = 0;\n    var included = false;\n\n    for (; i < len; ++i) {\n      var piece = path[i],\n          def;\n\n      curPath += (!curPath.length ? \'\' : \'.\') + piece;\n\n      // support excluding intermediary levels\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i === last) {\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          } else if (included) {\n            // selected field\n            def = type.getDefault(_this, false);\n            if (typeof def !== \'undefined\') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          }\n        } else {\n          def = type.getDefault(_this, false);\n          if (typeof def !== \'undefined\') {\n            doc_[piece] = def;\n            _this.$__.activePaths.default(p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  return doc;\n}',
  '$ignore': 'function (path) {\n  this.$__.activePaths.ignore(path);\n}',
  removePre: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , pres = proto._pres || (proto._pres || {});\n    if (!pres[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all pre callbacks for hook `name`\n      pres[name].length = 0;\n    } else {\n      pres[name] = pres[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  collection: '[object Object]',
  emit: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  createdAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  '$__version': 'function (where, delta) {\n  var key = this.schema.options.versionKey;\n\n  if (where === true) {\n    // this is an insert\n    if (key) this.setValue(key, delta[key] = 0);\n    return;\n  }\n\n  // updates\n\n  // only apply versioning if our versionKey was selected. else\n  // there is no way to select the correct version. we could fail\n  // fast here and force them to include the versionKey but\n  // thats a bit intrusive. can we do this automatically?\n  if (!this.isSelected(key)) {\n    return;\n  }\n\n  // $push $addToSet don\'t need the where clause set\n  if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {\n    where[key] = this.getValue(key);\n  }\n\n  if (VERSION_INC === (VERSION_INC & this.$__.version)) {\n    if (!delta.$set || typeof delta.$set[key] === \'undefined\') {\n      delta.$inc || (delta.$inc = {});\n      delta.$inc[key] = 1;\n    }\n  }\n}',
  isDirectModified: 'function (path) {\n  return (path in this.$__.activePaths.states.modify);\n}',
  '$isMongooseModelPrototype': 'true',
  set: 'function (path, val, type, options) {\n  if (type && utils.getFunctionName(type.constructor) === \'Object\') {\n    options = type;\n    type = undefined;\n  }\n\n  var merge = options && options.merge,\n      adhoc = type && type !== true,\n      constructing = type === true,\n      adhocs;\n\n  var strict = options && \'strict\' in options\n      ? options.strict\n      : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  if (typeof path !== \'string\') {\n    // new Document({ key: val })\n\n    if (path === null || path === void 0) {\n      var _ = path;\n      path = val;\n      val = _;\n    } else {\n      var prefix = val\n          ? val + \'.\'\n          : \'\';\n\n      if (path instanceof Document) {\n        if (path.$__isNested) {\n          path = path.toObject();\n        } else {\n          path = path._doc;\n        }\n      }\n\n      var keys = Object.keys(path);\n      var len = keys.length;\n      var i = 0;\n      var pathtype;\n      var key;\n\n      if (len === 0 && !this.schema.options.minimize) {\n        if (val) {\n          this.set(val, {});\n        }\n        return this;\n      }\n\n      if (this.schema.options.retainKeyOrder) {\n        while (i < len) {\n          _handleIndex.call(this, i++);\n        }\n      } else {\n        while (len--) {\n          _handleIndex.call(this, len);\n        }\n      }\n\n      return this;\n    }\n  }\n\n  function _handleIndex(i) {\n    key = keys[i];\n    var pathName = prefix + key;\n    pathtype = this.schema.pathType(pathName);\n\n    if (path[key] !== null\n        && path[key] !== void 0\n          // need to know if plain object - no Buffer, ObjectId, ref, etc\n        && utils.isObject(path[key])\n        && (!path[key].constructor || utils.getFunctionName(path[key].constructor) === \'Object\')\n        && pathtype !== \'virtual\'\n        && pathtype !== \'real\'\n        && !(this.$__path(pathName) instanceof MixedSchema)\n        && !(this.schema.paths[pathName] &&\n        this.schema.paths[pathName].options &&\n        this.schema.paths[pathName].options.ref)) {\n      this.set(path[key], prefix + key, constructing);\n    } else if (strict) {\n      // Don\'t overwrite defaults with undefined keys (gh-3981)\n      if (constructing && path[key] === void 0 &&\n          this.get(key) !== void 0) {\n        return;\n      }\n\n      if (pathtype === \'real\' || pathtype === \'virtual\') {\n        // Check for setting single embedded schema to document (gh-3535)\n        var p = path[key];\n        if (this.schema.paths[pathName] &&\n            this.schema.paths[pathName].$isSingleNested &&\n            path[key] instanceof Document) {\n          p = p.toObject({ virtuals: false, transform: false });\n        }\n        this.set(prefix + key, p, constructing);\n      } else if (pathtype === \'nested\' && path[key] instanceof Document) {\n        this.set(prefix + key,\n            path[key].toObject({transform: false}), constructing);\n      } else if (strict === \'throw\') {\n        if (pathtype === \'nested\') {\n          throw new ObjectExpectedError(key, path[key]);\n        } else {\n          throw new StrictModeError(key);\n        }\n      }\n    } else if (path[key] !== void 0) {\n      this.set(prefix + key, path[key], constructing);\n    }\n  }\n\n  var pathType = this.schema.pathType(path);\n  if (pathType === \'nested\' && val) {\n    if (utils.isObject(val) &&\n        (!val.constructor || utils.getFunctionName(val.constructor) === \'Object\')) {\n      if (!merge) {\n        this.setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      }\n\n      if (Object.keys(val).length === 0) {\n        this.setValue(path, {});\n        this.markModified(path);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        this.set(val, path, constructing);\n      }\n      return this;\n    }\n    this.invalidate(path, new MongooseError.CastError(\'Object\', val, path));\n    return this;\n  }\n\n  var schema;\n  var parts = path.split(\'.\');\n\n  if (pathType === \'adhocOrUndefined\' && strict) {\n    // check for roots that are Mixed types\n    var mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      var subpath = parts.slice(0, i + 1).join(\'.\');\n      schema = this.schema.path(subpath);\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n\n      // If path is underneath a virtual, bypass everything and just set it.\n      if (i + 1 < parts.length && this.schema.pathType(subpath) === \'virtual\') {\n        mpath.set(path, val, this);\n        return this;\n      }\n    }\n\n    if (!mixed) {\n      if (strict === \'throw\') {\n        throw new StrictModeError(path);\n      }\n      return this;\n    }\n  } else if (pathType === \'virtual\') {\n    schema = this.schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  var pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: "LEFT_SUBFIELD only supports Object"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    for (i = 0; i < parts.length; ++i) {\n      subpath = parts.slice(0, i + 1).join(\'.\');\n      if (this.isDirectModified(subpath) // earlier prefixes that are already\n            // marked as dirty have precedence\n          || this.get(subpath) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n\n  // if this doc is being constructed we should not trigger getters\n  var priorVal = constructing\n      ? undefined\n      : this.getValue(path);\n\n  if (!schema) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n    return this;\n  }\n\n  var shouldSet = true;\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    var didPopulate = false;\n    if (schema.options &&\n        schema.options.ref &&\n        val instanceof Document &&\n        (schema.options.ref === val.constructor.modelName || schema.options.ref === val.constructor.baseModelName)) {\n      if (this.ownerDocument) {\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val._id, {model: val.constructor});\n      } else {\n        this.populated(path, val._id, {model: val.constructor});\n      }\n      didPopulate = true;\n    }\n\n    var popOpts;\n    if (schema.options &&\n        Array.isArray(schema.options.type) &&\n        schema.options.type.length &&\n        schema.options.type[0].ref &&\n        Array.isArray(val) &&\n        val.length > 0 &&\n        val[0] instanceof Document &&\n        val[0].constructor.modelName &&\n        (schema.options.type[0].ref === val[0].constructor.baseModelName || schema.options.type[0].ref === val[0].constructor.modelName)) {\n      if (this.ownerDocument) {\n        popOpts = { model: val[0].constructor };\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val.map(function(v) { return v._id; }), popOpts);\n      } else {\n        popOpts = { model: val[0].constructor };\n        this.populated(path, val.map(function(v) { return v._id; }), popOpts);\n      }\n      didPopulate = true;\n    }\n    val = schema.applySetters(val, this, false, priorVal);\n\n    if (!didPopulate && this.$__.populated) {\n      delete this.$__.populated[path];\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    this.invalidate(path,\n      new MongooseError.CastError(schema.instance, val, path, e));\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n}',
  modifiedPaths: 'function () {\n  var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n  return directModifiedPaths.reduce(function(list, path) {\n    var parts = path.split(\'.\');\n    return list.concat(parts.reduce(function(chains, part, i) {\n      return chains.concat(parts.slice(0, i).concat(part).join(\'.\'));\n    }, []).filter(function(chain) {\n      return (list.indexOf(chain) === -1);\n    }));\n  }, []);\n}',
  get: 'function (path, type) {\n  var adhoc;\n  if (type) {\n    adhoc = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  var schema = this.$__path(path) || this.schema.virtualpath(path),\n      pieces = path.split(\'.\'),\n      obj = this._doc;\n\n  for (var i = 0, l = pieces.length; i < l; i++) {\n    obj = obj === null || obj === void 0\n        ? undefined\n        : obj[pieces[i]];\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  // Check if this path is populated - don\'t apply getters if it is,\n  // because otherwise its a nested object. See gh-3357\n  if (schema && !this.populated(path)) {\n    obj = schema.applyGetters(obj, this);\n  }\n\n  return obj;\n}',
  updatedAt: 'Fri Apr 28 2017 11:30:27 GMT+0800 (CST)',
  '$__path': 'function (path) {\n  var adhocs = this.$__.adhocPaths,\n      adhocType = adhocs && adhocs[path];\n\n  if (adhocType) {\n    return adhocType;\n  }\n  return this.schema.path(path);\n}',
  '$__save': 'function (options, callback) {\n  var _this = this;\n\n  _this.$__handleSave(options, function(error, result) {\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.$__reset();\n    _this.$__storeShard();\n\n    var numAffected = 0;\n    if (result) {\n      if (Array.isArray(result)) {\n        numAffected = result.length;\n      } else if (result.result && result.result.n !== undefined) {\n        numAffected = result.result.n;\n      } else if (result.result && result.result.nModified !== undefined) {\n        numAffected = result.result.nModified;\n      } else {\n        numAffected = result;\n      }\n    }\n\n    // was this an update that required a version bump?\n    if (_this.$__.version && !_this.$__.inserting) {\n      var doIncrement = VERSION_INC === (VERSION_INC & _this.$__.version);\n      _this.$__.version = undefined;\n\n      if (numAffected <= 0) {\n        // the update failed. pass an error back\n        var err = new VersionError(_this);\n        return callback(err);\n      }\n\n      // increment version if was successful\n      if (doIncrement) {\n        var key = _this.schema.options.versionKey;\n        var version = _this.getValue(key) | 0;\n        _this.setValue(key, version + 1);\n      }\n    }\n\n    if (_this.schema.options &&\n        _this.schema.options.saveErrorIfNotFound &&\n        numAffected <= 0) {\n      error = new DocumentNotFoundError(result.$where);\n      return _this.schema.s.hooks.execPost(\'save:error\', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    _this.emit(\'save\', _this, numAffected);\n    _this.constructor.emit(\'save\', _this, numAffected);\n    callback(null, _this, numAffected);\n  });\n}',
  '$__delta': 'function () {\n  var dirty = this.$__dirty();\n  if (!dirty.length && VERSION_ALL !== this.$__.version) return;\n\n  var where = {},\n      delta = {},\n      len = dirty.length,\n      divergent = [],\n      d = 0;\n\n  where._id = this._doc._id;\n  if (where._id.toObject) {\n    where._id = where._id.toObject({ transform: false, depopulate: true });\n  }\n\n  for (; d < len; ++d) {\n    var data = dirty[d];\n    var value = data.value;\n\n    var match = checkDivergentArray(this, data.path, value);\n    if (match) {\n      divergent.push(match);\n      continue;\n    }\n\n    var pop = this.populated(data.path, true);\n    if (!pop && this.$__.selected) {\n      // If any array was selected using an $elemMatch projection, we alter the path and where clause\n      // NOTE: MongoDB only supports projected $elemMatch on top level array.\n      var pathSplit = data.path.split(\'.\');\n      var top = pathSplit[0];\n      if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {\n        // If the selected array entry was modified\n        if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === \'undefined\') {\n          where[top] = this.$__.selected[top];\n          pathSplit[1] = \'$\';\n          data.path = pathSplit.join(\'.\');\n        }\n        // if the selected array was modified in any other way throw an error\n        else {\n          divergent.push(data.path);\n          continue;\n        }\n      }\n    }\n\n    if (divergent.length) continue;\n\n    if (undefined === value) {\n      operand(this, where, delta, data, 1, \'$unset\');\n    } else if (value === null) {\n      operand(this, where, delta, data, null);\n    } else if (value._path && value._atomics) {\n      // arrays and other custom types (support plugins etc)\n      handleAtomics(this, where, delta, data, value);\n    } else if (value._path && Buffer.isBuffer(value)) {\n      // MongooseBuffer\n      value = value.toObject();\n      operand(this, where, delta, data, value);\n    } else {\n      value = utils.clone(value, {depopulate: 1, _isNested: true});\n      operand(this, where, delta, data, value);\n    }\n  }\n\n  if (divergent.length) {\n    return new DivergentArrayError(divergent);\n  }\n\n  if (this.$__.version) {\n    this.$__version(where, delta);\n  }\n\n  return [where, delta];\n}',
  '$__storeShard': 'function () {\n  // backwards compat\n  var key = this.schema.options.shardKey || this.schema.options.shardkey;\n  if (!(key && utils.getFunctionName(key.constructor) === \'Object\')) {\n    return;\n  }\n\n  var orig = this.$__.shardval = {},\n      paths = Object.keys(key),\n      len = paths.length,\n      val;\n\n  for (var i = 0; i < len; ++i) {\n    val = this.getValue(paths[i]);\n    if (isMongooseObject(val)) {\n      orig[paths[i]] = val.toObject({depopulate: true, _isNested: true});\n    } else if (val !== null && val !== undefined && val.valueOf &&\n          // Explicitly don\'t take value of dates\n        (!val.constructor || utils.getFunctionName(val.constructor) !== \'Date\')) {\n      orig[paths[i]] = val.valueOf();\n    } else {\n      orig[paths[i]] = val;\n    }\n  }\n}',
  listeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  depopulate: 'function (path) {\n  var populatedIds = this.populated(path);\n  if (!populatedIds) {\n    return;\n  }\n  delete this.$__.populated[path];\n  this.set(path, populatedIds);\n  return this;\n}',
  equals: 'function (doc) {\n  if (!doc) {\n    return false;\n  }\n\n  var tid = this.get(\'_id\');\n  var docid = doc.get ? doc.get(\'_id\') : doc;\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals\n      ? tid.equals(docid)\n      : tid === docid;\n}',
  _posts: '[object Object]',
  '$__getAllSubdocs': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  function docReducer(seed, path) {\n    var val = this[path];\n\n    if (val instanceof Embedded) {\n      seed.push(val);\n    }\n    if (val && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(docReducer.bind(val._doc), seed);\n      seed.push(val);\n    }\n    if (val && val.isMongooseDocumentArray) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n        seed = Object.keys(doc._doc).reduce(docReducer.bind(doc._doc), seed);\n      });\n    } else if (val instanceof Document && val.$__isNested) {\n      if (val) {\n        seed = Object.keys(val).reduce(docReducer.bind(val), seed);\n      }\n    }\n    return seed;\n  }\n\n  var subDocs = Object.keys(this._doc).reduce(docReducer.bind(this), []);\n\n  return subDocs;\n}',
  removeListener: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  '$__original_save': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  '$__getArrayPathsToValidate': 'function () {\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  // validate all document arrays.\n  return this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return this.getValue(i);\n  }.bind(this))\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  }).reduce(function(seed, array) {\n    return seed.concat(array);\n  }, [])\n  .filter(function(doc) {\n    return doc;\n  });\n}',
  schema: '[object Object]',
  removeAllListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  save: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  isDirectSelected: 'function isDirectSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  removePost: 'function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , posts = proto._posts || (proto._posts || {});\n    if (!posts[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all post callbacks for hook `name`\n      posts[name].length = 0;\n    } else {\n      posts[name] = posts[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  }',
  _lazySetupHooks: 'function (proto, methodName, errorCb) {\n    if (\'undefined\' === typeof proto[methodName].numAsyncPres) {\n      this.$hook(methodName, proto[methodName], errorCb);\n    }\n  }',
  toBSON: 'function () {\n  return this.toObject({\n    transform: false,\n    virtuals: false,\n    _skipDepopulateTopLevel: true,\n    depopulate: true,\n    flattenDecimals: false\n  });\n}',
  markModified: 'function (path) {\n  this.$__.activePaths.modify(path);\n}',
  on: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  increment: 'function increment() {\n  this.$__.version = VERSION_ALL;\n  return this;\n}',
  validate: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populated: 'function (path, val, options) {\n  // val and options are internal\n\n  if (val === null || val === void 0) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    var v = this.$__.populated[path];\n    if (v) {\n      return v.value;\n    }\n    return undefined;\n  }\n\n  // internal\n\n  if (val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    return this.$__.populated[path];\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = {value: val, options: options};\n  return val;\n}',
  update: 'function update() {\n  var args = utils.args(arguments);\n  args.unshift({_id: this._id});\n  return this.constructor.update.apply(this.constructor, args);\n}',
  id: '5902b753c5756d72945d90b3',
  '$__setSchema': 'function (schema) {\n  compile(schema.tree, this, undefined, schema.options);\n  this.schema = schema;\n}',
  isInit: 'function (path) {\n  return (path in this.$__.activePaths.states.init);\n}',
  '$__validate': 'function (callback) {\n  var _this = this;\n  var _complete = function() {\n    var err = _this.$__.validationError;\n    _this.$__.validationError = undefined;\n    _this.emit(\'validate\', _this);\n    _this.constructor.emit(\'validate\', _this);\n    if (err) {\n      for (var key in err.errors) {\n        // Make sure cast errors persist\n        if (!_this.__parent && err.errors[key] instanceof MongooseError.CastError) {\n          _this.invalidate(key, err.errors[key]);\n        }\n      }\n\n      return err;\n    }\n  };\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (paths.length === 0) {\n    process.nextTick(function() {\n      var error = _complete();\n      if (error) {\n        return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n          callback(error);\n        });\n      }\n      callback();\n    });\n  }\n\n  var validating = {},\n      total = 0;\n\n  var complete = function() {\n    var error = _complete();\n    if (error) {\n      return _this.schema.s.hooks.execPost(\'validate:error\', _this, [ _this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n    callback();\n  };\n\n  var validatePath = function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n    total++;\n\n    process.nextTick(function() {\n      var p = _this.schema.path(path);\n      if (!p) {\n        return --total || complete();\n      }\n\n      // If user marked as invalid or there was a cast error, don\'t validate\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      var val = _this.getValue(path);\n      p.doValidate(val, function(err) {\n        if (err) {\n          _this.invalidate(path, err, undefined, true);\n        }\n        --total || complete();\n      }, _this);\n    });\n  };\n\n  paths.forEach(validatePath);\n}',
  username: '222',
  db: '[object Object]',
  '$__original_validate': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  discriminators: 'undefined',
  isModified: 'function (paths) {\n  if (paths) {\n    if (!Array.isArray(paths)) {\n      paths = paths.split(\' \');\n    }\n    var modified = this.modifiedPaths();\n    var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n    var isModifiedChild = paths.some(function(path) {\n      return !!~modified.indexOf(path);\n    });\n    return isModifiedChild || paths.some(function(path) {\n      return directModifiedPaths.some(function(mod) {\n        return mod === path || path.indexOf(mod + \'.\') === 0;\n      });\n    });\n  }\n  return this.$__.activePaths.some(\'modify\');\n}',
  toObject: 'function (options) {\n  return this.$toObject(options);\n}',
  '$markValid': 'function (path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n}',
  '$isValid': 'function (path) {\n  return !this.$__.validationError || !this.$__.validationError.errors[path];\n}',
  '$__dirty': 'function () {\n  var _this = this;\n\n  var all = this.$__.activePaths.map(\'modify\', function(path) {\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  });\n\n  // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n  all = all.concat(this.$__.activePaths.map(\'default\', function(path) {\n    if (path === \'_id\' || !_this.getValue(path)) {\n      return;\n    }\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n\n  // Sort dirty paths in a flat hierarchy.\n  all.sort(function(a, b) {\n    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));\n  });\n\n  // Ignore "foo.a" if "foo" is dirty already.\n  var minimal = [],\n      lastPath,\n      top;\n\n  all.forEach(function(item) {\n    if (!item) {\n      return;\n    }\n    if (item.path.indexOf(lastPath) !== 0) {\n      lastPath = item.path + \'.\';\n      minimal.push(item);\n      top = item;\n    } else {\n      // special case for top level MongooseArrays\n      if (top.value && top.value._atomics && top.value.hasAtomics()) {\n        // the `top` array itself and a sub path of `top` are being modified.\n        // the only way to honor all of both modifications is through a $set\n        // of entire array.\n        top.value._atomics = {};\n        top.value._atomics.$set = top.value;\n      }\n    }\n  });\n\n  top = lastPath = null;\n  return minimal;\n}',
  model: 'function model(name) {\n  return this.db.model(name);\n}',
  '$isDefault': 'function (path) {\n  return (path in this.$__.activePaths.states.default);\n}',
  '$__original_remove': 'function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    }',
  remove: 'function wrappedPointCut() {\n        var Promise = PromiseProvider.get();\n\n        var _this = this;\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== \'function\') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don\'t support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (this.constructor.$wrapCallback) {\n            fn = this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      }',
  populate: 'function populate() {\n  if (arguments.length === 0) {\n    return this;\n  }\n\n  var pop = this.$__.populate || (this.$__.populate = {});\n  var args = utils.args(arguments);\n  var fn;\n\n  if (typeof args[args.length - 1] === \'function\') {\n    fn = args.pop();\n  }\n\n  // allow `doc.populate(callback)`\n  if (args.length) {\n    // use hash to remove duplicate paths\n    var res = utils.populate.apply(null, args);\n    for (var i = 0; i < res.length; ++i) {\n      pop[res[i].path] = res[i];\n    }\n  }\n\n  if (fn) {\n    var paths = utils.object.vals(pop);\n    this.$__.populate = undefined;\n    paths.__noPromise = true;\n    this.constructor.populate(this, paths, fn);\n  }\n\n  return this;\n}',
  '$__shouldModify': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  if (this.isNew) {\n    return true;\n  }\n\n  if (undefined === val && !this.isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (undefined === val && path in this.$__.activePaths.states.default) {\n    // we\'re just unsetting the default value which was never saved\n    return false;\n  }\n\n  // gh-3992: if setting a populated field to a doc, don\'t mark modified\n  // if they have the same _id\n  if (this.populated(path) &&\n      val instanceof Document &&\n      deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal || this.get(path))) {\n    return true;\n  }\n\n  if (!constructing &&\n      val !== null &&\n      val !== undefined &&\n      path in this.$__.activePaths.states.default &&\n      deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n  return false;\n}',
  '$__': '[object Object]',
  '$__fullPath': 'function (path) {\n  // overridden in SubDocuments\n  return path || \'\';\n}',
  _pres: '[object Object]',
  inspect: 'function (options) {\n  var isPOJO = options &&\n    utils.getFunctionName(options.constructor) === \'Object\';\n  var opts;\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n    opts.retainKeyOrder = true;\n  }\n  return this.toObject(opts);\n}',
  '$__reset': 'function reset() {\n  var _this = this;\n  DocumentArray || (DocumentArray = require(\'./types/documentarray\'));\n\n  this.$__.activePaths\n  .map(\'init\', \'modify\', function(i) {\n    return _this.getValue(i);\n  })\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  })\n  .forEach(function(array) {\n    var i = array.length;\n    while (i--) {\n      var doc = array[i];\n      if (!doc) {\n        continue;\n      }\n      doc.$__reset();\n    }\n  });\n\n  // clear atomics\n  this.$__dirty().forEach(function(dirt) {\n    var type = dirt.value;\n    if (type && type._atomics) {\n      type._atomics = {};\n    }\n  });\n\n  // Clear \'dirty\' cache\n  this.$__.activePaths.clear(\'modify\');\n  this.$__.activePaths.clear(\'default\');\n  this.$__.validationError = undefined;\n  this.errors = undefined;\n  _this = this;\n  this.schema.requiredPaths().forEach(function(path) {\n    _this.$__.activePaths.require(path);\n  });\n\n  return this;\n}',
  init: 'function (doc, opts, fn) {\n  // do not prefix this method with $__ since its\n  // used by public hooks\n\n  if (typeof opts === \'function\') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.isNew = false;\n\n  // handle docs with populated paths\n  // If doc._id is not null or undefined\n  if (doc._id !== null && doc._id !== undefined &&\n    opts && opts.populated && opts.populated.length) {\n    var id = String(doc._id);\n    for (var i = 0; i < opts.populated.length; ++i) {\n      var item = opts.populated[i];\n      if (item.isVirtual) {\n        this.populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.populated(item.path, item._docs[id], item);\n      }\n    }\n  }\n\n  init(this, doc, this._doc);\n  this.$__storeShard();\n\n  this.emit(\'init\', this);\n  this.constructor.emit(\'init\', this);\n\n  if (fn) {\n    fn(null);\n  }\n  return this;\n}',
  setMaxListeners: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  initializeTimestamps: 'function () {\n      if (!this.get(createdAt)) {\n        this.set(createdAt, new Date());\n      }\n      if (!this.get(updatedAt)) {\n        this.set(updatedAt, new Date());\n      }\n      return this;\n    }',
  once: 'function () {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      }',
  __v: '0',
  '$toObject': 'function (options, json) {\n  var defaultOptions = {\n    transform: true,\n    json: json,\n    retainKeyOrder: this.schema.options.retainKeyOrder,\n    flattenDecimals: true\n  };\n\n  // _isNested will only be true if this is not the top level document, we\n  // should never depopulate\n  if (options && options.depopulate && options._isNested && this.$__.wasPopulated) {\n    // populated paths that we set to a document\n    return clone(this._id, options);\n  }\n\n  // When internally saving this document we always pass options,\n  // bypassing the custom schema options.\n  if (!(options && utils.getFunctionName(options.constructor) === \'Object\') ||\n      (options && options._useSchemaOptions)) {\n    if (json) {\n      options = this.schema.options.toJSON ?\n        clone(this.schema.options.toJSON) :\n        {};\n      options.json = true;\n      options._useSchemaOptions = true;\n    } else {\n      options = this.schema.options.toObject ?\n        clone(this.schema.options.toObject) :\n        {};\n      options.json = false;\n      options._useSchemaOptions = true;\n    }\n  }\n\n  for (var key in defaultOptions) {\n    if (options[key] === undefined) {\n      options[key] = defaultOptions[key];\n    }\n  }\n\n  (\'minimize\' in options) || (options.minimize = this.schema.options.minimize);\n\n  // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n  var originalTransform = options.transform;\n\n  options._isNested = true;\n\n  var ret = clone(this._doc, options) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, \'paths\', options);\n    // applyGetters for paths will add nested empty objects;\n    // if minimize is set, we need to remove them.\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || options.getters && options.virtuals !== false) {\n    applyGetters(this, ret, \'virtuals\', options);\n  }\n\n  if (options.versionKey === false && this.schema.options.versionKey) {\n    delete ret[this.schema.options.versionKey];\n  }\n\n  var transform = options.transform;\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema\'s transform and\n  // not the parent schema\'s\n  if (transform === true ||\n      (this.schema.options.toObject && transform)) {\n    var opts = options.json ? this.schema.options.toJSON : this.schema.options.toObject;\n\n    if (opts) {\n      transform = (typeof options.transform === \'function\' ? options.transform : opts.transform);\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === \'function\') {\n    var xformed = transform(this, ret, options);\n    if (typeof xformed !== \'undefined\') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n}',
  '$hook': 'function (name, fn, errorCb) {\n    if (arguments.length === 1 && typeof name === \'object\') {\n      for (var k in name) { // `name` is a hash of hookName->hookFn\n        this.$hook(k, name[k]);\n      }\n      return;\n    }\n\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {}\n      , posts = proto._posts = proto._posts || {};\n    pres[name] = pres[name] || [];\n    posts[name] = posts[name] || [];\n\n    proto[name] = function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if (\'function\' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === \'function\'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");\n              if (currPre.length < 1)\n                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === \'function\'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === \'function\'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== \'function\') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    };\n    \n    proto[name].numAsyncPres = 0;\n\n    return this;\n  }',
  name: '222',
  '$__set': 'function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || require(\'./types/embedded\');\n\n  var shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts,\n    schema, val, priorVal);\n  var _this = this;\n\n  if (shouldModify) {\n    this.markModified(pathToMark, val);\n\n    // handle directly setting arrays (gh-1126)\n    MongooseArray || (MongooseArray = require(\'./types/array\'));\n    if (val && val.isMongooseArray) {\n      val._registerAtomic(\'$set\', val);\n\n      // Update embedded document parent references (gh-5189)\n      if (val.isMongooseDocumentArray) {\n        val.forEach(function(item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      }\n\n      // Small hack for gh-1638: if we\'re overwriting the entire array, ignore\n      // paths that were modified before the array overwrite\n      this.$__.activePaths.forEach(function(modifiedPath) {\n        if (modifiedPath.indexOf(path + \'.\') === 0) {\n          _this.$__.activePaths.ignore(modifiedPath);\n        }\n      });\n    }\n  }\n\n  var obj = this._doc;\n  var i = 0;\n  var l = parts.length;\n  var cur = \'\';\n\n  for (; i < l; i++) {\n    var next = i + 1;\n    var last = next === l;\n    cur += (cur ? \'.\' + parts[i] : parts[i]);\n\n    if (last) {\n      obj[parts[i]] = val;\n    } else {\n      if (obj[parts[i]] && utils.getFunctionName(obj[parts[i]].constructor) === \'Object\') {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        this.set(cur, {});\n        obj = obj[parts[i]];\n      }\n    }\n  }\n}',
  isNew: 'false',
  unmarkModified: 'function (path) {\n  this.$__.activePaths.init(path);\n}',
  validateSync: 'function (pathsToValidate) {\n  var _this = this;\n\n  if (typeof pathsToValidate === \'string\') {\n    pathsToValidate = pathsToValidate.split(\' \');\n  }\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (pathsToValidate && pathsToValidate.length) {\n    var tmp = [];\n    for (var i = 0; i < paths.length; ++i) {\n      if (pathsToValidate.indexOf(paths[i]) !== -1) {\n        tmp.push(paths[i]);\n      }\n    }\n    paths = tmp;\n  }\n\n  var validating = {};\n\n  paths.forEach(function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n\n    var p = _this.schema.path(path);\n    if (!p) {\n      return;\n    }\n    if (!_this.$isValid(path)) {\n      return;\n    }\n\n    var val = _this.getValue(path);\n    var err = p.doValidateSync(val, _this);\n    if (err) {\n      _this.invalidate(path, err, undefined, true);\n    }\n  });\n\n  var err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n  _this.emit(\'validate\', _this);\n  _this.constructor.emit(\'validate\', _this);\n\n  if (err) {\n    for (var key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n}',
  invalidate: 'function (path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === \'string\') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || \'user defined\',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.errors[path] = err;\n  return this.$__.validationError;\n}',
  execPopulate: 'function () {\n  var Promise = PromiseProvider.get();\n  var _this = this;\n  return new Promise.ES6(function(resolve, reject) {\n    _this.populate(function(error, res) {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(res);\n      }\n    });\n  });\n}',
  isSelected: 'function isSelected(path) {\n  if (this.$__.selected) {\n    if (path === \'_id\') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected);\n    var i = paths.length;\n    var inclusive = null;\n    var cur;\n\n    if (i === 1 && paths[0] === \'_id\') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    i = paths.length;\n    var pathDot = path + \'.\';\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === \'_id\') {\n        continue;\n      }\n\n      if (cur.indexOf(pathDot) === 0) {\n        return inclusive || cur !== pathDot;\n      }\n\n      if (pathDot.indexOf(cur + \'.\') === 0) {\n        return inclusive;\n      }\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n}',
  toString: 'function () {\n  return inspect(this.inspect());\n}',
  toJSON: 'function (options) {\n  return this.$toObject(options, true);\n}',
  '$__handleReject': 'function handleReject(err) {\n  // emit on the Model if listening\n  if (this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  } else if (this.constructor.listeners && this.constructor.listeners(\'error\').length) {\n    this.constructor.emit(\'error\', err);\n  } else if (this.listeners && this.listeners(\'error\').length) {\n    this.emit(\'error\', err);\n  }\n}' }
[2017-05-04 16:19:47.510] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:19:47.521] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:19:47.523] [INFO] app - Redis client default is ready {}
[2017-05-04 16:19:47.718] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:19:49.614] [DEBUG] app - 2017-5-4 16:19:49 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:19:49.619] [WARN] console - this is a logger middleware.
[2017-05-04 16:19:49.639] [WARN] console - json ********* { username: '222', id: '5902b753c5756d72945d90b3' }
[2017-05-04 16:19:49.646] [WARN] console - { name: '222' }
[2017-05-04 16:21:01.250] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:21:01.259] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:21:01.264] [INFO] app - Redis client default is ready {}
[2017-05-04 16:21:01.471] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:21:27.648] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:21:27.660] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:21:27.664] [INFO] app - Redis client default is ready {}
[2017-05-04 16:21:27.839] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:21:29.181] [DEBUG] app - 2017-5-4 16:21:29 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:21:29.188] [WARN] console - this is a logger middleware.
[2017-05-04 16:21:29.209] [ERROR] app - ReferenceError: json is not defined
    at UserKv._callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:11:16)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:9:437
    at UserKv.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:9:99)
    at UserKv.loadById (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:60:21)
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:8:45)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:361
    at process._tickDomainCallback (internal/process/next_tick.js:135:7)
[2017-05-04 16:21:29.221] [ERROR] console - ReferenceError: json is not defined
    at UserKv._callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:11:16)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:9:437
    at UserKv.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:9:99)
    at UserKv.loadById (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:60:21)
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:8:45)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:361
    at process._tickDomainCallback (internal/process/next_tick.js:135:7)
[2017-05-04 16:21:38.357] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:21:38.367] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:21:38.370] [INFO] app - Redis client default is ready {}
[2017-05-04 16:21:38.603] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:21:39.718] [DEBUG] app - 2017-5-4 16:21:39 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:21:39.722] [WARN] console - this is a logger middleware.
[2017-05-04 16:22:03.983] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:22:04.000] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:22:04.002] [INFO] app - Redis client default is ready {}
[2017-05-04 16:22:04.202] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:22:05.114] [DEBUG] app - 2017-5-4 16:22:05 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:22:05.121] [WARN] console - this is a logger middleware.
[2017-05-04 16:22:13.946] [DEBUG] app - 2017-5-4 16:22:13 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:22:13.947] [WARN] console - this is a logger middleware.
[2017-05-04 16:22:14.655] [DEBUG] app - 2017-5-4 16:22:14 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:22:14.656] [WARN] console - this is a logger middleware.
[2017-05-04 16:23:28.234] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:23:28.246] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:23:28.270] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:23:28.281] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:23:28.285] [INFO] app - Redis client default is ready {}
[2017-05-04 16:23:28.420] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:23:43.387] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:23:43.397] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:24:06.547] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:24:06.562] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:24:14.301] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:24:14.316] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:24:14.318] [INFO] app - Redis client default is ready {}
[2017-05-04 16:24:14.452] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:24:15.880] [DEBUG] app - 2017-5-4 16:24:15 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:24:15.889] [WARN] console - this is a logger middleware.
[2017-05-04 16:24:46.707] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:24:46.718] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:24:46.722] [INFO] app - Redis client default is ready {}
[2017-05-04 16:24:46.892] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:24:52.923] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:24:52.934] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:24:52.937] [INFO] app - Redis client default is ready {}
[2017-05-04 16:24:53.113] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:24:58.544] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:24:58.563] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:24:58.666] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:24:58.681] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:24:58.569] [INFO] app - Redis client default is ready {}
[2017-05-04 16:24:58.846] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:26:16.831] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:26:16.847] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:26:31.579] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:26:31.591] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:26:37.634] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:26:37.648] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:26:37.651] [INFO] app - Redis client default is ready {}
[2017-05-04 16:26:37.799] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:26:38.536] [DEBUG] app - 2017-5-4 16:26:38 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:26:38.540] [WARN] console - this is a logger middleware.
[2017-05-04 16:27:12.304] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:27:12.317] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:27:12.320] [INFO] app - Redis client default is ready {}
[2017-05-04 16:27:12.524] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:27:13.524] [DEBUG] app - 2017-5-4 16:27:13 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:27:13.529] [WARN] console - this is a logger middleware.
[2017-05-04 16:28:16.552] [DEBUG] app - 2017-5-4 16:28:16 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:28:16.553] [WARN] console - this is a logger middleware.
[2017-05-04 16:31:09.176] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:31:09.196] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:31:09.198] [INFO] app - Redis client default is ready {}
[2017-05-04 16:31:09.398] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:31:12.100] [DEBUG] app - 2017-5-4 16:31:12 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:31:12.103] [WARN] console - this is a logger middleware.
[2017-05-04 16:31:16.827] [DEBUG] app - 2017-5-4 16:31:16 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:31:16.828] [WARN] console - this is a logger middleware.
[2017-05-04 16:31:19.358] [DEBUG] app - 2017-5-4 16:31:19 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:31:19.359] [WARN] console - this is a logger middleware.
[2017-05-04 16:35:28.520] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:35:28.537] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:35:39.658] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:35:39.674] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:35:39.679] [INFO] app - Redis client default is ready {}
[2017-05-04 16:35:40.125] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:35:43.443] [DEBUG] app - 2017-5-4 16:35:43 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:35:43.447] [WARN] console - this is a logger middleware.
[2017-05-04 16:35:49.181] [DEBUG] app - 2017-5-4 16:35:49 ::1 -- GET /api/ HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:35:49.188] [ERROR] console - 
[2017-05-04 16:35:49.188] [ERROR] console -   TypeError: Cannot read property 'render' of undefined
      at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/app/app.js:18:20)
      at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
      at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
      at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
      at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/app/app.js:31:191)
      at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/app/app.js:31:437
      at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/app/app.js:31:99
      at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/app/app.js:17:1
      at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
      at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
      at allowedMethods (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-router/lib/router.js:366:12)
      at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
      at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
      at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-router/lib/router.js:317:32)
      at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
      at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
      at allowedMethods (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-router/lib/router.js:366:12)
      at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
      at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
      at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-router/lib/router.js:317:32)
      at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
      at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
      at createGenerator (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-convert/index.js:24:16)
      at createGenerator.next (<anonymous>)
      at onFulfilled (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/co/index.js:65:19)
      at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/co/index.js:54:5
      at Object.co (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/co/index.js:50:10)
      at Object.toPromise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/co/index.js:118:63)
[2017-05-04 16:35:49.189] [ERROR] console - 
[2017-05-04 16:36:01.080] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:36:01.097] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:36:01.103] [INFO] app - Redis client default is ready {}
[2017-05-04 16:36:01.512] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:36:02.614] [DEBUG] app - 2017-5-4 16:36:02 ::1 -- GET /api/ HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:36:02.619] [ERROR] console - 
[2017-05-04 16:36:02.620] [ERROR] console -   Error: ENOENT: no such file or directory, stat '/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/views/404.html'
[2017-05-04 16:36:02.620] [ERROR] console - 
[2017-05-04 16:36:20.256] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:36:20.268] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:36:20.271] [INFO] app - Redis client default is ready {}
[2017-05-04 16:36:20.594] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:36:23.019] [DEBUG] app - 2017-5-4 16:36:23 ::1 -- GET /api/ HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:36:26.446] [DEBUG] app - 2017-5-4 16:36:26 ::1 -- GET /api/ HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:36:26.994] [DEBUG] app - 2017-5-4 16:36:26 ::1 -- GET /api/ HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:36:27.252] [DEBUG] app - 2017-5-4 16:36:27 ::1 -- GET /api/ HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:36:27.418] [DEBUG] app - 2017-5-4 16:36:27 ::1 -- GET /api/ HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:36:27.567] [DEBUG] app - 2017-5-4 16:36:27 ::1 -- GET /api/ HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:36:52.865] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:36:52.875] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:36:52.878] [INFO] app - Redis client default is ready {}
[2017-05-04 16:36:53.181] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:37:02.553] [DEBUG] app - 2017-5-4 16:37:02 ::1 -- GET /api/ HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:37:23.441] [DEBUG] app - 2017-5-4 16:37:23 ::1 -- GET /api/ HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:38:02.945] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:38:02.962] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:38:02.965] [INFO] app - Redis client default is ready {}
[2017-05-04 16:38:03.624] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:39:15.514] [DEBUG] app - 2017-5-4 16:39:15 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:39:15.518] [WARN] console - this is a logger middleware.
[2017-05-04 16:39:18.612] [DEBUG] app - 2017-5-4 16:39:18 ::1 -- GET /api HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:39:26.783] [DEBUG] app - 2017-5-4 16:39:26 ::1 -- GET /ap HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:39:28.218] [DEBUG] app - 2017-5-4 16:39:28 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:39:28.219] [WARN] console - this is a logger middleware.
[2017-05-04 16:39:32.823] [DEBUG] app - 2017-5-4 16:39:32 ::1 -- GET /ap HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:39:42.827] [DEBUG] app - 2017-5-4 16:39:42 ::1 -- GET / HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:39:45.857] [DEBUG] app - 2017-5-4 16:39:45 ::1 -- GET /22 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:39:49.856] [DEBUG] app - 2017-5-4 16:39:49 ::1 -- GET /xxx HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:40:03.781] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:40:03.792] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:40:03.796] [INFO] app - Redis client default is ready {}
[2017-05-04 16:40:04.236] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:40:04.856] [DEBUG] app - 2017-5-4 16:40:04 ::1 -- GET / HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:40:08.149] [DEBUG] app - 2017-5-4 16:40:08 ::1 -- GET /222 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:40:08.151] [WARN] console - .....
[2017-05-04 16:41:01.918] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:41:01.929] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:41:01.932] [INFO] app - Redis client default is ready {}
[2017-05-04 16:41:02.334] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:41:08.293] [DEBUG] app - 2017-5-4 16:41:08 ::1 -- GET / HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:41:12.740] [DEBUG] app - 2017-5-4 16:41:12 ::1 -- GET /xxx HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:41:12.742] [WARN] console - .....
[2017-05-04 16:41:16.578] [DEBUG] app - 2017-5-4 16:41:16 ::1 -- GET /api/user HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:41:16.579] [WARN] console - .....
[2017-05-04 16:41:17.291] [DEBUG] app - 2017-5-4 16:41:17 ::1 -- GET /api/user HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:41:17.291] [WARN] console - .....
[2017-05-04 16:41:20.690] [DEBUG] app - 2017-5-4 16:41:20 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:41:20.690] [WARN] console - this is a logger middleware.
[2017-05-04 16:41:25.365] [DEBUG] app - 2017-5-4 16:41:25 ::1 -- GET /a HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:41:25.366] [WARN] console - .....
[2017-05-04 16:41:29.968] [DEBUG] app - 2017-5-4 16:41:29 ::1 -- GET /a HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:41:29.968] [WARN] console - .....
[2017-05-04 16:41:34.499] [DEBUG] app - 2017-5-4 16:41:34 ::1 -- GET /api HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:41:34.500] [WARN] console - .....
[2017-05-04 16:41:37.607] [DEBUG] app - 2017-5-4 16:41:37 ::1 -- GET / HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:41:41.711] [DEBUG] app - 2017-5-4 16:41:41 ::1 -- GET /a HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:41:41.712] [WARN] console - .....
[2017-05-04 16:41:44.695] [DEBUG] app - 2017-5-4 16:41:44 ::1 -- GET /fdfds HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:41:44.696] [WARN] console - .....
[2017-05-04 16:41:58.984] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:41:58.996] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:41:58.998] [INFO] app - Redis client default is ready {}
[2017-05-04 16:41:59.383] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:42:01.968] [DEBUG] app - 2017-5-4 16:42:01 ::1 -- GET /222 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:42:01.971] [WARN] console - .....
[2017-05-04 16:42:04.657] [DEBUG] app - 2017-5-4 16:42:04 ::1 -- GET /222 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:42:04.657] [WARN] console - .....
[2017-05-04 16:42:10.345] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:42:10.358] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:42:10.364] [INFO] app - Redis client default is ready {}
[2017-05-04 16:42:10.805] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:42:11.553] [DEBUG] app - 2017-5-4 16:42:11 ::1 -- GET /222 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:42:11.559] [WARN] console - .....
[2017-05-04 16:42:12.225] [DEBUG] app - 2017-5-4 16:42:12 ::1 -- GET /222 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:42:12.225] [WARN] console - .....
[2017-05-04 16:42:12.864] [DEBUG] app - 2017-5-4 16:42:12 ::1 -- GET /222 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:42:12.864] [WARN] console - .....
[2017-05-04 16:42:57.601] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:42:57.615] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:42:57.618] [INFO] app - Redis client default is ready {}
[2017-05-04 16:42:58.064] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:43:24.899] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:43:24.913] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:43:24.920] [INFO] app - Redis client default is ready {}
[2017-05-04 16:43:25.401] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:43:37.136] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:43:37.149] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:43:37.151] [INFO] app - Redis client default is ready {}
[2017-05-04 16:43:37.742] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:43:52.505] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:43:52.520] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:43:55.697] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:43:55.710] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:43:58.976] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:43:58.988] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:44:04.761] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:44:04.772] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:44:04.776] [INFO] app - Redis client default is ready {}
[2017-05-04 16:44:05.126] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:44:12.748] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:44:12.766] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:44:12.770] [INFO] app - Redis client default is ready {}
[2017-05-04 16:44:13.338] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:44:14.880] [DEBUG] app - 2017-5-4 16:44:14 ::1 -- GET /222 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:44:17.820] [DEBUG] app - 2017-5-4 16:44:17 ::1 -- GET /api/user HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:44:18.506] [DEBUG] app - 2017-5-4 16:44:18 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:44:18.507] [WARN] console - this is a logger middleware.
[2017-05-04 16:44:55.740] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:44:55.753] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:44:55.756] [INFO] app - Redis client default is ready {}
[2017-05-04 16:44:56.369] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:45:35.549] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:45:35.561] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:45:35.564] [INFO] app - Redis client default is ready {}
[2017-05-04 16:45:36.068] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:45:50.016] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:45:50.031] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:45:50.035] [INFO] app - Redis client default is ready {}
[2017-05-04 16:45:50.561] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:45:54.579] [DEBUG] app - 2017-5-4 16:45:54 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:45:54.586] [WARN] console - this is a logger middleware.
[2017-05-04 16:45:56.366] [DEBUG] app - 2017-5-4 16:45:56 ::1 -- GET /a HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:45:59.478] [DEBUG] app - 2017-5-4 16:45:59 ::1 -- GET /ap HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:46:07.527] [DEBUG] app - 2017-5-4 16:46:07 ::1 -- GET / HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:46:09.992] [DEBUG] app - 2017-5-4 16:46:09 ::1 -- GET /xx HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:46:21.111] [DEBUG] app - 2017-5-4 16:46:21 ::1 -- GET / HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:46:30.665] [DEBUG] app - 2017-5-4 16:46:30 ::1 -- GET /111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:46:33.950] [DEBUG] app - 2017-5-4 16:46:33 ::1 -- GET /111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:49:35.177] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:49:35.187] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:49:35.190] [INFO] app - Redis client default is ready {}
[2017-05-04 16:49:35.606] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:49:36.773] [DEBUG] app - 2017-5-4 16:49:36 ::1 -- GET /api HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:49:37.828] [DEBUG] app - 2017-5-4 16:49:37 ::1 -- GET /fff HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:50:35.450] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:50:35.462] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:50:35.468] [INFO] app - Redis client default is ready {}
[2017-05-04 16:50:35.913] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:51:46.505] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:51:46.516] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:51:46.519] [INFO] app - Redis client default is ready {}
[2017-05-04 16:51:46.961] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:51:48.948] [DEBUG] app - 2017-5-4 16:51:48 ::1 -- GET /api/ HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:51:51.488] [DEBUG] app - 2017-5-4 16:51:51 ::1 -- GET /api/ HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:51:53.066] [DEBUG] app - 2017-5-4 16:51:53 ::1 -- GET /fff HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:52:28.790] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:52:28.806] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:52:28.810] [INFO] app - Redis client default is ready {}
[2017-05-04 16:52:29.308] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:52:32.331] [DEBUG] app - 2017-5-4 16:52:32 ::1 -- GET /fff HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:52:32.389] [WARN] console - undefined
[2017-05-04 16:52:52.524] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:52:52.537] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:52:52.540] [INFO] app - Redis client default is ready {}
[2017-05-04 16:52:53.007] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:52:55.610] [DEBUG] app - 2017-5-4 16:52:55 ::1 -- GET /fff HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:52:55.615] [WARN] console - [Function]
[2017-05-04 16:56:44.144] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:56:44.162] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:56:44.167] [INFO] app - Redis client default is ready {}
[2017-05-04 16:56:44.523] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:56:47.326] [DEBUG] app - 2017-5-4 16:56:47 ::1 -- GET /fff HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:56:47.333] [WARN] console - [Function]
[2017-05-04 16:57:14.741] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:57:14.753] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:57:14.756] [INFO] app - Redis client default is ready {}
[2017-05-04 16:57:15.238] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:57:16.174] [DEBUG] app - 2017-5-4 16:57:16 ::1 -- GET /fff HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:57:16.179] [WARN] console - [Function]
[2017-05-04 16:57:17.575] [DEBUG] app - 2017-5-4 16:57:17 ::1 -- GET /fff HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:57:17.576] [WARN] console - [Function]
[2017-05-04 16:57:18.121] [DEBUG] app - 2017-5-4 16:57:18 ::1 -- GET /fff HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:57:18.121] [WARN] console - [Function]
[2017-05-04 16:57:22.473] [DEBUG] app - 2017-5-4 16:57:22 ::1 -- GET /fff HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:57:22.473] [WARN] console - [Function]
[2017-05-04 16:57:31.755] [DEBUG] app - 2017-5-4 16:57:31 ::1 -- GET /xxxx HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:57:31.755] [WARN] console - [Function]
[2017-05-04 16:57:38.682] [DEBUG] app - 2017-5-4 16:57:38 ::1 -- GET /xxx HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:57:38.682] [WARN] console - [Function]
[2017-05-04 16:58:42.744] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:58:42.758] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:58:42.761] [INFO] app - Redis client default is ready {}
[2017-05-04 16:58:43.135] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:58:47.533] [DEBUG] app - 2017-5-4 16:58:47 ::1 -- GET /api/ HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:58:47.536] [WARN] console - [Function]
[2017-05-04 16:58:59.580] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 16:58:59.599] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 16:58:59.602] [INFO] app - Redis client default is ready {}
[2017-05-04 16:59:00.139] [INFO] app - application is startup, listening on port 3000
[2017-05-04 16:59:01.867] [DEBUG] app - 2017-5-4 16:59:01 ::1 -- GET /api/ HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 16:59:09.707] [DEBUG] app - 2017-5-4 16:59:09 ::1 -- GET /api/ HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 17:14:28.756] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 17:14:28.780] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 17:14:28.784] [INFO] app - Redis client default is ready {}
[2017-05-04 17:14:29.343] [INFO] app - application is startup, listening on port 3000
[2017-05-04 17:30:21.795] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 17:30:21.807] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 17:30:21.810] [INFO] app - Redis client default is ready {}
[2017-05-04 17:30:22.231] [INFO] app - application is startup, listening on port 3000
[2017-05-04 17:30:24.441] [DEBUG] app - 2017-5-4 17:30:24 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 17:30:24.447] [WARN] console - this is a logger middleware.
[2017-05-04 17:30:28.052] [DEBUG] app - 2017-5-4 17:30:28 ::1 -- GET /api HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 17:30:28.142] [DEBUG] app - 2017-5-4 17:30:28 ::1 -- GET /api HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 17:30:30.554] [DEBUG] app - 2017-5-4 17:30:30 ::1 -- GET /axxx HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 20:02:36.451] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:02:36.468] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:02:36.473] [INFO] app - Redis client default is ready {}
[2017-05-04 20:02:36.895] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:02:41.077] [DEBUG] app - 2017-5-4 20:02:41 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 20:02:41.083] [WARN] console - this is a logger middleware.
[2017-05-04 20:02:54.991] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:02:55.009] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:02:55.013] [INFO] app - Redis client default is ready {}
[2017-05-04 20:02:55.521] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:02:55.773] [DEBUG] app - 2017-5-4 20:02:55 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 20:02:55.778] [WARN] console - this is a logger middleware.
[2017-05-04 20:02:57.637] [DEBUG] app - 2017-5-4 20:02:57 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 20:02:57.637] [WARN] console - this is a logger middleware.
[2017-05-04 20:02:57.801] [DEBUG] app - 2017-5-4 20:02:57 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 20:02:57.802] [WARN] console - this is a logger middleware.
[2017-05-04 20:02:57.944] [DEBUG] app - 2017-5-4 20:02:57 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 20:02:57.945] [WARN] console - this is a logger middleware.
[2017-05-04 20:02:58.081] [DEBUG] app - 2017-5-4 20:02:58 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 20:02:58.082] [WARN] console - this is a logger middleware.
[2017-05-04 20:03:42.199] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:03:42.214] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:04:06.321] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:04:06.337] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:04:38.529] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:04:38.540] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:05:45.720] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:05:45.732] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:06:26.686] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:06:26.702] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:06:26.708] [INFO] app - Redis client default is ready {}
[2017-05-04 20:06:27.125] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:09:37.490] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:09:37.510] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:09:37.513] [INFO] app - Redis client default is ready {}
[2017-05-04 20:09:37.882] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:09:38.863] [DEBUG] app - 2017-5-4 20:09:38 ::1 -- GET /api/ HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 20:09:41.275] [DEBUG] app - 2017-5-4 20:09:41 ::1 -- GET /api/ HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 20:24:27.610] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:24:27.627] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:24:27.632] [INFO] app - Redis client default is ready {}
[2017-05-04 20:24:27.977] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:25:35.937] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:25:35.952] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:25:35.957] [INFO] app - Redis client default is ready {}
[2017-05-04 20:25:36.291] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:27:14.079] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:27:14.094] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:27:14.099] [INFO] app - Redis client default is ready {}
[2017-05-04 20:27:14.424] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:27:25.091] [WARN] console - { BadRequestError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } } }
[2017-05-04 20:27:25.174] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:27:25.183] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:27:25.188] [INFO] app - Redis client default is ready {}
[2017-05-04 20:27:25.417] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:29:56.814] [WARN] console - { BadRequestError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  UnauthorizedError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  PaymentRequiredError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  ForbiddenError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  NotFoundError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  MethodNotAllowedError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  NotAcceptableError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  ConflictError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  GoneError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  LengthRequiredError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  PreconditionFailedError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  UnprocessableEntityError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  UnorderedCollectionError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  UpgradeRequiredError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  PreconditionRequiredError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  TooManyRequestsError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  RequestHeaderFieldsTooLargeError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  InternalServerError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  NotImplementedError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  ServiceUnavailableError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  GatewayTimeoutError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  HttpVersionNotSupportedError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  VariantAlsoNegotiatesError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  InsufficientStorageError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  BandwidthLimitExceededError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  NotExtendedError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  NetworkAuthenticationRequiredError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  BadDigestError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  BadMethodError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  InternalError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  InvalidArgumentError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  InvalidContentError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  InvalidCredentialsError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  InvalidHeaderError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  MissingParameterError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  NotAuthorizedError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  RequestExpiredError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  RequestThrottledError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  WrongAcceptError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } } }
[2017-05-04 20:29:56.915] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:29:56.923] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:29:56.926] [INFO] app - Redis client default is ready {}
[2017-05-04 20:29:57.178] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:30:01.683] [WARN] console - { BadRequestError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  UnauthorizedError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  PaymentRequiredError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  ForbiddenError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  NotFoundError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  MethodNotAllowedError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  NotAcceptableError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  ConflictError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  GoneError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  LengthRequiredError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  PreconditionFailedError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  RequestEntityTooLargeError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  UnprocessableEntityError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  UnorderedCollectionError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  UpgradeRequiredError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  PreconditionRequiredError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  TooManyRequestsError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  RequestHeaderFieldsTooLargeError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  InternalServerError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  NotImplementedError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  ServiceUnavailableError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  GatewayTimeoutError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  HttpVersionNotSupportedError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  VariantAlsoNegotiatesError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  InsufficientStorageError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  BandwidthLimitExceededError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  NotExtendedError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  NetworkAuthenticationRequiredError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  BadDigestError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  BadMethodError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  InternalError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  InvalidArgumentError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  InvalidContentError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  InvalidCredentialsError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  InvalidHeaderError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  MissingParameterError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  NotAuthorizedError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  RequestExpiredError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  RequestThrottledError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  WrongAcceptError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } } }
[2017-05-04 20:30:01.747] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:30:01.761] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:30:01.766] [INFO] app - Redis client default is ready {}
[2017-05-04 20:30:02.015] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:30:10.110] [WARN] console - { BadRequestError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  UnauthorizedError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  PaymentRequiredError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  ForbiddenError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  NotFoundError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  MethodNotAllowedError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  NotAcceptableError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  ConflictError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  GoneError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  LengthRequiredError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  PreconditionFailedError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  RequestEntityTooLargeError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  UnprocessableEntityError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  UnorderedCollectionError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  UpgradeRequiredError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  PreconditionRequiredError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  TooManyRequestsError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  RequestHeaderFieldsTooLargeError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  InternalServerError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  NotImplementedError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  ServiceUnavailableError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  GatewayTimeoutError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  HttpVersionNotSupportedError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  VariantAlsoNegotiatesError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  InsufficientStorageError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  BandwidthLimitExceededError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  NotExtendedError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  NetworkAuthenticationRequiredError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  BadDigestError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  BadMethodError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  InternalError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  InvalidArgumentError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  InvalidContentError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  InvalidCredentialsError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  InvalidHeaderError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  MissingParameterError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  NotAuthorizedError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  RequestExpiredError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  RequestThrottledError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  WrongAcceptError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } } }
[2017-05-04 20:30:10.177] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:30:12.961] [WARN] console - { BadRequestError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  UnauthorizedError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  PaymentRequiredError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  ForbiddenError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  NotFoundError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  MethodNotAllowedError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  NotAcceptableError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  ConflictError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  GoneError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  LengthRequiredError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  PreconditionFailedError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  RequestEntityTooLargeError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  UnprocessableEntityError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  UnorderedCollectionError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  UpgradeRequiredError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  PreconditionRequiredError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  TooManyRequestsError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  RequestHeaderFieldsTooLargeError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  InternalServerError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  NotImplementedError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  ServiceUnavailableError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  GatewayTimeoutError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  HttpVersionNotSupportedError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  VariantAlsoNegotiatesError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  InsufficientStorageError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  BandwidthLimitExceededError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  NotExtendedError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  NetworkAuthenticationRequiredError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  BadDigestError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  BadMethodError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  InternalError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  InvalidArgumentError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  InvalidContentError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  InvalidCredentialsError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  InvalidHeaderError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  MissingParameterError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  NotAuthorizedError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  RequestExpiredError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  RequestThrottledError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } },
  WrongAcceptError: { [Function: anonymous] super_: { [Function: RestError] super_: [Object] } } }
[2017-05-04 20:30:13.021] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:30:13.033] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:30:13.038] [INFO] app - Redis client default is ready {}
[2017-05-04 20:30:13.316] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:30:36.508] [WARN] console - { [Function: anonymous]
  super_: 
   { [Function: RestError]
     super_: 
      { [Function: Error]
        stackTraceLimit: 22,
        prepareStackTrace: [Function: prepareStackTrace] } } }
[2017-05-04 20:30:36.579] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:30:36.598] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:30:36.603] [INFO] app - Redis client default is ready {}
[2017-05-04 20:30:36.850] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:31:34.885] [WARN] console - { [Function: anonymous]
  super_: 
   { [Function: RestError]
     super_: 
      { [Function: Error]
        stackTraceLimit: 22,
        prepareStackTrace: [Function: prepareStackTrace] } } }
[2017-05-04 20:31:34.946] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:31:34.955] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:31:34.958] [INFO] app - Redis client default is ready {}
[2017-05-04 20:31:35.195] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:31:50.581] [WARN] console - { [Function: anonymous]
  super_: 
   { [Function: RestError]
     super_: 
      { [Function: Error]
        stackTraceLimit: 22,
        prepareStackTrace: [Function: prepareStackTrace] } } }
[2017-05-04 20:31:50.663] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:31:50.671] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:31:50.676] [INFO] app - Redis client default is ready {}
[2017-05-04 20:31:50.943] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:33:14.884] [WARN] console - { [Function: BadDigestError]
  super_: 
   { [Function: RestError]
     super_: 
      { [Function: Error]
        stackTraceLimit: 22,
        prepareStackTrace: [Function: prepareStackTrace] } } }
[2017-05-04 20:33:14.956] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:33:14.964] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:33:14.967] [INFO] app - Redis client default is ready {}
[2017-05-04 20:33:15.248] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:35:02.986] [WARN] console - { [BadDigestError: null]
  restCode: null,
  statusCode: null,
  message: null,
  constructorOpt: undefined,
  name: 'BadDigestError' }
[2017-05-04 20:35:03.069] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:35:03.085] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:35:03.089] [INFO] app - Redis client default is ready {}
[2017-05-04 20:35:03.362] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:35:21.755] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:35:21.764] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:35:21.768] [INFO] app - Redis client default is ready {}
[2017-05-04 20:35:22.046] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:37:10.766] [WARN] console - null
[2017-05-04 20:37:10.851] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:37:10.863] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:37:10.866] [INFO] app - Redis client default is ready {}
[2017-05-04 20:37:11.064] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:38:38.991] [WARN] console - I am a teapot
[2017-05-04 20:38:39.057] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:38:39.066] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:38:39.068] [INFO] app - Redis client default is ready {}
[2017-05-04 20:38:39.283] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:38:49.098] [WARN] console - I am a teapot
[2017-05-04 20:38:49.196] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:38:49.208] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:38:49.213] [INFO] app - Redis client default is ready {}
[2017-05-04 20:38:49.433] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:39:12.543] [WARN] console - I am a teapot
[2017-05-04 20:39:12.609] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:39:12.622] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:39:12.625] [INFO] app - Redis client default is ready {}
[2017-05-04 20:39:12.878] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:40:08.597] [WARN] console - true
[2017-05-04 20:40:08.676] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:40:08.685] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:40:08.688] [INFO] app - Redis client default is ready {}
[2017-05-04 20:40:08.930] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:40:24.583] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:40:24.597] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:40:24.600] [INFO] app - Redis client default is ready {}
[2017-05-04 20:40:24.843] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:40:40.273] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:40:40.289] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:40:40.293] [INFO] app - Redis client default is ready {}
[2017-05-04 20:40:40.554] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:41:15.145] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:41:15.161] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:41:15.166] [INFO] app - Redis client default is ready {}
[2017-05-04 20:41:15.382] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:41:39.812] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:41:39.827] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:41:39.831] [INFO] app - Redis client default is ready {}
[2017-05-04 20:41:40.092] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:42:19.438] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:42:19.450] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:42:19.453] [INFO] app - Redis client default is ready {}
[2017-05-04 20:42:19.679] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:42:23.059] [DEBUG] app - 2017-5-4 20:42:23 ::1 -- GET / HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 20:42:28.298] [DEBUG] app - 2017-5-4 20:42:28 ::1 -- GET /api/user HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 20:42:31.697] [DEBUG] app - 2017-5-4 20:42:31 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 20:42:31.697] [WARN] console - this is a logger middleware.
[2017-05-04 20:42:31.706] [ERROR] console - 
[2017-05-04 20:42:31.706] [ERROR] console -   TypeError: Cannot read property 'throw' of undefined
      at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:6:7)
      at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
      at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
      at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
      at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:191)
      at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:437
      at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:99
      at getUser (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:66:21)
      at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
      at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
      at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-router/lib/router.js:326:16
      at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
      at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
      at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/middlewares/logger.js:3:9)
      at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
      at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
      at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
      at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/middlewares/logger.js:7:191)
      at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/middlewares/logger.js:7:437
      at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/middlewares/logger.js:7:99
      at logger (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/middlewares/logger.js:28:17)
      at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
      at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
      at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-router/lib/router.js:326:16
      at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
      at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:36:12
      at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-router/lib/router.js:331:31)
      at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
[2017-05-04 20:42:31.707] [ERROR] console - 
[2017-05-04 20:42:44.002] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:42:44.012] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:42:44.017] [INFO] app - Redis client default is ready {}
[2017-05-04 20:42:44.290] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:42:45.133] [DEBUG] app - 2017-5-4 20:42:45 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 20:42:45.137] [WARN] console - this is a logger middleware.
[2017-05-04 20:42:50.859] [DEBUG] app - 2017-5-4 20:42:50 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 20:42:50.859] [WARN] console - this is a logger middleware.
[2017-05-04 20:43:33.969] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:43:33.987] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:43:33.992] [INFO] app - Redis client default is ready {}
[2017-05-04 20:43:34.524] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:43:35.594] [DEBUG] app - 2017-5-4 20:43:35 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 20:43:35.600] [WARN] console - this is a logger middleware.
[2017-05-04 20:43:41.651] [DEBUG] app - 2017-5-4 20:43:41 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 20:43:41.652] [WARN] console - this is a logger middleware.
[2017-05-04 20:45:40.967] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:45:40.979] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:45:40.982] [INFO] app - Redis client default is ready {}
[2017-05-04 20:45:41.428] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:45:45.525] [DEBUG] app - 2017-5-4 20:45:45 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 20:45:45.534] [WARN] console - this is a logger middleware.
[2017-05-04 20:45:45.537] [ERROR] app - { [ForbiddenError: I am a teapot]
  restCode: null,
  statusCode: 418,
  message: 'I am a teapot',
  constructorOpt: undefined,
  name: 'ForbiddenError',
  expose: true,
  status: 418 }
[2017-05-04 20:46:47.150] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:46:47.162] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:46:47.165] [INFO] app - Redis client default is ready {}
[2017-05-04 20:46:47.600] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:46:53.610] [DEBUG] app - 2017-5-4 20:46:53 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 20:46:53.618] [WARN] console - this is a logger middleware.
[2017-05-04 20:46:53.621] [ERROR] app - { [ForbiddenError: I am a teapot]
  restCode: null,
  statusCode: 418,
  message: 'I am a teapot',
  constructorOpt: undefined,
  name: 'ForbiddenError',
  expose: true,
  status: 418 }
[2017-05-04 20:46:53.624] [WARN] console - { request: 
   { method: 'GET',
     url: '/api/user/111',
     header: 
      { host: 'localhost:3000',
        connection: 'keep-alive',
        'cache-control': 'max-age=0',
        'upgrade-insecure-requests': '1',
        'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36',
        accept: 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        'accept-encoding': 'gzip, deflate, sdch, br',
        'accept-language': 'zh-CN,zh;q=0.8,en;q=0.6' } },
  response: 
   { status: 404,
     message: 'Not Found',
     header: 
      { 'access-control-allow-origin': '*',
        'access-control-allow-credentials': 'true',
        'access-control-allow-methods': 'GET,PUT,POST,PATCH,DELETE',
        'access-control-allow-headers': 'Content-Type,Authorization,Accept,X-API-From,X-APPID,X-Component,X-FXER,x-api-from,x-appid,x-component,x-fxer' } },
  app: { subdomainOffset: 2, proxy: true, env: 'development' },
  originalUrl: '/api/user/111',
  req: '<original node req>',
  res: '<original node res>',
  socket: '<original node socket>' }
[2017-05-04 20:47:26.786] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:47:26.801] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:47:26.804] [INFO] app - Redis client default is ready {}
[2017-05-04 20:47:27.271] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:47:28.615] [DEBUG] app - 2017-5-4 20:47:28 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 20:47:28.622] [WARN] console - this is a logger middleware.
[2017-05-04 20:47:28.625] [ERROR] app - { [ForbiddenError: I am a teapot]
  restCode: null,
  statusCode: 418,
  message: 'I am a teapot',
  constructorOpt: undefined,
  name: 'ForbiddenError',
  expose: true,
  status: 418 }
[2017-05-04 20:47:31.252] [DEBUG] app - 2017-5-4 20:47:31 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 20:47:31.253] [WARN] console - this is a logger middleware.
[2017-05-04 20:47:31.253] [ERROR] app - { [ForbiddenError: I am a teapot]
  restCode: null,
  statusCode: 418,
  message: 'I am a teapot',
  constructorOpt: undefined,
  name: 'ForbiddenError',
  expose: true,
  status: 418 }
[2017-05-04 20:47:54.143] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:47:54.168] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:47:54.171] [INFO] app - Redis client default is ready {}
[2017-05-04 20:47:54.714] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:47:57.859] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:47:57.870] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:47:57.873] [INFO] app - Redis client default is ready {}
[2017-05-04 20:47:58.436] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:47:59.269] [DEBUG] app - 2017-5-4 20:47:59 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 20:47:59.275] [WARN] console - this is a logger middleware.
[2017-05-04 20:47:59.279] [ERROR] app - { [ForbiddenError: I am a teapot]
  restCode: null,
  statusCode: 418,
  message: 'I am a teapot',
  constructorOpt: undefined,
  name: 'ForbiddenError',
  expose: true,
  status: 418 }
[2017-05-04 20:48:07.231] [DEBUG] app - 2017-5-4 20:48:07 ::1 -- GET /api/user/xxx HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 20:48:07.232] [WARN] console - this is a logger middleware.
[2017-05-04 20:48:07.232] [ERROR] app - { [ForbiddenError: I am a teapot]
  restCode: null,
  statusCode: 418,
  message: 'I am a teapot',
  constructorOpt: undefined,
  name: 'ForbiddenError',
  expose: true,
  status: 418 }
[2017-05-04 20:48:08.966] [DEBUG] app - 2017-5-4 20:48:08 ::1 -- GET /api/user/xxx HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 20:48:08.967] [WARN] console - this is a logger middleware.
[2017-05-04 20:48:08.967] [ERROR] app - { [ForbiddenError: I am a teapot]
  restCode: null,
  statusCode: 418,
  message: 'I am a teapot',
  constructorOpt: undefined,
  name: 'ForbiddenError',
  expose: true,
  status: 418 }
[2017-05-04 20:48:11.770] [DEBUG] app - 2017-5-4 20:48:11 ::1 -- GET /api/user/xxx HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 20:48:11.771] [WARN] console - this is a logger middleware.
[2017-05-04 20:48:11.771] [ERROR] app - { [ForbiddenError: I am a teapot]
  restCode: null,
  statusCode: 418,
  message: 'I am a teapot',
  constructorOpt: undefined,
  name: 'ForbiddenError',
  expose: true,
  status: 418 }
[2017-05-04 20:48:34.936] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:48:34.949] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:48:34.952] [INFO] app - Redis client default is ready {}
[2017-05-04 20:48:35.298] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:48:35.853] [DEBUG] app - 2017-5-4 20:48:35 ::1 -- GET /api/user/xxx HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 20:48:35.859] [WARN] console - this is a logger middleware.
[2017-05-04 20:48:35.861] [ERROR] app - { [ForbiddenError: I am a teapot]
  restCode: null,
  statusCode: 418,
  message: 'I am a teapot',
  constructorOpt: undefined,
  name: 'ForbiddenError' }
[2017-05-04 20:49:03.072] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:49:03.083] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:49:03.086] [INFO] app - Redis client default is ready {}
[2017-05-04 20:49:03.390] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:49:04.667] [DEBUG] app - 2017-5-4 20:49:04 ::1 -- GET /api/user/xxx HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 20:49:04.671] [WARN] console - this is a logger middleware.
[2017-05-04 20:49:04.673] [ERROR] app - { [ForbiddenError: I am a teapot]
  restCode: null,
  statusCode: 418,
  message: 'I am a teapot',
  constructorOpt: undefined,
  name: 'ForbiddenError',
  expose: true,
  status: 418 }
[2017-05-04 20:51:06.564] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:51:06.580] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:51:06.583] [INFO] app - Redis client default is ready {}
[2017-05-04 20:51:06.983] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:53:54.155] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:53:54.197] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:53:54.201] [INFO] app - Redis client default is ready {}
[2017-05-04 20:53:54.643] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:54:19.051] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:54:19.062] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:54:19.065] [INFO] app - Redis client default is ready {}
[2017-05-04 20:54:19.498] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:55:58.046] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:55:58.057] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:55:58.060] [INFO] app - Redis client default is ready {}
[2017-05-04 20:55:58.524] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:56:00.595] [DEBUG] app - 2017-5-4 20:56:00 ::1 -- GET /api/user/xxx HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 20:56:00.600] [WARN] console - this is a logger middleware.
[2017-05-04 20:56:00.604] [ERROR] app - { [BadRequestError: Bad Request]
  restCode: null,
  statusCode: 400,
  message: 'Bad Request',
  constructorOpt: undefined,
  name: 'BadRequestError',
  expose: true,
  status: 400 }
[2017-05-04 20:56:24.156] [DEBUG] app - 2017-5-4 20:56:24 ::1 -- GET /api/user/xxx HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 20:56:24.157] [WARN] console - this is a logger middleware.
[2017-05-04 20:56:24.158] [ERROR] app - { [BadRequestError: Bad Request]
  restCode: null,
  statusCode: 400,
  message: 'Bad Request',
  constructorOpt: undefined,
  name: 'BadRequestError',
  expose: true,
  status: 400 }
[2017-05-04 20:56:26.295] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-04 20:56:26.313] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-04 20:56:26.317] [INFO] app - Redis client default is ready {}
[2017-05-04 20:56:26.746] [INFO] app - application is startup, listening on port 3000
[2017-05-04 20:56:28.740] [DEBUG] app - 2017-5-4 20:56:28 ::1 -- GET /api/user/xxx HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 20:56:28.743] [WARN] console - this is a logger middleware.
[2017-05-04 20:56:31.231] [DEBUG] app - 2017-5-4 20:56:31 ::1 -- GET /api/use22 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-04 20:56:31.233] [ERROR] app - { [NotFoundError: Not Found]
  restCode: null,
  statusCode: 404,
  message: 'Not Found',
  constructorOpt: undefined,
  name: 'NotFoundError',
  expose: true,
  status: 404 }
[2017-05-05 10:50:01.422] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 10:50:01.436] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 10:50:01.439] [INFO] app - Redis client default is ready {}
[2017-05-05 10:50:01.797] [INFO] app - application is startup, listening on port 3000
[2017-05-05 10:50:29.080] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 10:50:29.092] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 10:50:29.095] [INFO] app - Redis client default is ready {}
[2017-05-05 10:50:29.543] [INFO] app - application is startup, listening on port 3000
[2017-05-05 10:50:29.543] [WARN] console - ???
[2017-05-05 10:50:37.818] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 10:50:37.840] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 10:50:37.847] [INFO] app - Redis client default is ready {}
[2017-05-05 10:50:38.340] [INFO] app - application is startup, listening on port 3000
[2017-05-05 10:51:28.388] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 10:51:28.403] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 10:51:28.406] [INFO] app - Redis client default is ready {}
[2017-05-05 10:51:28.924] [INFO] app - application is startup, listening on port 3000
[2017-05-05 10:52:54.143] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 10:52:54.156] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 10:52:54.165] [INFO] app - Redis client default is ready {}
[2017-05-05 10:52:54.463] [INFO] app - application is startup, listening on port 3000
[2017-05-05 10:56:04.514] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 10:56:04.527] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 10:56:04.530] [INFO] app - Redis client default is ready {}
[2017-05-05 10:56:04.833] [INFO] app - application is startup, listening on port 3000
[2017-05-05 10:59:40.369] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 10:59:40.381] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 10:59:40.384] [INFO] app - Redis client default is ready {}
[2017-05-05 11:00:09.047] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 11:00:09.057] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 11:00:24.818] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 11:00:24.844] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 11:00:36.124] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 11:00:36.142] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 11:00:47.956] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 11:00:47.969] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 11:00:47.975] [INFO] app - Redis client default is ready {}
[2017-05-05 11:00:48.270] [INFO] app - application is startup, listening on port 3000
[2017-05-05 11:01:00.919] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 11:01:00.938] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 11:01:00.948] [INFO] app - Redis client default is ready {}
[2017-05-05 11:01:01.143] [INFO] app - application is startup, listening on port 3000
[2017-05-05 11:01:17.987] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 11:01:18.002] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 11:01:18.005] [INFO] app - Redis client default is ready {}
[2017-05-05 11:01:18.480] [INFO] app - application is startup, listening on port 3000
[2017-05-05 11:01:47.231] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 11:01:47.242] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 11:01:47.245] [INFO] app - Redis client default is ready {}
[2017-05-05 11:01:47.514] [INFO] app - application is startup, listening on port 3000
[2017-05-05 11:01:56.776] [DEBUG] app - 2017-5-5 11:01:56 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 11:01:56.779] [WARN] console - this is a logger middleware.
[2017-05-05 11:02:20.639] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 11:02:20.659] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 11:03:45.408] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 11:03:45.433] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 11:10:46.393] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 11:10:46.406] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 11:11:05.791] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 11:11:05.808] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 11:12:16.902] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 11:12:16.920] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 11:13:01.411] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 11:13:01.426] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 11:13:12.449] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 11:13:12.461] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 11:13:18.324] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 11:13:18.345] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 11:23:37.922] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 11:23:37.935] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 11:32:53.157] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 11:32:53.181] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 11:37:17.069] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 11:37:17.094] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 11:38:02.886] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 11:38:02.897] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 11:38:11.972] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 11:38:11.987] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 11:40:28.955] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 11:40:28.969] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 11:41:04.277] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 11:41:04.301] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 11:58:07.543] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 11:58:07.558] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 11:58:47.023] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 11:58:47.034] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 12:00:21.560] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 12:00:21.573] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 12:00:26.901] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 12:00:26.914] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 12:00:41.621] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 12:00:41.634] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 12:00:49.620] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 12:00:49.633] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 12:00:49.635] [INFO] app - Redis client default is ready {}
[2017-05-05 12:01:09.994] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 12:01:10.006] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 12:01:10.009] [INFO] app - Redis client default is ready {}
[2017-05-05 12:01:10.419] [WARN] console - { [Function: Ready] readify: [Function] }
[2017-05-05 12:02:21.099] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 12:02:21.120] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 12:02:43.251] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 12:02:43.271] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 12:04:16.493] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 12:04:16.505] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 12:04:16.512] [INFO] app - Redis client default is ready {}
[2017-05-05 12:04:16.889] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 12:04:44.161] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 12:04:44.172] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 12:04:44.174] [INFO] app - Redis client default is ready {}
[2017-05-05 12:04:44.669] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:17:23.612] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:17:23.626] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:17:23.629] [INFO] app - Redis client default is ready {}
[2017-05-05 13:17:24.093] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:19:36.688] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:19:36.702] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:19:36.705] [INFO] app - Redis client default is ready {}
[2017-05-05 13:19:37.210] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:20:01.022] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:20:01.035] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:20:01.039] [INFO] app - Redis client default is ready {}
[2017-05-05 13:20:01.565] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:20:14.812] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:20:14.823] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:20:14.829] [INFO] app - Redis client default is ready {}
[2017-05-05 13:20:15.336] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:20:15.338] [WARN] console - jfiodsjfodisjfs
[2017-05-05 13:20:15.340] [WARN] console - jfiodsjfodisjfs
[2017-05-05 13:20:15.340] [WARN] console - jfiodsjfodisjfs
[2017-05-05 13:20:32.696] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:20:32.715] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:20:32.719] [INFO] app - Redis client default is ready {}
[2017-05-05 13:20:33.212] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:20:33.215] [WARN] console - 0
[2017-05-05 13:20:33.217] [WARN] console - 1
[2017-05-05 13:20:33.217] [WARN] console - 1
[2017-05-05 13:20:59.930] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:20:59.943] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:20:59.946] [INFO] app - Redis client default is ready {}
[2017-05-05 13:21:00.467] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:21:00.469] [WARN] console - 0
[2017-05-05 13:21:00.469] [WARN] console - 1
[2017-05-05 13:21:00.470] [WARN] console - 1
[2017-05-05 13:21:22.000] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:21:22.011] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:21:22.014] [INFO] app - Redis client default is ready {}
[2017-05-05 13:21:22.569] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:21:22.570] [WARN] console - [ { [Function: callback] readyStatus: 2 },
  { [Function: callback] readyStatus: 1 } ]
[2017-05-05 13:21:22.573] [WARN] console - [ { [Function: callback] readyStatus: 2 },
  { [Function: callback] readyStatus: 2 } ]
[2017-05-05 13:21:22.574] [WARN] console - [ { [Function: callback] readyStatus: 2 },
  { [Function: callback] readyStatus: 2 } ]
[2017-05-05 13:22:30.661] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:22:30.675] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:22:30.678] [INFO] app - Redis client default is ready {}
[2017-05-05 13:22:31.209] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:22:49.900] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:22:49.911] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:22:49.914] [INFO] app - Redis client default is ready {}
[2017-05-05 13:22:50.490] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:23:15.842] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:23:15.858] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:23:15.861] [INFO] app - Redis client default is ready {}
[2017-05-05 13:23:16.388] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:23:34.960] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:23:34.977] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:23:34.980] [INFO] app - Redis client default is ready {}
[2017-05-05 13:23:35.555] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:24:14.726] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:24:14.741] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:24:14.746] [INFO] app - Redis client default is ready {}
[2017-05-05 13:24:15.192] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:24:19.194] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:24:19.208] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:24:19.211] [INFO] app - Redis client default is ready {}
[2017-05-05 13:24:19.795] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:24:36.598] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:24:36.609] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:24:36.612] [INFO] app - Redis client default is ready {}
[2017-05-05 13:24:37.094] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:24:37.095] [WARN] console - [ { [Function: callback] readyStatus: 2 },
  { [Function: callback] readyStatus: 1 } ]
[2017-05-05 13:24:37.096] [WARN] console - [ { [Function: callback] readyStatus: 2 },
  { [Function: callback] readyStatus: 2 } ]
[2017-05-05 13:24:37.096] [WARN] console - [ { [Function: callback] readyStatus: 2 },
  { [Function: callback] readyStatus: 2 } ]
[2017-05-05 13:25:08.988] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:25:09.009] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:25:09.013] [INFO] app - Redis client default is ready {}
[2017-05-05 13:25:09.582] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:25:09.583] [WARN] console - 1
[2017-05-05 13:25:09.584] [WARN] console - 1
[2017-05-05 13:25:09.584] [WARN] console - 1
[2017-05-05 13:25:43.932] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:25:43.942] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:25:43.945] [INFO] app - Redis client default is ready {}
[2017-05-05 13:25:44.432] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:25:44.433] [WARN] console - 2
[2017-05-05 13:25:44.434] [WARN] console - 1
[2017-05-05 13:25:44.434] [WARN] console - 2
[2017-05-05 13:25:44.434] [WARN] console - 1
[2017-05-05 13:25:44.435] [WARN] console - 1
[2017-05-05 13:26:19.854] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:26:19.864] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:26:19.868] [INFO] app - Redis client default is ready {}
[2017-05-05 13:26:20.315] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:26:20.317] [WARN] console - 2
[2017-05-05 13:26:20.318] [WARN] console - 1
[2017-05-05 13:26:20.318] [WARN] console - 2
[2017-05-05 13:26:20.318] [WARN] console - 2
[2017-05-05 13:26:20.319] [WARN] console - 0
[2017-05-05 13:26:41.860] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:26:41.870] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:26:41.873] [INFO] app - Redis client default is ready {}
[2017-05-05 13:26:42.374] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:26:42.375] [WARN] console - false
[2017-05-05 13:26:42.376] [WARN] console - 1
[2017-05-05 13:26:42.376] [WARN] console - true
[2017-05-05 13:26:42.376] [WARN] console - 2
[2017-05-05 13:26:42.376] [WARN] console - 0
[2017-05-05 13:26:58.512] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:26:58.527] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:26:58.531] [INFO] app - Redis client default is ready {}
[2017-05-05 13:26:58.987] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:26:58.988] [WARN] console - 1
[2017-05-05 13:26:58.988] [WARN] console - 2
[2017-05-05 13:26:58.989] [WARN] console - 0
[2017-05-05 13:27:46.455] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:27:46.471] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:27:46.474] [INFO] app - Redis client default is ready {}
[2017-05-05 13:27:47.042] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:27:47.043] [WARN] console - 1
[2017-05-05 13:27:47.043] [WARN] console - 2
[2017-05-05 13:27:47.044] [WARN] console - 0
[2017-05-05 13:27:47.044] [WARN] console - all ok ....
[2017-05-05 13:28:05.224] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:28:05.237] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:28:05.241] [INFO] app - Redis client default is ready {}
[2017-05-05 13:28:05.791] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:28:05.793] [WARN] console - all ok ....
[2017-05-05 13:28:12.977] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:28:12.990] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:28:12.993] [INFO] app - Redis client default is ready {}
[2017-05-05 13:28:13.490] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:28:19.872] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:28:19.885] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:28:19.888] [INFO] app - Redis client default is ready {}
[2017-05-05 13:28:20.436] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:28:20.438] [WARN] console - all ok ....
[2017-05-05 13:30:00.762] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:30:00.777] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:30:00.781] [INFO] app - Redis client default is ready {}
[2017-05-05 13:30:01.292] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:30:01.294] [WARN] console - all ok ....
[2017-05-05 13:30:24.434] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:30:24.446] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:30:24.449] [INFO] app - Redis client default is ready {}
[2017-05-05 13:30:24.971] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:30:24.972] [WARN] console - 1
[2017-05-05 13:30:24.972] [WARN] console - 2
[2017-05-05 13:30:24.972] [WARN] console - 0
[2017-05-05 13:30:24.972] [WARN] console - all ok ....
[2017-05-05 13:31:24.306] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:31:24.319] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:31:24.323] [INFO] app - Redis client default is ready {}
[2017-05-05 13:31:24.779] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:31:24.780] [WARN] console - 1
[2017-05-05 13:31:24.780] [WARN] console - 2
[2017-05-05 13:31:24.781] [WARN] console - 2
[2017-05-05 13:31:24.781] [WARN] console - all ok ....
[2017-05-05 13:32:40.776] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:32:40.788] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:32:40.791] [INFO] app - Redis client default is ready {}
[2017-05-05 13:32:41.279] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:32:41.280] [WARN] console - 1
[2017-05-05 13:32:41.281] [WARN] console - 2
[2017-05-05 13:32:41.282] [WARN] console - 0
[2017-05-05 13:32:41.282] [WARN] console - all ok ....
[2017-05-05 13:35:08.172] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:35:08.190] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:35:08.193] [INFO] app - Redis client default is ready {}
[2017-05-05 13:35:08.680] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:35:08.681] [WARN] console - ready status ******** 1
[2017-05-05 13:35:08.682] [WARN] console - 1
[2017-05-05 13:35:08.682] [WARN] console - ready status ******** 2
[2017-05-05 13:35:08.682] [WARN] console - 2
[2017-05-05 13:35:08.683] [WARN] console - 0
[2017-05-05 13:35:08.683] [WARN] console - all ok ....
[2017-05-05 13:35:27.257] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:35:27.269] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:35:27.272] [INFO] app - Redis client default is ready {}
[2017-05-05 13:35:27.745] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:35:27.748] [WARN] console - [ { [Function: callback] readyStatus: 2 },
  { [Function: callback] readyStatus: 1 } ]
[2017-05-05 13:35:27.749] [WARN] console - ready status ******** 1
[2017-05-05 13:35:27.749] [WARN] console - 1
[2017-05-05 13:35:27.749] [WARN] console - [ { [Function: callback] readyStatus: 2 },
  { [Function: callback] readyStatus: 2 } ]
[2017-05-05 13:35:27.750] [WARN] console - ready status ******** 2
[2017-05-05 13:35:27.750] [WARN] console - 2
[2017-05-05 13:35:27.750] [WARN] console - 0
[2017-05-05 13:35:27.750] [WARN] console - all ok ....
[2017-05-05 13:38:20.883] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:38:20.897] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:38:20.901] [INFO] app - Redis client default is ready {}
[2017-05-05 13:38:21.401] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:38:21.403] [WARN] console - ????
[2017-05-05 13:38:21.403] [WARN] console - 1
[2017-05-05 13:38:21.404] [WARN] console - ????
[2017-05-05 13:38:21.404] [WARN] console - 2
[2017-05-05 13:38:21.404] [WARN] console - 0
[2017-05-05 13:38:21.404] [WARN] console - all ok ....
[2017-05-05 13:38:41.164] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:38:41.179] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:38:41.182] [INFO] app - Redis client default is ready {}
[2017-05-05 13:38:41.680] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:38:41.681] [WARN] console - ????
[2017-05-05 13:38:41.682] [WARN] console - 1
[2017-05-05 13:38:41.683] [WARN] console - 1
[2017-05-05 13:38:47.003] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:38:47.015] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:38:47.018] [INFO] app - Redis client default is ready {}
[2017-05-05 13:38:47.557] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:38:47.558] [WARN] console - ????
[2017-05-05 13:38:47.558] [WARN] console - 1
[2017-05-05 13:38:47.559] [WARN] console - ????
[2017-05-05 13:38:47.559] [WARN] console - 2
[2017-05-05 13:38:47.559] [WARN] console - 0
[2017-05-05 13:38:47.559] [WARN] console - all ok ....
[2017-05-05 13:39:17.057] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:39:17.073] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:39:17.080] [INFO] app - Redis client default is ready {}
[2017-05-05 13:39:17.542] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:39:17.545] [WARN] console - ????
[2017-05-05 13:39:17.546] [WARN] console - ????
[2017-05-05 13:39:17.546] [WARN] console - all ok ....
[2017-05-05 13:40:18.217] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:40:18.230] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:40:47.035] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:40:47.059] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:40:55.638] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:40:55.649] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:42:34.853] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:42:34.865] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:42:39.394] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:42:39.441] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:43:14.229] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:43:14.245] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:43:47.132] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:43:47.144] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:44:13.981] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:44:13.994] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:44:32.771] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:44:32.784] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:44:32.788] [INFO] app - Redis client default is ready {}
[2017-05-05 13:44:33.193] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:44:33.194] [WARN] console - all ok ....
[2017-05-05 13:45:09.572] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:45:09.583] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:45:09.586] [INFO] app - Redis client default is ready {}
[2017-05-05 13:45:09.929] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:45:09.931] [WARN] console - all ok ....
[2017-05-05 13:45:18.158] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:45:18.177] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:45:18.182] [INFO] app - Redis client default is ready {}
[2017-05-05 13:45:18.542] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:45:18.545] [WARN] console - all ok ....
[2017-05-05 13:45:27.787] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:45:27.799] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:45:27.803] [INFO] app - Redis client default is ready {}
[2017-05-05 13:45:28.309] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:45:28.311] [WARN] console - all ok ....
[2017-05-05 13:46:17.921] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:46:17.935] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:46:17.938] [INFO] app - Redis client default is ready {}
[2017-05-05 13:46:18.462] [WARN] console - { [Function: callback] readyStatus: 2 }
[2017-05-05 13:46:18.464] [WARN] console - all ok ....
[2017-05-05 13:46:29.949] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:46:29.962] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:46:29.965] [INFO] app - Redis client default is ready {}
[2017-05-05 13:46:30.425] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:46:30.426] [WARN] console - all ok ....
[2017-05-05 13:46:38.712] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:46:38.728] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:46:38.735] [INFO] app - Redis client default is ready {}
[2017-05-05 13:46:39.185] [WARN] console - { [Function: callback] readyStatus: 2 }
[2017-05-05 13:46:39.186] [WARN] console - all ok ....
[2017-05-05 13:46:48.050] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:46:48.061] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:46:48.064] [INFO] app - Redis client default is ready {}
[2017-05-05 13:46:48.571] [WARN] console - { [Function: callback] readyStatus: 2 }
[2017-05-05 13:46:48.572] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:46:48.573] [WARN] console - all ok ....
[2017-05-05 13:48:00.265] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:48:00.283] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:48:00.288] [INFO] app - Redis client default is ready {}
[2017-05-05 13:48:00.770] [WARN] console - { [Function: callback] readyStatus: 2 }
[2017-05-05 13:48:00.771] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:48:00.772] [WARN] console - all ok ....
[2017-05-05 13:50:23.095] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:50:23.107] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:50:23.112] [INFO] app - Redis client default is ready {}
[2017-05-05 13:50:23.642] [WARN] console - { [Function: callback] readyStatus: 2 }
[2017-05-05 13:50:23.644] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:50:23.644] [WARN] console - all ok ....
[2017-05-05 13:50:29.902] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:50:29.914] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:50:29.917] [INFO] app - Redis client default is ready {}
[2017-05-05 13:50:30.407] [WARN] console - { [Function: callback] readyStatus: 2 }
[2017-05-05 13:50:30.409] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:50:30.409] [WARN] console - all ok ....
[2017-05-05 13:50:40.028] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:50:40.047] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:50:40.059] [INFO] app - Redis client default is ready {}
[2017-05-05 13:50:40.567] [WARN] console - { [Function: callback] readyStatus: 2 }
[2017-05-05 13:50:40.568] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:50:40.568] [WARN] console - all ok ....
[2017-05-05 13:50:50.487] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:50:50.511] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:50:50.516] [INFO] app - Redis client default is ready {}
[2017-05-05 13:50:51.404] [WARN] console - { [Function: callback] readyStatus: 2 }
[2017-05-05 13:50:51.406] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:50:51.406] [WARN] console - all ok ....
[2017-05-05 13:50:58.117] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:50:58.137] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:50:58.142] [INFO] app - Redis client default is ready {}
[2017-05-05 13:50:58.671] [WARN] console - 0
[2017-05-05 13:50:58.672] [WARN] console - 0
[2017-05-05 13:50:58.672] [WARN] console - { [Function: callback] readyStatus: 2 }
[2017-05-05 13:50:58.673] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:50:58.673] [WARN] console - all ok ....
[2017-05-05 13:51:09.613] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:51:09.624] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:51:09.627] [INFO] app - Redis client default is ready {}
[2017-05-05 13:51:10.010] [WARN] console - 0
[2017-05-05 13:51:10.011] [WARN] console - 0
[2017-05-05 13:51:10.012] [WARN] console - { [Function: callback] readyStatus: 2 }
[2017-05-05 13:51:10.012] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:51:10.012] [WARN] console - all ok ....
[2017-05-05 13:51:28.029] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:51:28.046] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:51:28.050] [INFO] app - Redis client default is ready {}
[2017-05-05 13:51:28.535] [WARN] console - 0
[2017-05-05 13:51:28.536] [WARN] console - 0
[2017-05-05 13:51:28.537] [WARN] console - { [Function: callback] readyStatus: 2 }
[2017-05-05 13:51:28.537] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:51:28.538] [WARN] console - all ok ....
[2017-05-05 13:52:08.648] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:52:08.659] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:52:08.662] [INFO] app - Redis client default is ready {}
[2017-05-05 13:52:09.136] [WARN] console - { members: 
   [ { [Function: callback] readyStatus: 2 },
     { [Function: callback] readyStatus: 1 } ],
  callbacks: [],
  readyStatus: 0 }
[2017-05-05 13:52:09.138] [WARN] console - 0
[2017-05-05 13:52:09.138] [WARN] console - 0
[2017-05-05 13:52:09.138] [WARN] console - { [Function: callback] readyStatus: 2 }
[2017-05-05 13:52:09.139] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:52:09.139] [WARN] console - all ok ....
[2017-05-05 13:52:32.656] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:52:32.668] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:52:32.671] [INFO] app - Redis client default is ready {}
[2017-05-05 13:52:33.217] [WARN] console - { members: 
   [ { [Function: callback] readyStatus: 2 },
     { [Function: callback] readyStatus: 1 } ],
  callbacks: [],
  readyStatus: 0 }
[2017-05-05 13:52:33.219] [WARN] console - 0
[2017-05-05 13:52:33.220] [WARN] console - 0
[2017-05-05 13:52:33.220] [WARN] console - { [Function: callback] readyStatus: 2 }
[2017-05-05 13:52:33.220] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:52:33.220] [WARN] console - all ok ....
[2017-05-05 13:52:40.101] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:52:40.114] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:52:40.118] [INFO] app - Redis client default is ready {}
[2017-05-05 13:52:40.639] [WARN] console - { members: 
   [ { [Function: callback] readyStatus: 2 },
     { [Function: callback] readyStatus: 1 } ],
  callbacks: [],
  readyStatus: 0 }
[2017-05-05 13:52:40.641] [WARN] console - 0
[2017-05-05 13:52:40.641] [WARN] console - 0
[2017-05-05 13:52:40.642] [WARN] console - { [Function: callback] readyStatus: 2 }
[2017-05-05 13:52:40.642] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:52:40.642] [WARN] console - all ok ....
[2017-05-05 13:53:31.852] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:53:31.867] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:53:31.870] [INFO] app - Redis client default is ready {}
[2017-05-05 13:53:32.425] [WARN] console - 0
[2017-05-05 13:53:32.426] [WARN] console - 0
[2017-05-05 13:53:32.427] [WARN] console - 0
[2017-05-05 13:53:32.427] [WARN] console - { [Function: callback] readyStatus: 2 }
[2017-05-05 13:53:32.428] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:53:32.428] [WARN] console - all ok ....
[2017-05-05 13:53:50.620] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:53:50.632] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:53:50.635] [INFO] app - Redis client default is ready {}
[2017-05-05 13:53:51.118] [WARN] console - ready status ********* 0
[2017-05-05 13:53:51.120] [WARN] console - 0
[2017-05-05 13:53:51.121] [WARN] console - 0
[2017-05-05 13:53:51.121] [WARN] console - { [Function: callback] readyStatus: 2 }
[2017-05-05 13:53:51.122] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:53:51.122] [WARN] console - all ok ....
[2017-05-05 13:54:54.789] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:54:54.806] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:54:54.809] [INFO] app - Redis client default is ready {}
[2017-05-05 13:54:55.315] [WARN] console - ready status ********* 0
[2017-05-05 13:54:55.316] [WARN] console - 0
[2017-05-05 13:54:55.316] [WARN] console - 0
[2017-05-05 13:54:55.317] [WARN] console - { [Function: callback] readyStatus: 2 }
[2017-05-05 13:54:55.318] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:54:55.318] [WARN] console - all ok ....
[2017-05-05 13:54:59.652] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:54:59.665] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:54:59.669] [INFO] app - Redis client default is ready {}
[2017-05-05 13:55:00.249] [WARN] console - mmmm
[2017-05-05 13:55:00.250] [WARN] console - mmmm
[2017-05-05 13:55:00.251] [WARN] console - ready status ********* 0
[2017-05-05 13:55:00.251] [WARN] console - 0
[2017-05-05 13:55:00.252] [WARN] console - 0
[2017-05-05 13:55:00.253] [WARN] console - { [Function: callback] readyStatus: 2 }
[2017-05-05 13:55:00.254] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:55:00.254] [WARN] console - all ok ....
[2017-05-05 13:55:12.483] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:55:12.497] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:55:12.500] [INFO] app - Redis client default is ready {}
[2017-05-05 13:55:12.952] [WARN] console - ready status ********* 0
[2017-05-05 13:55:12.952] [WARN] console - 0
[2017-05-05 13:55:12.953] [WARN] console - 0
[2017-05-05 13:55:12.953] [WARN] console - { [Function: callback] readyStatus: 2 }
[2017-05-05 13:55:12.954] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:55:12.955] [WARN] console - all ok ....
[2017-05-05 13:55:16.223] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:55:16.235] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:55:16.239] [INFO] app - Redis client default is ready {}
[2017-05-05 13:55:16.723] [WARN] console - 0
[2017-05-05 13:55:16.724] [WARN] console - 0
[2017-05-05 13:55:16.724] [WARN] console - { [Function: callback] readyStatus: 2 }
[2017-05-05 13:55:16.725] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 13:55:16.725] [WARN] console - all ok ....
[2017-05-05 13:55:42.317] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:55:42.327] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:55:42.330] [INFO] app - Redis client default is ready {}
[2017-05-05 13:55:42.807] [WARN] console - 1
[2017-05-05 13:55:42.808] [WARN] console - 1
[2017-05-05 13:55:52.414] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:55:52.425] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:55:52.428] [INFO] app - Redis client default is ready {}
[2017-05-05 13:55:52.950] [WARN] console - 1
[2017-05-05 13:55:52.951] [WARN] console - 1
[2017-05-05 13:55:59.610] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:55:59.628] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:55:59.634] [INFO] app - Redis client default is ready {}
[2017-05-05 13:56:00.212] [WARN] console - 1
[2017-05-05 13:56:00.213] [WARN] console - 2
[2017-05-05 13:56:00.213] [WARN] console - 2
[2017-05-05 13:56:00.213] [WARN] console - { [Function: callback] readyStatus: 2 }
[2017-05-05 13:56:00.214] [WARN] console - { [Function: callback] readyStatus: 2 }
[2017-05-05 13:56:00.214] [WARN] console - all ok ....
[2017-05-05 13:56:04.619] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:56:04.631] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:56:04.634] [INFO] app - Redis client default is ready {}
[2017-05-05 13:56:05.150] [WARN] console - 1
[2017-05-05 13:56:05.151] [WARN] console - 1
[2017-05-05 13:56:10.725] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:56:10.739] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:56:10.747] [INFO] app - Redis client default is ready {}
[2017-05-05 13:56:11.263] [WARN] console - 1
[2017-05-05 13:56:11.264] [WARN] console - 2
[2017-05-05 13:56:11.264] [WARN] console - 2
[2017-05-05 13:56:11.265] [WARN] console - { [Function: callback] readyStatus: 2 }
[2017-05-05 13:56:11.265] [WARN] console - { [Function: callback] readyStatus: 2 }
[2017-05-05 13:56:11.266] [WARN] console - all ok ....
[2017-05-05 13:56:17.495] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:56:17.513] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:56:17.515] [INFO] app - Redis client default is ready {}
[2017-05-05 13:56:18.039] [WARN] console - 1
[2017-05-05 13:56:18.040] [WARN] console - 2
[2017-05-05 13:56:18.041] [WARN] console - 2
[2017-05-05 13:56:18.041] [WARN] console - all ok ....
[2017-05-05 13:56:22.290] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:56:22.311] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:56:22.315] [INFO] app - Redis client default is ready {}
[2017-05-05 13:56:22.819] [WARN] console - all ok ....
[2017-05-05 13:57:25.135] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:57:25.148] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:57:38.900] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:57:38.913] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:57:38.916] [INFO] app - Redis client default is ready {}
[2017-05-05 13:57:48.106] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:57:48.117] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:58:02.683] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:58:02.697] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:58:30.997] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:58:31.016] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:59:20.614] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:59:20.629] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:59:45.004] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 13:59:45.020] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 13:59:45.024] [INFO] app - Redis client default is ready {}
[2017-05-05 13:59:45.461] [WARN] console - Ready { '$readyRef': { members: [], callbacks: [], readyStatus: 0 } }
[2017-05-05 13:59:45.463] [WARN] console - undefined
[2017-05-05 13:59:45.473] [WARN] console - { members: [], callbacks: [], readyStatus: 0 }
[2017-05-05 14:00:38.191] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:00:38.202] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:00:56.499] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:00:56.510] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:00:56.513] [INFO] app - Redis client default is ready {}
[2017-05-05 14:00:56.946] [WARN] console - undefined
[2017-05-05 14:00:56.956] [WARN] console - { members: [], callbacks: [], readyStatus: 0 }
[2017-05-05 14:01:09.604] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:01:09.615] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:01:09.620] [INFO] app - Redis client default is ready {}
[2017-05-05 14:01:10.047] [WARN] console - undefined
[2017-05-05 14:01:10.047] [WARN] console - undefined
[2017-05-05 14:01:10.059] [WARN] console - { members: [], callbacks: [], readyStatus: 0 }
[2017-05-05 14:01:22.200] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:01:22.216] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:01:22.221] [INFO] app - Redis client default is ready {}
[2017-05-05 14:01:22.617] [WARN] console - { subdomainOffset: 2, proxy: true, env: 'development' }
[2017-05-05 14:01:22.619] [WARN] console - undefined
[2017-05-05 14:01:22.631] [WARN] console - { members: [], callbacks: [], readyStatus: 0 }
[2017-05-05 14:01:27.818] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:01:27.829] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:01:27.832] [INFO] app - Redis client default is ready {}
[2017-05-05 14:01:28.208] [WARN] console - [Function: use]
[2017-05-05 14:01:28.209] [WARN] console - undefined
[2017-05-05 14:01:28.223] [WARN] console - { members: [], callbacks: [], readyStatus: 0 }
[2017-05-05 14:01:35.466] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:01:35.481] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:01:46.840] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:01:46.853] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:01:46.855] [INFO] app - Redis client default is ready {}
[2017-05-05 14:01:47.271] [WARN] console - [Function: use]
[2017-05-05 14:01:47.272] [WARN] console - undefined
[2017-05-05 14:01:47.288] [WARN] console - { members: [], callbacks: [], readyStatus: 0 }
[2017-05-05 14:02:10.840] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:02:10.853] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:02:10.856] [INFO] app - Redis client default is ready {}
[2017-05-05 14:02:11.229] [WARN] console - undefined
[2017-05-05 14:02:11.239] [WARN] console - { members: [], callbacks: [], readyStatus: 0 }
[2017-05-05 14:02:30.459] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:02:30.473] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:02:41.172] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:02:41.183] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:02:56.569] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:02:56.582] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:03:32.908] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:03:32.921] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:04:00.647] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:04:00.659] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:04:00.662] [INFO] app - Redis client default is ready {}
[2017-05-05 14:04:01.078] [INFO] app - application is startup, listening on port 3000
[2017-05-05 14:04:15.552] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:04:15.562] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:04:15.565] [INFO] app - Redis client default is ready {}
[2017-05-05 14:04:25.271] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:04:25.283] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:04:25.292] [INFO] app - Redis client default is ready {}
[2017-05-05 14:04:25.818] [INFO] app - application is startup, listening on port 3000
[2017-05-05 14:04:38.771] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:04:38.787] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:04:38.790] [INFO] app - Redis client default is ready {}
[2017-05-05 14:04:39.480] [INFO] app - application is startup, listening on port 3000
[2017-05-05 14:06:05.145] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:06:05.156] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:06:05.159] [INFO] app - Redis client default is ready {}
[2017-05-05 14:06:05.638] [INFO] app - application is startup, listening on port 3000
[2017-05-05 14:06:11.541] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:06:11.560] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:06:11.563] [INFO] app - Redis client default is ready {}
[2017-05-05 14:06:12.126] [INFO] app - application is startup, listening on port 3000
[2017-05-05 14:06:16.255] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:06:16.270] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:06:16.273] [INFO] app - Redis client default is ready {}
[2017-05-05 14:06:29.117] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:06:29.132] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:06:29.137] [INFO] app - Redis client default is ready {}
[2017-05-05 14:06:29.634] [WARN] console - { [Function: callback] readyStatus: 1 }
[2017-05-05 14:06:37.582] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:06:37.592] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:06:37.595] [INFO] app - Redis client default is ready {}
[2017-05-05 14:06:38.076] [WARN] console - callback
[2017-05-05 14:08:11.383] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:08:11.405] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:08:11.409] [INFO] app - Redis client default is ready {}
[2017-05-05 14:08:11.879] [WARN] console - callback
[2017-05-05 14:08:18.915] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:08:18.927] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:08:18.930] [INFO] app - Redis client default is ready {}
[2017-05-05 14:08:19.455] [WARN] console - undefined
[2017-05-05 14:08:40.557] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:08:40.570] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:08:40.574] [INFO] app - Redis client default is ready {}
[2017-05-05 14:08:41.133] [WARN] console - undefined
[2017-05-05 14:09:05.193] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:09:05.210] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:09:05.217] [INFO] app - Redis client default is ready {}
[2017-05-05 14:09:05.751] [WARN] console - wire_modules
[2017-05-05 14:09:05.752] [WARN] console - undefined
[2017-05-05 14:09:13.865] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:09:13.879] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:09:13.884] [INFO] app - Redis client default is ready {}
[2017-05-05 14:09:14.415] [WARN] console - wire_modules
[2017-05-05 14:09:40.809] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:09:40.820] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:09:49.642] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:09:49.661] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:11:01.331] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:11:01.344] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:11:01.347] [INFO] app - Redis client default is ready {}
[2017-05-05 14:11:01.735] [WARN] console - wire_modules
[2017-05-05 14:11:15.809] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:11:15.844] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:11:15.856] [INFO] app - Redis client default is ready {}
[2017-05-05 14:11:20.882] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:11:20.899] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:11:20.904] [INFO] app - Redis client default is ready {}
[2017-05-05 14:11:21.428] [WARN] console - { [Function: wire_modules] readyStatus: 1 }
[2017-05-05 14:11:30.680] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:11:30.696] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:11:30.700] [INFO] app - Redis client default is ready {}
[2017-05-05 14:11:31.239] [INFO] app - application is startup, listening on port 3000
[2017-05-05 14:12:25.279] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:12:25.303] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:12:39.980] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:12:39.994] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:14:26.953] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:14:26.968] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:18:00.728] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:18:30.353] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:18:43.563] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:18:43.572] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:18:43.574] [INFO] app - Redis client default is ready {}
[2017-05-05 14:18:57.305] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:18:57.314] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:18:57.315] [INFO] app - Redis client default is ready {}
[2017-05-05 14:19:21.306] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:19:21.317] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:19:21.319] [INFO] app - Redis client default is ready {}
[2017-05-05 14:19:40.357] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:19:40.367] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:19:40.369] [INFO] app - Redis client default is ready {}
[2017-05-05 14:20:02.932] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:20:02.949] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:20:02.951] [INFO] app - Redis client default is ready {}
[2017-05-05 14:20:28.762] [WARN] console - [Function: load]
[2017-05-05 14:20:28.772] [WARN] console - { subdomainOffset: 2, proxy: true, env: 'development' }
[2017-05-05 14:20:28.871] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:20:28.877] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:20:28.879] [INFO] app - Redis client default is ready {}
[2017-05-05 14:20:28.882] [INFO] app - application is startup, listening on port 3000
[2017-05-05 14:20:41.362] [WARN] console - [Function: load]
[2017-05-05 14:20:41.368] [WARN] console - { subdomainOffset: 2, proxy: true, env: 'development' }
[2017-05-05 14:20:41.423] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:20:41.430] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:20:41.432] [INFO] app - Redis client default is ready {}
[2017-05-05 14:20:49.542] [WARN] console - [Function: load]
[2017-05-05 14:20:49.550] [WARN] console - { subdomainOffset: 2, proxy: true, env: 'development' }
[2017-05-05 14:20:49.622] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:20:49.632] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:20:49.634] [INFO] app - Redis client default is ready {}
[2017-05-05 14:20:49.637] [INFO] app - application is startup, listening on port 3000
[2017-05-05 14:21:01.414] [WARN] console - { subdomainOffset: 2, proxy: true, env: 'development' }
[2017-05-05 14:21:01.503] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:21:01.510] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:21:01.512] [INFO] app - Redis client default is ready {}
[2017-05-05 14:21:01.516] [INFO] app - application is startup, listening on port 3000
[2017-05-05 14:22:07.825] [WARN] console - { subdomainOffset: 2, proxy: true, env: 'development' }
[2017-05-05 14:22:07.921] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:22:07.929] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:22:07.932] [INFO] app - Redis client default is ready {}
[2017-05-05 14:22:07.936] [INFO] app - application is startup, listening on port 3000
[2017-05-05 14:23:24.783] [WARN] console - { subdomainOffset: 2, proxy: true, env: 'development' }
[2017-05-05 14:23:24.867] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:23:24.793] [WARN] console - { subdomainOffset: 2, proxy: true, env: 'development' }
[2017-05-05 14:23:24.878] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:23:24.877] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:23:24.880] [INFO] app - Redis client default is ready {}
[2017-05-05 14:23:24.883] [INFO] app - application is startup, listening on port 3000
[2017-05-05 14:23:33.062] [WARN] console - { subdomainOffset: 2, proxy: true, env: 'development' }
[2017-05-05 14:23:33.126] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:23:33.139] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:23:33.142] [INFO] app - Redis client default is ready {}
[2017-05-05 14:23:33.145] [INFO] app - application is startup, listening on port 3000
[2017-05-05 14:24:38.734] [DEBUG] app - 2017-5-5 14:24:38 ::1 -- GET / HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 14:24:39.628] [DEBUG] app - 2017-5-5 14:24:39 ::1 -- GET / HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 14:24:44.861] [DEBUG] app - 2017-5-5 14:24:44 ::1 -- GET /api/user HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 14:24:44.863] [ERROR] app - { [NotFoundError: Not Found]
  restCode: null,
  statusCode: 404,
  message: 'Not Found',
  constructorOpt: undefined,
  name: 'NotFoundError',
  expose: true,
  status: 404 }
[2017-05-05 14:24:47.209] [DEBUG] app - 2017-5-5 14:24:47 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 14:24:47.210] [WARN] console - this is a logger middleware.
[2017-05-05 14:24:47.359] [DEBUG] app - 2017-5-5 14:24:47 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 14:24:47.360] [WARN] console - this is a logger middleware.
[2017-05-05 14:26:06.779] [WARN] console - { subdomainOffset: 2, proxy: true, env: 'development' }
[2017-05-05 14:26:06.836] [INFO] console - 
[2017-05-05 14:26:06.838] [INFO] console - [0m[0m
[2017-05-05 14:26:06.860] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:26:06.863] [INFO] console - [0m  Example Node Server[0m
[2017-05-05 14:26:06.877] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:26:06.880] [INFO] app - Redis client default is ready {}
[2017-05-05 14:26:06.883] [INFO] app - application is startup, listening on port 3000
[2017-05-05 14:26:06.901] [DEBUG] app - 2017-5-5 14:26:06 ::ffff:127.0.0.1 -- GET /user HTTP/1.1, null undefined
[2017-05-05 14:26:06.906] [ERROR] app - { [NotFoundError: Not Found]
  restCode: null,
  statusCode: 404,
  message: 'Not Found',
  constructorOpt: undefined,
  name: 'NotFoundError',
  expose: true,
  status: 404 }
[2017-05-05 14:29:03.485] [WARN] console - { subdomainOffset: 2, proxy: true, env: 'development' }
[2017-05-05 14:29:03.528] [INFO] console - 
[2017-05-05 14:29:03.529] [INFO] console - [0m[0m
[2017-05-05 14:29:03.546] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:29:03.549] [INFO] console - [0m  Example Node Server[0m
[2017-05-05 14:29:03.556] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:29:03.560] [INFO] app - Redis client default is ready {}
[2017-05-05 14:29:03.564] [INFO] app - application is startup, listening on port 3000
[2017-05-05 14:29:03.580] [DEBUG] app - 2017-5-5 14:29:03 ::ffff:127.0.0.1 -- GET /user HTTP/1.1, null undefined
[2017-05-05 14:29:03.584] [ERROR] app - { [NotFoundError: Not Found]
  restCode: null,
  statusCode: 404,
  message: 'Not Found',
  constructorOpt: undefined,
  name: 'NotFoundError',
  expose: true,
  status: 404 }
[2017-05-05 14:30:19.927] [INFO] console - 
[2017-05-05 14:30:19.931] [INFO] console - [0m[0m
[2017-05-05 14:30:56.415] [INFO] console - 
[2017-05-05 14:30:56.418] [INFO] console - [0m[0m
[2017-05-05 14:31:04.320] [INFO] console - 
[2017-05-05 14:31:04.323] [INFO] console - [0m[0m
[2017-05-05 14:31:49.826] [INFO] console - 
[2017-05-05 14:31:49.832] [INFO] console - [0m[0m
[2017-05-05 14:32:09.635] [INFO] console - 
[2017-05-05 14:32:09.638] [INFO] console - [0m[0m
[2017-05-05 14:32:32.123] [INFO] console - 
[2017-05-05 14:32:32.127] [INFO] console - [0m[0m
[2017-05-05 14:32:42.263] [INFO] console - 
[2017-05-05 14:32:42.267] [INFO] console - [0m[0m
[2017-05-05 14:33:21.675] [INFO] console - 
[2017-05-05 14:33:21.678] [INFO] console - [0m[0m
[2017-05-05 14:33:21.696] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:33:21.745] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:33:21.748] [INFO] console - [0m  UserService[0m
[2017-05-05 14:33:21.751] [INFO] app - Redis client default is ready {}
[2017-05-05 14:33:21.759] [INFO] console -   [31m  1) #getUser[0m
[2017-05-05 14:33:21.761] [INFO] console - 
[2017-05-05 14:33:49.494] [INFO] console - 
[2017-05-05 14:33:49.497] [INFO] console - [0m[0m
[2017-05-05 14:33:49.515] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:33:49.559] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:33:49.562] [INFO] console - [0m  UserService[0m
[2017-05-05 14:33:49.564] [INFO] app - Redis client default is ready {}
[2017-05-05 14:33:49.571] [INFO] console -   [31m  1) #getUser[0m
[2017-05-05 14:33:49.575] [INFO] console - 
[2017-05-05 14:34:23.249] [INFO] console - 
[2017-05-05 14:34:23.253] [INFO] console - [0m[0m
[2017-05-05 14:34:23.266] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:34:23.311] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:34:23.313] [INFO] console - [0m  UserService[0m
[2017-05-05 14:34:23.315] [INFO] app - Redis client default is ready {}
[2017-05-05 14:34:23.318] [WARN] console - { errors: 
   { BadRequestError: { [Function: BadRequestError] super_: [Object] },
     UnauthorizedError: { [Function: UnauthorizedError] super_: [Object] },
     PaymentRequiredError: { [Function: PaymentRequiredError] super_: [Object] },
     ForbiddenError: { [Function: ForbiddenError] super_: [Object] },
     NotFoundError: { [Function: NotFoundError] super_: [Object] },
     MethodNotAllowedError: { [Function: MethodNotAllowedError] super_: [Object] },
     NotAcceptableError: { [Function: NotAcceptableError] super_: [Object] },
     ProxyAuthenticationRequiredError: { [Function: ProxyAuthenticationRequiredError] super_: [Object] },
     RequestTimeoutError: { [Function: RequestTimeoutError] super_: [Object] },
     ConflictError: { [Function: ConflictError] super_: [Object] },
     GoneError: { [Function: GoneError] super_: [Object] },
     LengthRequiredError: { [Function: LengthRequiredError] super_: [Object] },
     PreconditionFailedError: { [Function: PreconditionFailedError] super_: [Object] },
     RequestEntityTooLargeError: { [Function: RequestEntityTooLargeError] super_: [Object] },
     RequesturiTooLargeError: { [Function: RequesturiTooLargeError] super_: [Object] },
     UnsupportedMediaTypeError: { [Function: UnsupportedMediaTypeError] super_: [Object] },
     RequestedRangeNotSatisfiableError: { [Function: RequestedRangeNotSatisfiableError] super_: [Object] },
     ExpectationFailedError: { [Function: ExpectationFailedError] super_: [Object] },
     ImATeapotError: { [Function: ImATeapotError] super_: [Object] },
     UnprocessableEntityError: { [Function: UnprocessableEntityError] super_: [Object] },
     LockedError: { [Function: LockedError] super_: [Object] },
     FailedDependencyError: { [Function: FailedDependencyError] super_: [Object] },
     UnorderedCollectionError: { [Function: UnorderedCollectionError] super_: [Object] },
     UpgradeRequiredError: { [Function: UpgradeRequiredError] super_: [Object] },
     PreconditionRequiredError: { [Function: PreconditionRequiredError] super_: [Object] },
     TooManyRequestsError: { [Function: TooManyRequestsError] super_: [Object] },
     RequestHeaderFieldsTooLargeError: { [Function: RequestHeaderFieldsTooLargeError] super_: [Object] },
     InternalServerError: { [Function: InternalServerError] super_: [Object] },
     NotImplementedError: { [Function: NotImplementedError] super_: [Object] },
     BadGatewayError: { [Function: BadGatewayError] super_: [Object] },
     ServiceUnavailableError: { [Function: ServiceUnavailableError] super_: [Object] },
     GatewayTimeoutError: { [Function: GatewayTimeoutError] super_: [Object] },
     HttpVersionNotSupportedError: { [Function: HttpVersionNotSupportedError] super_: [Object] },
     VariantAlsoNegotiatesError: { [Function: VariantAlsoNegotiatesError] super_: [Object] },
     InsufficientStorageError: { [Function: InsufficientStorageError] super_: [Object] },
     BandwidthLimitExceededError: { [Function: BandwidthLimitExceededError] super_: [Object] },
     NotExtendedError: { [Function: NotExtendedError] super_: [Object] },
     NetworkAuthenticationRequiredError: { [Function: NetworkAuthenticationRequiredError] super_: [Object] },
     BadDigestError: { [Function: BadDigestError] super_: [Object] },
     BadMethodError: { [Function: BadMethodError] super_: [Object] },
     InternalError: { [Function: InternalError] super_: [Object] },
     InvalidArgumentError: { [Function: InvalidArgumentError] super_: [Object] },
     InvalidContentError: { [Function: InvalidContentError] super_: [Object] },
     InvalidCredentialsError: { [Function: InvalidCredentialsError] super_: [Object] },
     InvalidHeaderError: { [Function: InvalidHeaderError] super_: [Object] },
     MissingParameterError: { [Function: MissingParameterError] super_: [Object] },
     NotAuthorizedError: { [Function: NotAuthorizedError] super_: [Object] },
     RequestExpiredError: { [Function: RequestExpiredError] super_: [Object] },
     RequestThrottledError: { [Function: RequestThrottledError] super_: [Object] },
     WrongAcceptError: { [Function: WrongAcceptError] super_: [Object] } },
  redis: 
   { main: 
      RedisClient {
        domain: null,
        _events: [Object],
        _eventsCount: 6,
        _maxListeners: undefined,
        address: '127.0.0.1:6379',
        connection_options: [Object],
        connection_id: 0,
        connected: true,
        ready: true,
        should_buffer: false,
        max_attempts: 0,
        command_queue: [Object],
        offline_queue: [Object],
        pipeline_queue: [Object],
        connect_timeout: 3600000,
        enable_offline_queue: true,
        retry_max_delay: null,
        retry_timer: null,
        retry_totaltime: 0,
        retry_delay: 200,
        retry_backoff: 1.7,
        attempts: 1,
        pub_sub_mode: 0,
        subscription_set: {},
        monitoring: false,
        message_buffers: false,
        closing: false,
        server_info: [Object],
        auth_pass: undefined,
        selected_db: undefined,
        old_state: null,
        fire_strings: true,
        pipeline: false,
        sub_commands_left: 0,
        times_connected: 1,
        buffers: false,
        options: [Object],
        reply: 'ON',
        reply_parser: [Object],
        stream: [Object],
        emitted_end: false,
        cork: [Function],
        uncork: [Function] } },
  mongoose: 
   { main: 
      Mongoose {
        connections: [Object],
        plugins: [],
        models: [Object],
        modelSchemas: [Object],
        options: [Object] } },
  controllers: 
   { userController: UserController {},
     mainController: MainController {} },
  services: { UserService: [Function] },
  models: 
   { User: 
      { [Function: model]
        hooks: [Object],
        base: [Object],
        modelName: 'User',
        model: [Function: model],
        db: [Object],
        discriminators: undefined,
        schema: [Object],
        collection: [Object],
        Query: [Object],
        '$__insertMany': [Function],
        insertMany: [Function] } },
  kvs: { UserKv: [Function] },
  logger: Logger { category: 'app', _events: { log: [Object] }, _eventsCount: 1 } }
[2017-05-05 14:34:23.338] [INFO] console -   [31m  1) #getUser[0m
[2017-05-05 14:34:41.782] [INFO] console - 
[2017-05-05 14:34:41.785] [INFO] console - [0m[0m
[2017-05-05 14:34:41.798] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:34:41.845] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:34:41.847] [INFO] console - [0m  UserService[0m
[2017-05-05 14:34:41.848] [INFO] app - Redis client default is ready {}
[2017-05-05 14:34:41.851] [WARN] console - { UserService: [Function] }
[2017-05-05 14:34:41.857] [INFO] console -   [31m  1) #getUser[0m
[2017-05-05 14:35:03.669] [INFO] console - 
[2017-05-05 14:35:03.672] [INFO] console - [0m[0m
[2017-05-05 14:35:03.692] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:35:03.732] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:35:03.734] [INFO] console - [0m  UserService[0m
[2017-05-05 14:35:03.736] [INFO] app - Redis client default is ready {}
[2017-05-05 14:35:03.740] [WARN] console - { UserService: [Function] }
[2017-05-05 14:35:03.758] [INFO] console -   [31m  1) #getUser[0m
[2017-05-05 14:35:03.761] [INFO] console - 
[2017-05-05 14:35:21.990] [INFO] console - 
[2017-05-05 14:35:21.994] [INFO] console - [0m[0m
[2017-05-05 14:35:22.015] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:35:22.057] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:35:22.060] [INFO] console - [0m  UserService[0m
[2017-05-05 14:35:22.062] [INFO] app - Redis client default is ready {}
[2017-05-05 14:35:22.081] [WARN] console - [ { username: '222', id: '5902b753c5756d72945d90b3' },
  { username: 'user0.38955004828614115',
    id: '590467fb9bb491da74caee32' },
  { username: 'user0.9823151939002306',
    id: '5904689fb4b502db0a450395' } ]
[2017-05-05 14:35:22.089] [INFO] console -   [31m  1) #getUser[0m
[2017-05-05 14:35:22.094] [INFO] console - 
[2017-05-05 14:35:44.903] [INFO] console - 
[2017-05-05 14:35:44.906] [INFO] console - [0m[0m
[2017-05-05 14:35:44.923] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:35:44.977] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:35:44.982] [INFO] console - [0m  UserService[0m
[2017-05-05 14:35:44.985] [INFO] app - Redis client default is ready {}
[2017-05-05 14:35:45.016] [WARN] console - [ { username: '222', id: '5902b753c5756d72945d90b3' },
  { username: 'user0.38955004828614115',
    id: '590467fb9bb491da74caee32' },
  { username: 'user0.9823151939002306',
    id: '5904689fb4b502db0a450395' } ]
[2017-05-05 14:35:45.021] [INFO] console -   [32m  [0m[90m #getUser[0m
[2017-05-05 14:35:45.025] [INFO] console - 
[2017-05-05 14:36:00.551] [INFO] console - 
[2017-05-05 14:36:00.554] [INFO] console - [0m[0m
[2017-05-05 14:36:00.572] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:36:00.629] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:36:00.632] [INFO] console - [0m  UserService[0m
[2017-05-05 14:36:00.634] [INFO] app - Redis client default is ready {}
[2017-05-05 14:36:00.656] [WARN] console - [ { username: '222', id: '5902b753c5756d72945d90b3' },
  { username: 'user0.38955004828614115',
    id: '590467fb9bb491da74caee32' },
  { username: 'user0.9823151939002306',
    id: '5904689fb4b502db0a450395' } ]
[2017-05-05 14:36:00.663] [INFO] console -   [31m  1) #getUser[0m
[2017-05-05 14:36:00.669] [INFO] console - 
[2017-05-05 14:36:28.773] [INFO] console - 
[2017-05-05 14:36:28.776] [INFO] console - [0m[0m
[2017-05-05 14:36:28.791] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:36:28.797] [INFO] console - [0m  Example Node Server[0m
[2017-05-05 14:36:28.805] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:36:28.807] [INFO] app - Redis client default is ready {}
[2017-05-05 14:36:28.811] [INFO] app - application is startup, listening on port 3000
[2017-05-05 14:36:28.828] [DEBUG] app - 2017-5-5 14:36:28 ::ffff:127.0.0.1 -- GET /user HTTP/1.1, null undefined
[2017-05-05 14:36:28.832] [ERROR] app - { [NotFoundError: Not Found]
  restCode: null,
  statusCode: 404,
  message: 'Not Found',
  constructorOpt: undefined,
  name: 'NotFoundError',
  expose: true,
  status: 404 }
[2017-05-05 14:36:28.839] [WARN] console - Not Found
[2017-05-05 14:36:56.692] [INFO] console - 
[2017-05-05 14:36:56.695] [INFO] console - [0m[0m
[2017-05-05 14:36:56.715] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:36:56.721] [INFO] console - [0m  Example Node Server[0m
[2017-05-05 14:36:56.727] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:36:56.731] [INFO] app - Redis client default is ready {}
[2017-05-05 14:36:56.735] [INFO] app - application is startup, listening on port 3000
[2017-05-05 14:36:56.752] [DEBUG] app - 2017-5-5 14:36:56 ::ffff:127.0.0.1 -- GET /api/user/111 HTTP/1.1, null undefined
[2017-05-05 14:36:56.755] [WARN] console - this is a logger middleware.
[2017-05-05 14:36:56.784] [WARN] console - OK
[2017-05-05 14:36:56.785] [INFO] console -   [32m  [0m[90m should return 200[0m[33m (47ms)[0m
[2017-05-05 14:36:56.788] [INFO] console - 
[2017-05-05 14:36:56.790] [INFO] console - 
[2017-05-05 14:37:57.617] [INFO] console - 
[2017-05-05 14:37:57.623] [INFO] console - [0m[0m
[2017-05-05 14:37:57.652] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:37:57.657] [INFO] console - [0m  Example Node Server[0m
[2017-05-05 14:37:57.669] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:37:57.672] [INFO] app - Redis client default is ready {}
[2017-05-05 14:37:57.676] [INFO] app - application is startup, listening on port 3000
[2017-05-05 14:38:36.637] [INFO] console - 
[2017-05-05 14:38:36.642] [INFO] console - [0m[0m
[2017-05-05 14:38:36.654] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:38:36.656] [INFO] console - [0m  Example Node Server[0m
[2017-05-05 14:38:36.666] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:38:36.670] [INFO] app - Redis client default is ready {}
[2017-05-05 14:38:36.673] [INFO] app - application is startup, listening on port 3000
[2017-05-05 14:38:48.658] [INFO] console - 
[2017-05-05 14:38:48.661] [INFO] console - [0m[0m
[2017-05-05 14:38:48.680] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:38:48.684] [INFO] console - [0m  Example Node Server[0m
[2017-05-05 14:38:48.692] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:38:48.695] [INFO] app - Redis client default is ready {}
[2017-05-05 14:38:48.700] [INFO] app - application is startup, listening on port 3000
[2017-05-05 14:38:48.707] [INFO] console -   [31m  1) should return 200[0m
[2017-05-05 14:39:42.823] [WARN] console - {}
[2017-05-05 14:39:42.829] [INFO] console - 
[2017-05-05 14:39:42.830] [INFO] console - [0m[0m
[2017-05-05 14:39:42.844] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:39:42.846] [INFO] console - [0m  Example Node Server[0m
[2017-05-05 14:39:42.855] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:39:42.857] [INFO] app - Redis client default is ready {}
[2017-05-05 14:39:42.860] [INFO] app - application is startup, listening on port 3000
[2017-05-05 14:40:45.951] [WARN] console - {}
[2017-05-05 14:40:45.959] [INFO] console - 
[2017-05-05 14:40:45.960] [INFO] console - [0m[0m
[2017-05-05 14:40:45.976] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:40:45.979] [INFO] console - [0m  Example Node Server[0m
[2017-05-05 14:40:45.991] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:40:45.993] [INFO] app - Redis client default is ready {}
[2017-05-05 14:40:45.996] [INFO] app - application is startup, listening on port 3000
[2017-05-05 14:41:33.602] [WARN] console - {}
[2017-05-05 14:41:33.608] [INFO] console - 
[2017-05-05 14:41:33.608] [INFO] console - [0m[0m
[2017-05-05 14:41:33.622] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:41:33.624] [INFO] console - [0m  Example Node Server[0m
[2017-05-05 14:41:33.635] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:41:33.640] [INFO] app - Redis client default is ready {}
[2017-05-05 14:41:58.883] [WARN] console - ********** {}
[2017-05-05 14:41:58.889] [INFO] console - 
[2017-05-05 14:41:58.890] [INFO] console - [0m[0m
[2017-05-05 14:41:58.907] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:41:58.909] [INFO] console - [0m  Example Node Server[0m
[2017-05-05 14:41:58.914] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:41:58.917] [INFO] app - Redis client default is ready {}
[2017-05-05 14:42:15.939] [WARN] console - ********** { subdomainOffset: 2, proxy: true, env: 'development' }
[2017-05-05 14:42:15.952] [INFO] console - 
[2017-05-05 14:42:15.953] [INFO] console - [0m[0m
[2017-05-05 14:42:15.966] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:42:15.968] [INFO] console - [0m  Example Node Server[0m
[2017-05-05 14:42:15.978] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:42:15.982] [INFO] app - Redis client default is ready {}
[2017-05-05 14:42:27.236] [WARN] console - ********** { subdomainOffset: 2, proxy: true, env: 'development' }
[2017-05-05 14:42:27.242] [INFO] console - 
[2017-05-05 14:42:27.243] [INFO] console - [0m[0m
[2017-05-05 14:42:27.260] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:42:27.261] [INFO] console - [0m  Example Node Server[0m
[2017-05-05 14:42:27.266] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:42:27.269] [INFO] app - Redis client default is ready {}
[2017-05-05 14:48:16.214] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:48:16.229] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:48:16.232] [INFO] app - Redis client default is ready {}
[2017-05-05 14:48:16.236] [INFO] app - application is startup, listening on port 3000
[2017-05-05 14:48:20.858] [DEBUG] app - 2017-5-5 14:48:20 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 14:48:20.861] [WARN] console - this is a logger middleware.
[2017-05-05 14:48:21.576] [DEBUG] app - 2017-5-5 14:48:21 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 14:48:21.576] [WARN] console - this is a logger middleware.
[2017-05-05 14:48:38.546] [WARN] console - ********** { subdomainOffset: 2, proxy: true, env: 'development' }
[2017-05-05 14:48:38.553] [INFO] console - 
[2017-05-05 14:48:38.554] [INFO] console - [0m[0m
[2017-05-05 14:48:38.577] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:48:38.580] [INFO] console - [0m  Example Node Server[0m
[2017-05-05 14:48:38.586] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:48:38.588] [INFO] app - Redis client default is ready {}
[2017-05-05 14:48:38.596] [INFO] console -   [31m  1) should return 200[0m
[2017-05-05 14:49:25.467] [WARN] console - ********** { subdomainOffset: 2, proxy: true, env: 'development' }
[2017-05-05 14:49:25.474] [INFO] console - 
[2017-05-05 14:49:25.475] [INFO] console - [0m[0m
[2017-05-05 14:49:25.492] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:49:25.495] [INFO] console - [0m  Example Node Server[0m
[2017-05-05 14:49:25.508] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:49:25.510] [INFO] app - Redis client default is ready {}
[2017-05-05 14:49:25.519] [INFO] console -   [32m  [0m[90m should return 200[0m
[2017-05-05 14:49:51.719] [WARN] console - ********** { subdomainOffset: 2, proxy: true, env: 'development' }
[2017-05-05 14:49:51.726] [INFO] console - 
[2017-05-05 14:49:51.727] [INFO] console - [0m[0m
[2017-05-05 14:49:51.739] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:49:51.742] [INFO] console - [0m  Example Node Server[0m
[2017-05-05 14:49:51.750] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:49:51.753] [INFO] app - Redis client default is ready {}
[2017-05-05 14:50:11.833] [WARN] console - ********** { subdomainOffset: 2, proxy: true, env: 'development' }
[2017-05-05 14:50:11.839] [INFO] console - 
[2017-05-05 14:50:11.840] [INFO] console - [0m[0m
[2017-05-05 14:50:11.857] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:50:11.861] [INFO] console - [0m  Example Node Server[0m
[2017-05-05 14:50:11.870] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:50:11.872] [INFO] app - Redis client default is ready {}
[2017-05-05 14:50:13.881] [INFO] console -   [31m  1) should return 200[0m
[2017-05-05 14:50:13.885] [INFO] console - 
[2017-05-05 14:50:13.886] [INFO] console - 
[2017-05-05 14:50:51.198] [WARN] console - ********** { subdomainOffset: 2, proxy: true, env: 'development' }
[2017-05-05 14:50:51.206] [INFO] console - 
[2017-05-05 14:50:51.207] [INFO] console - [0m[0m
[2017-05-05 14:50:51.224] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:50:51.227] [INFO] console - [0m  Example Node Server[0m
[2017-05-05 14:50:51.235] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:50:51.237] [INFO] app - Redis client default is ready {}
[2017-05-05 14:50:56.243] [INFO] console -   [31m  1) should return 200[0m
[2017-05-05 14:50:56.245] [INFO] console - 
[2017-05-05 14:50:56.247] [INFO] console - 
[2017-05-05 14:52:21.580] [WARN] console - ********** { subdomainOffset: 2, proxy: true, env: 'development' }
[2017-05-05 14:52:21.589] [INFO] console - 
[2017-05-05 14:52:21.590] [INFO] console - [0m[0m
[2017-05-05 14:52:21.604] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:52:21.605] [INFO] console - [0m  Example Node Server[0m
[2017-05-05 14:52:21.612] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:52:21.615] [INFO] app - Redis client default is ready {}
[2017-05-05 14:52:21.637] [WARN] console - undefined
[2017-05-05 14:52:26.622] [INFO] console -   [31m  1) should return 200[0m
[2017-05-05 14:52:26.625] [INFO] console - 
[2017-05-05 14:52:26.626] [INFO] console - 
[2017-05-05 14:52:31.764] [WARN] console - ********** { subdomainOffset: 2, proxy: true, env: 'development' }
[2017-05-05 14:52:31.770] [INFO] console - 
[2017-05-05 14:52:31.771] [INFO] console - [0m[0m
[2017-05-05 14:52:31.788] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:52:31.792] [INFO] console - [0m  Example Node Server[0m
[2017-05-05 14:52:31.801] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:52:31.804] [INFO] app - Redis client default is ready {}
[2017-05-05 14:52:31.820] [WARN] console - TypeError: Cannot read property 'status' of undefined
    at Test._assertStatus (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/supertest/lib/test.js:229:10)
    at Test._assertFunction (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/supertest/lib/test.js:247:11)
    at Test.assert (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/supertest/lib/test.js:148:18)
    at assert (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/supertest/lib/test.js:127:12)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/supertest/lib/test.js:124:5
    at Test.Request.callback (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/superagent/lib/node/index.js:687:12)
    at ClientRequest.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/superagent/lib/node/index.js:639:10)
    at emitOne (events.js:96:13)
    at ClientRequest.emit (events.js:191:7)
    at Socket.socketErrorListener (_http_client.js:358:9)
    at emitOne (events.js:96:13)
    at Socket.emit (events.js:191:7)
    at emitErrorNT (net.js:1283:8)
    at _combinedTickCallback (internal/process/next_tick.js:80:11)
    at process._tickCallback (internal/process/next_tick.js:104:9)
[2017-05-05 14:52:36.813] [INFO] console -   [31m  1) should return 200[0m
[2017-05-05 14:52:36.817] [INFO] console - 
[2017-05-05 14:52:36.819] [INFO] console - 
[2017-05-05 14:53:01.204] [WARN] console - ********** { subdomainOffset: 2, proxy: true, env: 'development' }
[2017-05-05 14:53:01.213] [INFO] console - 
[2017-05-05 14:53:01.214] [INFO] console - [0m[0m
[2017-05-05 14:53:01.236] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:53:01.240] [INFO] console - [0m  Example Node Server[0m
[2017-05-05 14:53:01.247] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:53:01.250] [INFO] app - Redis client default is ready {}
[2017-05-05 14:53:01.270] [WARN] console - TypeError: Cannot read property 'status' of undefined
    at Test._assertStatus (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/supertest/lib/test.js:229:10)
    at Test._assertFunction (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/supertest/lib/test.js:247:11)
    at Test.assert (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/supertest/lib/test.js:148:18)
    at assert (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/supertest/lib/test.js:127:12)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/supertest/lib/test.js:124:5
    at Test.Request.callback (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/superagent/lib/node/index.js:687:12)
    at ClientRequest.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/superagent/lib/node/index.js:639:10)
    at emitOne (events.js:96:13)
    at ClientRequest.emit (events.js:191:7)
    at Socket.socketErrorListener (_http_client.js:358:9)
    at emitOne (events.js:96:13)
    at Socket.emit (events.js:191:7)
    at emitErrorNT (net.js:1283:8)
    at _combinedTickCallback (internal/process/next_tick.js:80:11)
    at process._tickCallback (internal/process/next_tick.js:104:9)
[2017-05-05 14:53:06.258] [INFO] console -   [31m  1) should return 200[0m
[2017-05-05 14:53:06.261] [INFO] console - 
[2017-05-05 14:53:06.263] [INFO] console - 
[2017-05-05 14:53:21.853] [WARN] console - ********** { subdomainOffset: 2, proxy: true, env: 'development' }
[2017-05-05 14:53:21.859] [INFO] console - 
[2017-05-05 14:53:21.860] [INFO] console - [0m[0m
[2017-05-05 14:53:21.875] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:53:21.881] [INFO] console - [0m  Example Node Server[0m
[2017-05-05 14:53:21.890] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:53:21.892] [INFO] app - Redis client default is ready {}
[2017-05-05 14:53:21.913] [DEBUG] app - 2017-5-5 14:53:21 ::ffff:127.0.0.1 -- GET /user/111 HTTP/1.1, null node-superagent/1.8.5
[2017-05-05 14:53:21.917] [ERROR] app - { [NotFoundError: Not Found]
  restCode: null,
  statusCode: 404,
  message: 'Not Found',
  constructorOpt: undefined,
  name: 'NotFoundError',
  expose: true,
  status: 404 }
[2017-05-05 14:53:21.929] [WARN] console - Error: expected 200 "OK", got 404 "Not Found"
    at Test._assertStatus (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/supertest/lib/test.js:232:12)
    at Test._assertFunction (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/supertest/lib/test.js:247:11)
    at Test.assert (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/supertest/lib/test.js:148:18)
    at assert (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/supertest/lib/test.js:127:12)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/supertest/lib/test.js:124:5
    at Test.Request.callback (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/superagent/lib/node/index.js:703:3)
    at IncomingMessage.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/superagent/lib/node/index.js:922:12)
    at emitNone (events.js:91:20)
    at IncomingMessage.emit (events.js:188:7)
    at endReadableNT (_stream_readable.js:975:12)
    at _combinedTickCallback (internal/process/next_tick.js:80:11)
    at process._tickCallback (internal/process/next_tick.js:104:9)
[2017-05-05 14:53:26.898] [INFO] console -   [31m  1) should return 200[0m
[2017-05-05 14:53:26.903] [INFO] console - 
[2017-05-05 14:53:26.904] [INFO] console - 
[2017-05-05 14:53:37.728] [WARN] console - ********** { subdomainOffset: 2, proxy: true, env: 'development' }
[2017-05-05 14:53:37.736] [INFO] console - 
[2017-05-05 14:53:37.737] [INFO] console - [0m[0m
[2017-05-05 14:53:37.753] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:53:37.756] [INFO] console - [0m  Example Node Server[0m
[2017-05-05 14:53:37.764] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:53:37.767] [INFO] app - Redis client default is ready {}
[2017-05-05 14:53:37.789] [DEBUG] app - 2017-5-5 14:53:37 ::ffff:127.0.0.1 -- GET /api/user/111 HTTP/1.1, null node-superagent/1.8.5
[2017-05-05 14:53:37.792] [WARN] console - this is a logger middleware.
[2017-05-05 14:53:37.821] [WARN] console - null
[2017-05-05 14:53:42.772] [INFO] console -   [31m  1) should return 200[0m
[2017-05-05 14:53:42.775] [INFO] console - 
[2017-05-05 14:53:42.777] [INFO] console - 
[2017-05-05 14:53:45.614] [WARN] console - ********** { subdomainOffset: 2, proxy: true, env: 'development' }
[2017-05-05 14:53:45.621] [INFO] console - 
[2017-05-05 14:53:45.622] [INFO] console - [0m[0m
[2017-05-05 14:53:45.639] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:53:45.641] [INFO] console - [0m  Example Node Server[0m
[2017-05-05 14:53:45.648] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:53:45.650] [INFO] app - Redis client default is ready {}
[2017-05-05 14:53:45.671] [DEBUG] app - 2017-5-5 14:53:45 ::ffff:127.0.0.1 -- GET /api/user/111 HTTP/1.1, null node-superagent/1.8.5
[2017-05-05 14:53:45.675] [WARN] console - this is a logger middleware.
[2017-05-05 14:53:45.706] [WARN] console - Response {
  domain: null,
  _events: {},
  _eventsCount: 0,
  _maxListeners: undefined,
  res: 
   IncomingMessage {
     _readableState: 
      ReadableState {
        objectMode: false,
        highWaterMark: 16384,
        buffer: [Object],
        length: 0,
        pipes: null,
        pipesCount: 0,
        flowing: true,
        ended: true,
        endEmitted: true,
        reading: false,
        sync: true,
        needReadable: false,
        emittedReadable: false,
        readableListening: false,
        resumeScheduled: false,
        defaultEncoding: 'utf8',
        ranOut: false,
        awaitDrain: 0,
        readingMore: false,
        decoder: [Object],
        encoding: 'utf8' },
     readable: false,
     domain: null,
     _events: 
      { end: [Object],
        data: [Object],
        error: [Object],
        close: [Function: bound emit] },
     _eventsCount: 4,
     _maxListeners: undefined,
     socket: 
      Socket {
        connecting: false,
        _hadError: false,
        _handle: null,
        _parent: null,
        _host: null,
        _readableState: [Object],
        readable: false,
        domain: null,
        _events: [Object],
        _eventsCount: 8,
        _maxListeners: undefined,
        _writableState: [Object],
        writable: false,
        allowHalfOpen: false,
        destroyed: true,
        _bytesDispatched: 138,
        _sockname: null,
        _pendingData: null,
        _pendingEncoding: '',
        server: null,
        _server: null,
        parser: null,
        _httpMessage: [Object],
        read: [Function],
        _consuming: true,
        _idleNext: null,
        _idlePrev: null,
        _idleTimeout: -1 },
     connection: 
      Socket {
        connecting: false,
        _hadError: false,
        _handle: null,
        _parent: null,
        _host: null,
        _readableState: [Object],
        readable: false,
        domain: null,
        _events: [Object],
        _eventsCount: 8,
        _maxListeners: undefined,
        _writableState: [Object],
        writable: false,
        allowHalfOpen: false,
        destroyed: true,
        _bytesDispatched: 138,
        _sockname: null,
        _pendingData: null,
        _pendingEncoding: '',
        server: null,
        _server: null,
        parser: null,
        _httpMessage: [Object],
        read: [Function],
        _consuming: true,
        _idleNext: null,
        _idlePrev: null,
        _idleTimeout: -1 },
     httpVersionMajor: 1,
     httpVersionMinor: 1,
     httpVersion: '1.1',
     complete: true,
     headers: 
      { 'access-control-allow-origin': '*',
        'access-control-allow-credentials': 'true',
        'access-control-allow-methods': 'GET,PUT,POST,PATCH,DELETE',
        'access-control-allow-headers': 'Content-Type,Authorization,Accept,X-API-From,X-APPID,X-Component,X-FXER,x-api-from,x-appid,x-component,x-fxer',
        'content-type': 'application/json; charset=utf-8',
        'content-length': '38',
        date: 'Fri, 05 May 2017 06:53:45 GMT',
        connection: 'close' },
     rawHeaders: 
      [ 'Access-Control-Allow-Origin',
        '*',
        'Access-Control-Allow-Credentials',
        'true',
        'Access-Control-Allow-Methods',
        'GET,PUT,POST,PATCH,DELETE',
        'Access-Control-Allow-Headers',
        'Content-Type,Authorization,Accept,X-API-From,X-APPID,X-Component,X-FXER,x-api-from,x-appid,x-component,x-fxer',
        'Content-Type',
        'application/json; charset=utf-8',
        'Content-Length',
        '38',
        'Date',
        'Fri, 05 May 2017 06:53:45 GMT',
        'Connection',
        'close' ],
     trailers: {},
     rawTrailers: [],
     upgrade: false,
     url: '',
     method: null,
     statusCode: 200,
     statusMessage: 'OK',
     client: 
      Socket {
        connecting: false,
        _hadError: false,
        _handle: null,
        _parent: null,
        _host: null,
        _readableState: [Object],
        readable: false,
        domain: null,
        _events: [Object],
        _eventsCount: 8,
        _maxListeners: undefined,
        _writableState: [Object],
        writable: false,
        allowHalfOpen: false,
        destroyed: true,
        _bytesDispatched: 138,
        _sockname: null,
        _pendingData: null,
        _pendingEncoding: '',
        server: null,
        _server: null,
        parser: null,
        _httpMessage: [Object],
        read: [Function],
        _consuming: true,
        _idleNext: null,
        _idlePrev: null,
        _idleTimeout: -1 },
     _consuming: true,
     _dumped: false,
     req: 
      ClientRequest {
        domain: null,
        _events: [Object],
        _eventsCount: 4,
        _maxListeners: undefined,
        output: [],
        outputEncodings: [],
        outputCallbacks: [],
        outputSize: 0,
        writable: true,
        _last: true,
        upgrading: false,
        chunkedEncoding: false,
        shouldKeepAlive: false,
        useChunkedEncodingByDefault: false,
        sendDate: false,
        _removedHeader: {},
        _contentLength: 0,
        _hasBody: true,
        _trailer: '',
        finished: true,
        _headerSent: true,
        socket: [Object],
        connection: [Object],
        _header: 'GET /api/user/111 HTTP/1.1\r\nHost: 127.0.0.1:3000\r\nAccept-Encoding: gzip, deflate\r\nUser-Agent: node-superagent/1.8.5\r\nConnection: close\r\n\r\n',
        _headers: [Object],
        _headerNames: [Object],
        _onPendingData: null,
        agent: [Object],
        socketPath: undefined,
        timeout: undefined,
        method: 'GET',
        path: '/api/user/111',
        _ended: true,
        res: [Circular],
        aborted: undefined,
        timeoutCb: null,
        upgradeOrConnect: false,
        parser: null,
        maxHeadersCount: null },
     text: '{"username":"user0.38955004828614115"}',
     read: [Function],
     body: { username: 'user0.38955004828614115' } },
  request: 
   Test {
     domain: null,
     _events: { end: [Function: bound _clearTimeout] },
     _eventsCount: 1,
     _maxListeners: undefined,
     _agent: false,
     _formData: null,
     method: 'get',
     url: 'http://127.0.0.1:3000/api/user/111',
     _header: { 'user-agent': 'node-superagent/1.8.5' },
     header: { 'User-Agent': 'node-superagent/1.8.5' },
     writable: true,
     _redirects: 0,
     _maxRedirects: 0,
     cookies: '',
     qs: {},
     qsRaw: [],
     _redirectList: [],
     _streamRequest: false,
     _buffer: true,
     app: 
      Server {
        domain: null,
        _events: [Object],
        _eventsCount: 2,
        _maxListeners: undefined,
        _connections: 0,
        _handle: [Object],
        _usingSlaves: false,
        _slaves: [],
        _unref: false,
        allowHalfOpen: true,
        pauseOnConnect: false,
        httpAllowHalfOpen: false,
        timeout: 120000,
        _pendingResponseData: 0,
        maxHeadersCount: null,
        _connectionKey: '6::::3000' },
     _asserts: [ [Function: bound ] ],
     req: 
      ClientRequest {
        domain: null,
        _events: [Object],
        _eventsCount: 4,
        _maxListeners: undefined,
        output: [],
        outputEncodings: [],
        outputCallbacks: [],
        outputSize: 0,
        writable: true,
        _last: true,
        upgrading: false,
        chunkedEncoding: false,
        shouldKeepAlive: false,
        useChunkedEncodingByDefault: false,
        sendDate: false,
        _removedHeader: {},
        _contentLength: 0,
        _hasBody: true,
        _trailer: '',
        finished: true,
        _headerSent: true,
        socket: [Object],
        connection: [Object],
        _header: 'GET /api/user/111 HTTP/1.1\r\nHost: 127.0.0.1:3000\r\nAccept-Encoding: gzip, deflate\r\nUser-Agent: node-superagent/1.8.5\r\nConnection: close\r\n\r\n',
        _headers: [Object],
        _headerNames: [Object],
        _onPendingData: null,
        agent: [Object],
        socketPath: undefined,
        timeout: undefined,
        method: 'GET',
        path: '/api/user/111',
        _ended: true,
        res: [Object],
        aborted: undefined,
        timeoutCb: null,
        upgradeOrConnect: false,
        parser: null,
        maxHeadersCount: null },
     protocol: 'http:',
     host: '127.0.0.1:3000',
     _callback: [Function],
     res: 
      IncomingMessage {
        _readableState: [Object],
        readable: false,
        domain: null,
        _events: [Object],
        _eventsCount: 4,
        _maxListeners: undefined,
        socket: [Object],
        connection: [Object],
        httpVersionMajor: 1,
        httpVersionMinor: 1,
        httpVersion: '1.1',
        complete: true,
        headers: [Object],
        rawHeaders: [Object],
        trailers: {},
        rawTrailers: [],
        upgrade: false,
        url: '',
        method: null,
        statusCode: 200,
        statusMessage: 'OK',
        client: [Object],
        _consuming: true,
        _dumped: false,
        req: [Object],
        text: '{"username":"user0.38955004828614115"}',
        read: [Function],
        body: [Object] },
     response: [Circular],
     _timeout: 0,
     called: true },
  req: 
   ClientRequest {
     domain: null,
     _events: 
      { drain: [Function],
        error: [Function],
        response: [Function],
        prefinish: [Function: requestOnPrefinish] },
     _eventsCount: 4,
     _maxListeners: undefined,
     output: [],
     outputEncodings: [],
     outputCallbacks: [],
     outputSize: 0,
     writable: true,
     _last: true,
     upgrading: false,
     chunkedEncoding: false,
     shouldKeepAlive: false,
     useChunkedEncodingByDefault: false,
     sendDate: false,
     _removedHeader: {},
     _contentLength: 0,
     _hasBody: true,
     _trailer: '',
     finished: true,
     _headerSent: true,
     socket: 
      Socket {
        connecting: false,
        _hadError: false,
        _handle: null,
        _parent: null,
        _host: null,
        _readableState: [Object],
        readable: false,
        domain: null,
        _events: [Object],
        _eventsCount: 8,
        _maxListeners: undefined,
        _writableState: [Object],
        writable: false,
        allowHalfOpen: false,
        destroyed: true,
        _bytesDispatched: 138,
        _sockname: null,
        _pendingData: null,
        _pendingEncoding: '',
        server: null,
        _server: null,
        parser: null,
        _httpMessage: [Circular],
        read: [Function],
        _consuming: true,
        _idleNext: null,
        _idlePrev: null,
        _idleTimeout: -1 },
     connection: 
      Socket {
        connecting: false,
        _hadError: false,
        _handle: null,
        _parent: null,
        _host: null,
        _readableState: [Object],
        readable: false,
        domain: null,
        _events: [Object],
        _eventsCount: 8,
        _maxListeners: undefined,
        _writableState: [Object],
        writable: false,
        allowHalfOpen: false,
        destroyed: true,
        _bytesDispatched: 138,
        _sockname: null,
        _pendingData: null,
        _pendingEncoding: '',
        server: null,
        _server: null,
        parser: null,
        _httpMessage: [Circular],
        read: [Function],
        _consuming: true,
        _idleNext: null,
        _idlePrev: null,
        _idleTimeout: -1 },
     _header: 'GET /api/user/111 HTTP/1.1\r\nHost: 127.0.0.1:3000\r\nAccept-Encoding: gzip, deflate\r\nUser-Agent: node-superagent/1.8.5\r\nConnection: close\r\n\r\n',
     _headers: 
      { host: '127.0.0.1:3000',
        'accept-encoding': 'gzip, deflate',
        'user-agent': 'node-superagent/1.8.5' },
     _headerNames: 
      { host: 'Host',
        'accept-encoding': 'Accept-Encoding',
        'user-agent': 'User-Agent' },
     _onPendingData: null,
     agent: 
      Agent {
        domain: null,
        _events: [Object],
        _eventsCount: 1,
        _maxListeners: undefined,
        defaultPort: 80,
        protocol: 'http:',
        options: [Object],
        requests: {},
        sockets: [Object],
        freeSockets: {},
        keepAliveMsecs: 1000,
        keepAlive: false,
        maxSockets: Infinity,
        maxFreeSockets: 256 },
     socketPath: undefined,
     timeout: undefined,
     method: 'GET',
     path: '/api/user/111',
     _ended: true,
     res: 
      IncomingMessage {
        _readableState: [Object],
        readable: false,
        domain: null,
        _events: [Object],
        _eventsCount: 4,
        _maxListeners: undefined,
        socket: [Object],
        connection: [Object],
        httpVersionMajor: 1,
        httpVersionMinor: 1,
        httpVersion: '1.1',
        complete: true,
        headers: [Object],
        rawHeaders: [Object],
        trailers: {},
        rawTrailers: [],
        upgrade: false,
        url: '',
        method: null,
        statusCode: 200,
        statusMessage: 'OK',
        client: [Object],
        _consuming: true,
        _dumped: false,
        req: [Circular],
        text: '{"username":"user0.38955004828614115"}',
        read: [Function],
        body: [Object] },
     aborted: undefined,
     timeoutCb: null,
     upgradeOrConnect: false,
     parser: null,
     maxHeadersCount: null },
  links: {},
  text: '{"username":"user0.38955004828614115"}',
  body: { username: 'user0.38955004828614115' },
  files: {},
  buffered: true,
  headers: 
   { 'access-control-allow-origin': '*',
     'access-control-allow-credentials': 'true',
     'access-control-allow-methods': 'GET,PUT,POST,PATCH,DELETE',
     'access-control-allow-headers': 'Content-Type,Authorization,Accept,X-API-From,X-APPID,X-Component,X-FXER,x-api-from,x-appid,x-component,x-fxer',
     'content-type': 'application/json; charset=utf-8',
     'content-length': '38',
     date: 'Fri, 05 May 2017 06:53:45 GMT',
     connection: 'close' },
  header: 
   { 'access-control-allow-origin': '*',
     'access-control-allow-credentials': 'true',
     'access-control-allow-methods': 'GET,PUT,POST,PATCH,DELETE',
     'access-control-allow-headers': 'Content-Type,Authorization,Accept,X-API-From,X-APPID,X-Component,X-FXER,x-api-from,x-appid,x-component,x-fxer',
     'content-type': 'application/json; charset=utf-8',
     'content-length': '38',
     date: 'Fri, 05 May 2017 06:53:45 GMT',
     connection: 'close' },
  statusCode: 200,
  status: 200,
  statusType: 2,
  info: false,
  ok: true,
  redirect: false,
  clientError: false,
  serverError: false,
  error: false,
  accepted: false,
  noContent: false,
  badRequest: false,
  unauthorized: false,
  notAcceptable: false,
  forbidden: false,
  notFound: false,
  charset: 'utf-8',
  type: 'application/json',
  setEncoding: [Function: bound ],
  redirects: [] }
[2017-05-05 14:53:50.657] [INFO] console -   [31m  1) should return 200[0m
[2017-05-05 14:53:50.663] [INFO] console - 
[2017-05-05 14:53:50.664] [INFO] console - 
[2017-05-05 14:53:56.423] [WARN] console - ********** { subdomainOffset: 2, proxy: true, env: 'development' }
[2017-05-05 14:53:56.429] [INFO] console - 
[2017-05-05 14:53:56.430] [INFO] console - [0m[0m
[2017-05-05 14:53:56.443] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:53:56.446] [INFO] console - [0m  Example Node Server[0m
[2017-05-05 14:53:56.455] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:53:56.457] [INFO] app - Redis client default is ready {}
[2017-05-05 14:53:56.481] [DEBUG] app - 2017-5-5 14:53:56 ::ffff:127.0.0.1 -- GET /api/user/111 HTTP/1.1, null node-superagent/1.8.5
[2017-05-05 14:53:56.484] [WARN] console - this is a logger middleware.
[2017-05-05 14:53:56.514] [INFO] console -   [32m  [0m[90m should return 200[0m[33m (52ms)[0m
[2017-05-05 14:53:56.518] [INFO] console - 
[2017-05-05 14:53:56.520] [INFO] console - 
[2017-05-05 14:54:56.003] [INFO] console - 
[2017-05-05 14:54:56.006] [INFO] console - [0m[0m
[2017-05-05 14:54:56.022] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:54:56.026] [INFO] console - [0m  GET /api/user[0m
[2017-05-05 14:54:56.038] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:54:56.040] [INFO] app - Redis client default is ready {}
[2017-05-05 14:54:56.059] [DEBUG] app - 2017-5-5 14:54:56 ::ffff:127.0.0.1 -- GET /api/user/111 HTTP/1.1, null node-superagent/1.8.5
[2017-05-05 14:54:56.063] [WARN] console - this is a logger middleware.
[2017-05-05 14:54:56.093] [INFO] console -   [32m  [0m[90m should return 200[0m[33m (48ms)[0m
[2017-05-05 14:54:56.095] [INFO] console - 
[2017-05-05 14:54:56.096] [INFO] console - 
[2017-05-05 14:56:24.149] [INFO] console - 
[2017-05-05 14:56:24.153] [INFO] console - [0m[0m
[2017-05-05 14:56:24.169] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:56:24.174] [INFO] console - [0m  GET /api/user[0m
[2017-05-05 14:56:24.181] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:56:24.183] [INFO] app - Redis client default is ready {}
[2017-05-05 14:56:24.202] [DEBUG] app - 2017-5-5 14:56:24 ::ffff:127.0.0.1 -- GET /api/user/111 HTTP/1.1, null node-superagent/1.8.5
[2017-05-05 14:56:24.206] [WARN] console - this is a logger middleware.
[2017-05-05 14:56:24.239] [INFO] console -   [32m  [0m[90m should return 200[0m[33m (52ms)[0m
[2017-05-05 14:56:24.242] [INFO] console - 
[2017-05-05 14:56:24.244] [INFO] console - 
[2017-05-05 14:56:30.473] [INFO] console - 
[2017-05-05 14:56:30.475] [INFO] console - [0m[0m
[2017-05-05 14:56:30.499] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 14:56:30.502] [INFO] console - [0m  GET /api/user[0m
[2017-05-05 14:56:30.509] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 14:56:30.511] [INFO] app - Redis client default is ready {}
[2017-05-05 14:56:30.530] [DEBUG] app - 2017-5-5 14:56:30 ::ffff:127.0.0.1 -- GET /api/user/111 HTTP/1.1, null node-superagent/1.8.5
[2017-05-05 14:56:30.534] [WARN] console - this is a logger middleware.
[2017-05-05 14:56:30.566] [INFO] console -   [31m  1) should return 200[0m
[2017-05-05 14:56:30.569] [INFO] console - 
[2017-05-05 14:56:30.570] [INFO] console - 
[2017-05-05 15:00:58.170] [INFO] console - 
[2017-05-05 15:00:58.174] [INFO] console - [0m[0m
[2017-05-05 15:00:58.194] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 15:00:58.244] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 15:00:58.247] [INFO] console - [0m  UserService[0m
[2017-05-05 15:00:58.248] [INFO] app - Redis client default is ready {}
[2017-05-05 15:00:58.265] [INFO] console -   [31m  1) #getUser[0m
[2017-05-05 15:00:58.268] [INFO] console - 
[2017-05-05 15:00:58.269] [INFO] console - 
[2017-05-05 15:01:10.755] [INFO] console - 
[2017-05-05 15:01:10.758] [INFO] console - [0m[0m
[2017-05-05 15:01:10.774] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 15:01:10.819] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 15:01:10.821] [INFO] console - [0m  UserService[0m
[2017-05-05 15:01:10.822] [INFO] app - Redis client default is ready {}
[2017-05-05 15:01:10.850] [INFO] console -   [31m  1) #getUser[0m
[2017-05-05 15:01:10.853] [INFO] console - 
[2017-05-05 15:01:10.854] [INFO] console - 
[2017-05-05 15:01:29.329] [INFO] console - 
[2017-05-05 15:01:29.333] [INFO] console - [0m[0m
[2017-05-05 15:01:29.350] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 15:01:29.387] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 15:01:29.390] [INFO] console - [0m  UserService[0m
[2017-05-05 15:01:29.391] [INFO] app - Redis client default is ready {}
[2017-05-05 15:01:29.415] [INFO] console -   [31m  1) #getUser[0m
[2017-05-05 15:01:29.419] [INFO] console - 
[2017-05-05 15:01:29.420] [INFO] console - 
[2017-05-05 15:02:02.076] [INFO] console - 
[2017-05-05 15:02:02.079] [INFO] console - [0m[0m
[2017-05-05 15:02:02.097] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 15:02:02.159] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 15:02:02.161] [INFO] console - [0m  UserService[0m
[2017-05-05 15:02:02.163] [INFO] app - Redis client default is ready {}
[2017-05-05 15:02:02.190] [INFO] console -   [31m  1) #getUser[0m
[2017-05-05 15:02:02.192] [INFO] console - 
[2017-05-05 15:02:02.194] [INFO] console - 
[2017-05-05 15:02:24.753] [INFO] console - 
[2017-05-05 15:02:24.756] [INFO] console - [0m[0m
[2017-05-05 15:02:24.770] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 15:02:24.817] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 15:02:24.819] [INFO] console - [0m  UserService[0m
[2017-05-05 15:02:24.821] [INFO] app - Redis client default is ready {}
[2017-05-05 15:02:24.842] [WARN] console - { AssertionError: expected [ Array(3) ] to equal 3
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/test/modules/user/services/UserService.js:14:36)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/test/modules/user/services/UserService.js:13:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/test/modules/user/services/UserService.js:13:361
    at process._tickCallback (internal/process/next_tick.js:109:7)
  message: 'expected [ Array(3) ] to equal 3',
  showDiff: true,
  actual: 
   [ { username: '222', id: '5902b753c5756d72945d90b3' },
     { username: 'user0.38955004828614115',
       id: '590467fb9bb491da74caee32' },
     { username: 'user0.9823151939002306',
       id: '5904689fb4b502db0a450395' } ],
  expected: 3 }
[2017-05-05 15:02:24.850] [INFO] console -   [31m  1) #getUser[0m
[2017-05-05 15:02:24.854] [INFO] console - 
[2017-05-05 15:02:24.855] [INFO] console - 
[2017-05-05 15:03:08.629] [INFO] console - 
[2017-05-05 15:03:08.632] [INFO] console - [0m[0m
[2017-05-05 15:03:08.648] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 15:03:08.702] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 15:03:08.704] [INFO] console - [0m  UserService[0m
[2017-05-05 15:03:08.706] [INFO] app - Redis client default is ready {}
[2017-05-05 15:03:08.724] [INFO] console -   [32m  [0m[90m #getUser[0m
[2017-05-05 15:03:08.727] [INFO] console - 
[2017-05-05 15:03:08.729] [INFO] console - 
[2017-05-05 15:05:21.155] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 15:05:21.166] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 15:05:21.169] [INFO] app - Redis client default is ready {}
[2017-05-05 15:05:21.173] [INFO] app - application is startup, listening on port 3000
[2017-05-05 15:05:27.506] [DEBUG] app - 2017-5-5 15:05:27 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 15:05:27.510] [WARN] console - this is a logger middleware.
[2017-05-05 15:05:28.276] [DEBUG] app - 2017-5-5 15:05:28 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 15:05:28.276] [WARN] console - this is a logger middleware.
[2017-05-05 15:05:30.691] [DEBUG] app - 2017-5-5 15:05:30 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 15:05:30.691] [WARN] console - this is a logger middleware.
[2017-05-05 15:05:30.843] [DEBUG] app - 2017-5-5 15:05:30 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 15:05:30.844] [WARN] console - this is a logger middleware.
[2017-05-05 15:05:30.989] [DEBUG] app - 2017-5-5 15:05:30 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 15:05:30.989] [WARN] console - this is a logger middleware.
[2017-05-05 15:05:31.141] [DEBUG] app - 2017-5-5 15:05:31 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 15:05:31.143] [WARN] console - this is a logger middleware.
[2017-05-05 15:05:31.274] [DEBUG] app - 2017-5-5 15:05:31 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 15:05:31.274] [WARN] console - this is a logger middleware.
[2017-05-05 15:05:31.384] [DEBUG] app - 2017-5-5 15:05:31 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 15:05:31.384] [WARN] console - this is a logger middleware.
[2017-05-05 15:05:31.506] [DEBUG] app - 2017-5-5 15:05:31 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 15:05:31.507] [WARN] console - this is a logger middleware.
[2017-05-05 15:05:51.926] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 15:05:51.935] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-05 15:05:51.938] [INFO] app - Redis client default is ready {}
[2017-05-05 15:05:51.941] [INFO] app - application is startup, listening on port 3000
[2017-05-05 15:21:11.122] [WARN] console - [Function]
[2017-05-05 15:21:11.504] [INFO] app - application is startup, listening on port 3000
[2017-05-05 15:21:11.506] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 15:21:11.509] [INFO] app - Redis client default is ready {}
[2017-05-05 15:21:31.144] [WARN] console - [Function]
[2017-05-05 15:21:31.148] [WARN] console - [Function]
[2017-05-05 15:21:31.419] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 15:21:31.429] [INFO] app - Redis client default is ready {}
[2017-05-05 15:21:31.433] [INFO] app - application is startup, listening on port 3000
[2017-05-05 15:22:25.400] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 15:22:25.407] [INFO] app - Redis client default is ready {}
[2017-05-05 15:22:25.414] [INFO] app - application is startup, listening on port 3000
[2017-05-05 15:22:49.543] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 15:22:49.560] [INFO] app - Redis client default is ready {}
[2017-05-05 15:22:49.564] [INFO] app - application is startup, listening on port 3000
[2017-05-05 15:25:52.287] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 15:25:52.383] [INFO] app - Redis client default is ready {}
[2017-05-05 15:25:52.395] [WARN] console - [31mUnhandled rejection SequelizeBaseError: ER_ACCESS_DENIED_ERROR: Access denied for user ''@'localhost' (using password: NO)
    at Handshake._callback (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/connection-manager.js:83:20)
    at Handshake.Sequence.end (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:86:24)
    at Handshake.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Handshake.js:105:8)
    at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
    at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
    at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
    at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
    at emitOne (events.js:96:13)
    at Socket.emit (events.js:191:7)
    at readableAddChunk (_stream_readable.js:178:18)
    at Socket.Readable.push (_stream_readable.js:136:10)
    at TCP.onread (net.js:560:20)[0m

[2017-05-05 15:47:57.778] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 15:47:57.828] [INFO] app - Redis client default is ready {}
[2017-05-05 15:47:57.837] [WARN] console - [31mUnhandled rejection SequelizeBaseError: ER_ACCESS_DENIED_ERROR: Access denied for user ''@'localhost' (using password: NO)
    at Handshake._callback (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/connection-manager.js:83:20)
    at Handshake.Sequence.end (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:86:24)
    at Handshake.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Handshake.js:105:8)
    at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
    at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
    at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
    at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
    at emitOne (events.js:96:13)
    at Socket.emit (events.js:191:7)
    at readableAddChunk (_stream_readable.js:178:18)
    at Socket.Readable.push (_stream_readable.js:136:10)
    at TCP.onread (net.js:560:20)[0m

[2017-05-05 15:48:15.440] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 15:48:15.519] [INFO] app - Redis client default is ready {}
[2017-05-05 15:48:15.528] [WARN] console - [31mUnhandled rejection SequelizeBaseError: ER_ACCESS_DENIED_ERROR: Access denied for user ''@'localhost' (using password: YES)
    at Handshake._callback (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/connection-manager.js:83:20)
    at Handshake.Sequence.end (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:86:24)
    at Handshake.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Handshake.js:105:8)
    at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
    at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
    at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
    at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
    at emitOne (events.js:96:13)
    at Socket.emit (events.js:191:7)
    at readableAddChunk (_stream_readable.js:178:18)
    at Socket.Readable.push (_stream_readable.js:136:10)
    at TCP.onread (net.js:560:20)[0m

[2017-05-05 15:49:44.296] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 15:49:44.354] [INFO] app - Redis client default is ready {}
[2017-05-05 15:49:44.366] [WARN] console - [31mUnhandled rejection SequelizeBaseError: ER_BAD_DB_ERROR: Unknown database 'wenode'
    at Handshake._callback (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/connection-manager.js:95:20)
    at Handshake.Sequence.end (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:86:24)
    at Handshake.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Handshake.js:105:8)
    at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
    at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
    at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
    at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
    at emitOne (events.js:96:13)
    at Socket.emit (events.js:191:7)
    at readableAddChunk (_stream_readable.js:178:18)
    at Socket.Readable.push (_stream_readable.js:136:10)
    at TCP.onread (net.js:560:20)[0m

[2017-05-05 15:52:07.774] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 15:52:07.885] [INFO] app - Redis client default is ready {}
[2017-05-05 15:52:07.904] [WARN] console - [31mUnhandled rejection SequelizeBaseError: ER_BAD_DB_ERROR: Unknown database 'wenode'
    at Handshake._callback (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/connection-manager.js:95:20)
    at Handshake.Sequence.end (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:86:24)
    at Handshake.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Handshake.js:105:8)
    at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
    at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
    at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
    at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
    at emitOne (events.js:96:13)
    at Socket.emit (events.js:191:7)
    at readableAddChunk (_stream_readable.js:178:18)
    at Socket.Readable.push (_stream_readable.js:136:10)
    at TCP.onread (net.js:560:20)[0m

[2017-05-05 15:55:38.518] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 15:55:38.609] [INFO] app - Redis client default is ready {}
[2017-05-05 15:55:38.631] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 15:55:38.636] [INFO] app - application is startup, listening on port 3000
[2017-05-05 16:01:11.045] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 16:01:11.115] [INFO] app - Redis client default is ready {}
[2017-05-05 16:01:11.159] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 16:01:11.166] [INFO] app - application is startup, listening on port 3000
[2017-05-05 16:01:18.282] [DEBUG] app - 2017-5-5 16:01:18 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 16:01:18.289] [WARN] console - this is a logger middleware.
[2017-05-05 16:01:18.290] [WARN] console - user
[2017-05-05 16:01:18.293] [ERROR] app - TypeError: Cannot read property '1' of undefined
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:7:21)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:361
    at process._tickDomainCallback (internal/process/next_tick.js:135:7)
[2017-05-05 16:01:18.307] [ERROR] console - (node:27660) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): AssertionError: status code must be a number
[2017-05-05 16:01:18.308] [ERROR] console - (node:27660) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
[2017-05-05 16:01:38.541] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 16:01:38.606] [INFO] app - Redis client default is ready {}
[2017-05-05 16:01:38.629] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 16:01:38.635] [INFO] app - application is startup, listening on port 3000
[2017-05-05 16:01:41.381] [DEBUG] app - 2017-5-5 16:01:41 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 16:01:41.385] [WARN] console - this is a logger middleware.
[2017-05-05 16:01:41.386] [WARN] console - object
[2017-05-05 16:01:41.388] [ERROR] app - TypeError: Cannot read property '1' of undefined
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:7:21)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:361
    at process._tickDomainCallback (internal/process/next_tick.js:135:7)
[2017-05-05 16:01:41.403] [ERROR] console - (node:27703) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): AssertionError: status code must be a number
[2017-05-05 16:01:41.404] [ERROR] console - (node:27703) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
[2017-05-05 16:01:41.546] [DEBUG] app - 2017-5-5 16:01:41 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 16:01:41.547] [WARN] console - this is a logger middleware.
[2017-05-05 16:01:41.548] [WARN] console - object
[2017-05-05 16:01:41.548] [ERROR] app - TypeError: Cannot read property '1' of undefined
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:7:21)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:361
    at process._tickDomainCallback (internal/process/next_tick.js:135:7)
[2017-05-05 16:01:41.550] [ERROR] console - (node:27703) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 2): AssertionError: status code must be a number
[2017-05-05 16:02:16.788] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 16:02:16.857] [INFO] app - Redis client default is ready {}
[2017-05-05 16:02:16.888] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 16:02:16.894] [INFO] app - application is startup, listening on port 3000
[2017-05-05 16:02:21.685] [DEBUG] app - 2017-5-5 16:02:21 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 16:02:21.692] [WARN] console - this is a logger middleware.
[2017-05-05 16:02:21.699] [INFO] console - Executing (default): SELECT `id`, `first_name` AS `firstName`, `lastName`, `createdAt`, `updatedAt` FROM `user` AS `user` LIMIT 1;
[2017-05-05 16:02:21.710] [ERROR] app - { SequelizeBaseError: ER_NO_SUCH_TABLE: Table 'wenode.user' doesn't exist
    at Query.formatError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:175:14)
    at Query._callback (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:49:21)
    at Query.Sequence.end (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:86:24)
    at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:88:8)
    at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
    at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
    at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
    at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
    at emitOne (events.js:96:13)
    at Socket.emit (events.js:191:7)
    at readableAddChunk (_stream_readable.js:178:18)
    at Socket.Readable.push (_stream_readable.js:136:10)
    at TCP.onread (net.js:560:20)
  name: 'SequelizeDatabaseError',
  message: 'ER_NO_SUCH_TABLE: Table \'wenode.user\' doesn\'t exist',
  parent: 
   { Error: ER_NO_SUCH_TABLE: Table 'wenode.user' doesn't exist
       at Query.Sequence._packetToError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:52:14)
       at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:77:18)
       at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
       at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
       at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
       at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
       at emitOne (events.js:96:13)
       at Socket.emit (events.js:191:7)
       at readableAddChunk (_stream_readable.js:178:18)
       at Socket.Readable.push (_stream_readable.js:136:10)
       at TCP.onread (net.js:560:20)
       --------------------
       at Protocol._enqueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:141:48)
       at Connection.query (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:208:25)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at Query.run (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:39:17)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:849:20
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at retryAsPromised (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:30:10)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:848:12
       at tryCatcher (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/util.js:16:23)
       at Promise._settlePromiseFromHandler (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:512:31)
       at Promise._settlePromise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:569:18)
       at Promise._settlePromise0 (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:614:10)
       at Promise._settlePromises (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:693:18)
       at Async._drainQueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:133:16)
       at Async._drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:143:10)
       at Immediate.Async.drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:17:14)
     code: 'ER_NO_SUCH_TABLE',
     errno: 1146,
     sqlState: '42S02',
     index: 0,
     sql: 'SELECT `id`, `first_name` AS `firstName`, `lastName`, `createdAt`, `updatedAt` FROM `user` AS `user` LIMIT 1;' },
  original: 
   { Error: ER_NO_SUCH_TABLE: Table 'wenode.user' doesn't exist
       at Query.Sequence._packetToError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:52:14)
       at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:77:18)
       at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
       at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
       at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
       at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
       at emitOne (events.js:96:13)
       at Socket.emit (events.js:191:7)
       at readableAddChunk (_stream_readable.js:178:18)
       at Socket.Readable.push (_stream_readable.js:136:10)
       at TCP.onread (net.js:560:20)
       --------------------
       at Protocol._enqueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:141:48)
       at Connection.query (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:208:25)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at Query.run (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:39:17)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:849:20
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at retryAsPromised (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:30:10)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:848:12
       at tryCatcher (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/util.js:16:23)
       at Promise._settlePromiseFromHandler (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:512:31)
       at Promise._settlePromise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:569:18)
       at Promise._settlePromise0 (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:614:10)
       at Promise._settlePromises (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:693:18)
       at Async._drainQueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:133:16)
       at Async._drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:143:10)
       at Immediate.Async.drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:17:14)
     code: 'ER_NO_SUCH_TABLE',
     errno: 1146,
     sqlState: '42S02',
     index: 0,
     sql: 'SELECT `id`, `first_name` AS `firstName`, `lastName`, `createdAt`, `updatedAt` FROM `user` AS `user` LIMIT 1;' },
  sql: 'SELECT `id`, `first_name` AS `firstName`, `lastName`, `createdAt`, `updatedAt` FROM `user` AS `user` LIMIT 1;' }
[2017-05-05 16:02:21.724] [ERROR] console - (node:27731) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): AssertionError: status code must be a number
[2017-05-05 16:02:21.724] [ERROR] console - (node:27731) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
[2017-05-05 16:05:17.749] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 16:05:17.816] [INFO] app - Redis client default is ready {}
[2017-05-05 16:05:17.833] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 16:05:17.837] [INFO] app - application is startup, listening on port 3000
[2017-05-05 16:05:20.337] [DEBUG] app - 2017-5-5 16:05:20 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 16:05:20.343] [WARN] console - this is a logger middleware.
[2017-05-05 16:05:20.349] [INFO] console - Executing (default): SELECT `id`, `first_name` AS `firstName`, `lastName`, `createdAt`, `updatedAt` FROM `user` AS `user` LIMIT 1;
[2017-05-05 16:05:20.363] [ERROR] app - { SequelizeBaseError: ER_BAD_FIELD_ERROR: Unknown column 'id' in 'field list'
    at Query.formatError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:175:14)
    at Query._callback (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:49:21)
    at Query.Sequence.end (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:86:24)
    at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:88:8)
    at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
    at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
    at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
    at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
    at emitOne (events.js:96:13)
    at Socket.emit (events.js:191:7)
    at readableAddChunk (_stream_readable.js:178:18)
    at Socket.Readable.push (_stream_readable.js:136:10)
    at TCP.onread (net.js:560:20)
  name: 'SequelizeDatabaseError',
  message: 'ER_BAD_FIELD_ERROR: Unknown column \'id\' in \'field list\'',
  parent: 
   { Error: ER_BAD_FIELD_ERROR: Unknown column 'id' in 'field list'
       at Query.Sequence._packetToError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:52:14)
       at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:77:18)
       at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
       at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
       at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
       at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
       at emitOne (events.js:96:13)
       at Socket.emit (events.js:191:7)
       at readableAddChunk (_stream_readable.js:178:18)
       at Socket.Readable.push (_stream_readable.js:136:10)
       at TCP.onread (net.js:560:20)
       --------------------
       at Protocol._enqueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:141:48)
       at Connection.query (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:208:25)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at Query.run (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:39:17)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:849:20
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at retryAsPromised (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:30:10)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:848:12
       at tryCatcher (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/util.js:16:23)
       at Promise._settlePromiseFromHandler (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:512:31)
       at Promise._settlePromise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:569:18)
       at Promise._settlePromise0 (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:614:10)
       at Promise._settlePromises (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:693:18)
       at Async._drainQueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:133:16)
       at Async._drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:143:10)
       at Immediate.Async.drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:17:14)
     code: 'ER_BAD_FIELD_ERROR',
     errno: 1054,
     sqlState: '42S22',
     index: 0,
     sql: 'SELECT `id`, `first_name` AS `firstName`, `lastName`, `createdAt`, `updatedAt` FROM `user` AS `user` LIMIT 1;' },
  original: 
   { Error: ER_BAD_FIELD_ERROR: Unknown column 'id' in 'field list'
       at Query.Sequence._packetToError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:52:14)
       at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:77:18)
       at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
       at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
       at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
       at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
       at emitOne (events.js:96:13)
       at Socket.emit (events.js:191:7)
       at readableAddChunk (_stream_readable.js:178:18)
       at Socket.Readable.push (_stream_readable.js:136:10)
       at TCP.onread (net.js:560:20)
       --------------------
       at Protocol._enqueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:141:48)
       at Connection.query (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:208:25)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at Query.run (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:39:17)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:849:20
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at retryAsPromised (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:30:10)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:848:12
       at tryCatcher (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/util.js:16:23)
       at Promise._settlePromiseFromHandler (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:512:31)
       at Promise._settlePromise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:569:18)
       at Promise._settlePromise0 (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:614:10)
       at Promise._settlePromises (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:693:18)
       at Async._drainQueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:133:16)
       at Async._drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:143:10)
       at Immediate.Async.drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:17:14)
     code: 'ER_BAD_FIELD_ERROR',
     errno: 1054,
     sqlState: '42S22',
     index: 0,
     sql: 'SELECT `id`, `first_name` AS `firstName`, `lastName`, `createdAt`, `updatedAt` FROM `user` AS `user` LIMIT 1;' },
  sql: 'SELECT `id`, `first_name` AS `firstName`, `lastName`, `createdAt`, `updatedAt` FROM `user` AS `user` LIMIT 1;' }
[2017-05-05 16:05:20.378] [ERROR] console - (node:27782) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): AssertionError: status code must be a number
[2017-05-05 16:05:20.378] [ERROR] console - (node:27782) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
[2017-05-05 16:06:04.328] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 16:06:04.400] [INFO] app - Redis client default is ready {}
[2017-05-05 16:06:04.438] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 16:06:04.445] [INFO] app - application is startup, listening on port 3000
[2017-05-05 16:07:16.194] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 16:07:16.277] [INFO] app - Redis client default is ready {}
[2017-05-05 16:07:16.315] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 16:07:16.323] [INFO] app - application is startup, listening on port 3000
[2017-05-05 16:07:23.550] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 16:07:23.624] [INFO] app - Redis client default is ready {}
[2017-05-05 16:07:23.653] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 16:07:23.661] [INFO] app - application is startup, listening on port 3000
[2017-05-05 16:07:27.319] [DEBUG] app - 2017-5-5 16:07:27 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 16:07:27.323] [WARN] console - this is a logger middleware.
[2017-05-05 16:07:27.330] [INFO] console - Executing (default): SELECT `id`, `first_name` AS `firstName`, `user_id` AS `userId`, `createdAt`, `updatedAt` FROM `user` AS `user` LIMIT 1;
[2017-05-05 16:07:27.339] [ERROR] app - { SequelizeBaseError: ER_BAD_FIELD_ERROR: Unknown column 'id' in 'field list'
    at Query.formatError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:175:14)
    at Query._callback (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:49:21)
    at Query.Sequence.end (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:86:24)
    at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:88:8)
    at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
    at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
    at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
    at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
    at emitOne (events.js:96:13)
    at Socket.emit (events.js:191:7)
    at readableAddChunk (_stream_readable.js:178:18)
    at Socket.Readable.push (_stream_readable.js:136:10)
    at TCP.onread (net.js:560:20)
  name: 'SequelizeDatabaseError',
  message: 'ER_BAD_FIELD_ERROR: Unknown column \'id\' in \'field list\'',
  parent: 
   { Error: ER_BAD_FIELD_ERROR: Unknown column 'id' in 'field list'
       at Query.Sequence._packetToError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:52:14)
       at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:77:18)
       at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
       at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
       at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
       at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
       at emitOne (events.js:96:13)
       at Socket.emit (events.js:191:7)
       at readableAddChunk (_stream_readable.js:178:18)
       at Socket.Readable.push (_stream_readable.js:136:10)
       at TCP.onread (net.js:560:20)
       --------------------
       at Protocol._enqueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:141:48)
       at Connection.query (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:208:25)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at Query.run (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:39:17)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:849:20
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at retryAsPromised (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:30:10)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:848:12
       at tryCatcher (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/util.js:16:23)
       at Promise._settlePromiseFromHandler (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:512:31)
       at Promise._settlePromise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:569:18)
       at Promise._settlePromise0 (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:614:10)
       at Promise._settlePromises (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:693:18)
       at Async._drainQueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:133:16)
       at Async._drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:143:10)
       at Immediate.Async.drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:17:14)
     code: 'ER_BAD_FIELD_ERROR',
     errno: 1054,
     sqlState: '42S22',
     index: 0,
     sql: 'SELECT `id`, `first_name` AS `firstName`, `user_id` AS `userId`, `createdAt`, `updatedAt` FROM `user` AS `user` LIMIT 1;' },
  original: 
   { Error: ER_BAD_FIELD_ERROR: Unknown column 'id' in 'field list'
       at Query.Sequence._packetToError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:52:14)
       at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:77:18)
       at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
       at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
       at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
       at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
       at emitOne (events.js:96:13)
       at Socket.emit (events.js:191:7)
       at readableAddChunk (_stream_readable.js:178:18)
       at Socket.Readable.push (_stream_readable.js:136:10)
       at TCP.onread (net.js:560:20)
       --------------------
       at Protocol._enqueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:141:48)
       at Connection.query (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:208:25)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at Query.run (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:39:17)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:849:20
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at retryAsPromised (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:30:10)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:848:12
       at tryCatcher (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/util.js:16:23)
       at Promise._settlePromiseFromHandler (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:512:31)
       at Promise._settlePromise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:569:18)
       at Promise._settlePromise0 (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:614:10)
       at Promise._settlePromises (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:693:18)
       at Async._drainQueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:133:16)
       at Async._drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:143:10)
       at Immediate.Async.drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:17:14)
     code: 'ER_BAD_FIELD_ERROR',
     errno: 1054,
     sqlState: '42S22',
     index: 0,
     sql: 'SELECT `id`, `first_name` AS `firstName`, `user_id` AS `userId`, `createdAt`, `updatedAt` FROM `user` AS `user` LIMIT 1;' },
  sql: 'SELECT `id`, `first_name` AS `firstName`, `user_id` AS `userId`, `createdAt`, `updatedAt` FROM `user` AS `user` LIMIT 1;' }
[2017-05-05 16:07:27.354] [ERROR] console - (node:27919) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): AssertionError: status code must be a number
[2017-05-05 16:07:27.354] [ERROR] console - (node:27919) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
[2017-05-05 16:09:27.329] [DEBUG] app - 2017-5-5 16:09:27 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 16:09:27.330] [WARN] console - this is a logger middleware.
[2017-05-05 16:09:27.335] [INFO] console - Executing (default): SELECT `id`, `first_name` AS `firstName`, `user_id` AS `userId`, `createdAt`, `updatedAt` FROM `user` AS `user` LIMIT 1;
[2017-05-05 16:09:27.340] [ERROR] app - { SequelizeBaseError: ER_BAD_FIELD_ERROR: Unknown column 'id' in 'field list'
    at Query.formatError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:175:14)
    at Query._callback (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:49:21)
    at Query.Sequence.end (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:86:24)
    at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:88:8)
    at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
    at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
    at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
    at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
    at emitOne (events.js:96:13)
    at Socket.emit (events.js:191:7)
    at readableAddChunk (_stream_readable.js:178:18)
    at Socket.Readable.push (_stream_readable.js:136:10)
    at TCP.onread (net.js:560:20)
  name: 'SequelizeDatabaseError',
  message: 'ER_BAD_FIELD_ERROR: Unknown column \'id\' in \'field list\'',
  parent: 
   { Error: ER_BAD_FIELD_ERROR: Unknown column 'id' in 'field list'
       at Query.Sequence._packetToError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:52:14)
       at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:77:18)
       at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
       at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
       at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
       at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
       at emitOne (events.js:96:13)
       at Socket.emit (events.js:191:7)
       at readableAddChunk (_stream_readable.js:178:18)
       at Socket.Readable.push (_stream_readable.js:136:10)
       at TCP.onread (net.js:560:20)
       --------------------
       at Protocol._enqueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:141:48)
       at Connection.query (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:208:25)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at Query.run (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:39:17)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:849:20
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at retryAsPromised (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:30:10)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:848:12
       at tryCatcher (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/util.js:16:23)
       at Promise._settlePromiseFromHandler (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:512:31)
       at Promise._settlePromise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:569:18)
       at Promise._settlePromise0 (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:614:10)
       at Promise._settlePromises (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:693:18)
       at Async._drainQueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:133:16)
       at Async._drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:143:10)
       at Immediate.Async.drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:17:14)
     code: 'ER_BAD_FIELD_ERROR',
     errno: 1054,
     sqlState: '42S22',
     index: 0,
     sql: 'SELECT `id`, `first_name` AS `firstName`, `user_id` AS `userId`, `createdAt`, `updatedAt` FROM `user` AS `user` LIMIT 1;' },
  original: 
   { Error: ER_BAD_FIELD_ERROR: Unknown column 'id' in 'field list'
       at Query.Sequence._packetToError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:52:14)
       at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:77:18)
       at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
       at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
       at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
       at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
       at emitOne (events.js:96:13)
       at Socket.emit (events.js:191:7)
       at readableAddChunk (_stream_readable.js:178:18)
       at Socket.Readable.push (_stream_readable.js:136:10)
       at TCP.onread (net.js:560:20)
       --------------------
       at Protocol._enqueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:141:48)
       at Connection.query (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:208:25)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at Query.run (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:39:17)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:849:20
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at retryAsPromised (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:30:10)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:848:12
       at tryCatcher (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/util.js:16:23)
       at Promise._settlePromiseFromHandler (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:512:31)
       at Promise._settlePromise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:569:18)
       at Promise._settlePromise0 (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:614:10)
       at Promise._settlePromises (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:693:18)
       at Async._drainQueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:133:16)
       at Async._drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:143:10)
       at Immediate.Async.drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:17:14)
     code: 'ER_BAD_FIELD_ERROR',
     errno: 1054,
     sqlState: '42S22',
     index: 0,
     sql: 'SELECT `id`, `first_name` AS `firstName`, `user_id` AS `userId`, `createdAt`, `updatedAt` FROM `user` AS `user` LIMIT 1;' },
  sql: 'SELECT `id`, `first_name` AS `firstName`, `user_id` AS `userId`, `createdAt`, `updatedAt` FROM `user` AS `user` LIMIT 1;' }
[2017-05-05 16:09:27.342] [ERROR] console - (node:27919) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 2): AssertionError: status code must be a number
[2017-05-05 16:11:10.463] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 16:11:10.544] [INFO] app - Redis client default is ready {}
[2017-05-05 16:11:10.566] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 16:11:10.573] [INFO] app - application is startup, listening on port 3000
[2017-05-05 16:11:13.507] [DEBUG] app - 2017-5-5 16:11:13 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 16:11:13.512] [WARN] console - this is a logger middleware.
[2017-05-05 16:11:13.520] [INFO] console - Executing (default): DROP TABLE IF EXISTS `user`;
[2017-05-05 16:11:13.530] [INFO] console - Executing (default): CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB;
[2017-05-05 16:11:13.553] [INFO] console - Executing (default): SHOW INDEX FROM `user`
[2017-05-05 16:11:13.557] [ERROR] app - TypeError: Cannot read property 'id' of undefined
    at UserKv._callee2$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:24:16)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:15:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:15:437
    at UserKv.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:15:99)
    at UserKv.save (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:106:22)
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:8:34)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:361
[2017-05-05 16:11:13.571] [ERROR] app - TypeError: Cannot read property 'id' of undefined
    at UserKv._callee2$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:24:16)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:15:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:15:437
    at UserKv.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:15:99)
    at UserKv.save (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/kvs/UserKv.js:106:22)
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:8:34)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:361
[2017-05-05 16:11:13.575] [ERROR] console - (node:27978) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 2): AssertionError: status code must be a number
[2017-05-05 16:11:13.575] [ERROR] console - (node:27978) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
[2017-05-05 16:12:04.885] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 16:12:04.934] [INFO] app - Redis client default is ready {}
[2017-05-05 16:12:04.961] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 16:12:04.967] [INFO] app - application is startup, listening on port 3000
[2017-05-05 16:12:11.349] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 16:12:11.402] [INFO] app - Redis client default is ready {}
[2017-05-05 16:12:11.429] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 16:12:11.435] [INFO] app - application is startup, listening on port 3000
[2017-05-05 16:12:14.462] [DEBUG] app - 2017-5-5 16:12:14 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 16:12:14.466] [WARN] console - this is a logger middleware.
[2017-05-05 16:12:14.472] [INFO] console - Executing (default): DROP TABLE IF EXISTS `user`;
[2017-05-05 16:12:14.478] [INFO] console - Executing (default): CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB;
[2017-05-05 16:12:14.502] [INFO] console - Executing (default): SHOW INDEX FROM `user`
[2017-05-05 16:13:07.841] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 16:13:07.914] [INFO] app - Redis client default is ready {}
[2017-05-05 16:13:07.939] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 16:13:07.947] [INFO] app - application is startup, listening on port 3000
[2017-05-05 16:13:11.314] [DEBUG] app - 2017-5-5 16:13:11 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 16:13:11.318] [WARN] console - this is a logger middleware.
[2017-05-05 16:13:11.323] [ERROR] app - TypeError: User.sync(...).create is not a function
    at UserService._callee2$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:16:43)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:437
    at UserService.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:9:99)
    at UserService.find (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/services/UserService.js:76:22)
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:6:56)
    at tryCatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:191)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:437
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:9:99
    at getUser (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/modules/user/controllers/UserController.js:57:21)
    at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
    at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-router/lib/router.js:326:16
    at dispatch (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/koa-compose/index.js:45:18)
    at _callee$ (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/src/middlewares/logger.js:3:9)
[2017-05-05 16:13:11.338] [ERROR] console - (node:28071) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 2): AssertionError: status code must be a number
[2017-05-05 16:13:11.338] [ERROR] console - (node:28071) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
[2017-05-05 16:13:11.341] [INFO] console - Executing (default): DROP TABLE IF EXISTS `user`;
[2017-05-05 16:13:11.348] [INFO] console - Executing (default): CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB;
[2017-05-05 16:13:11.370] [INFO] console - Executing (default): SHOW INDEX FROM `user`
[2017-05-05 16:13:51.648] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 16:13:51.719] [INFO] app - Redis client default is ready {}
[2017-05-05 16:13:51.754] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 16:13:51.762] [INFO] app - application is startup, listening on port 3000
[2017-05-05 16:13:54.949] [DEBUG] app - 2017-5-5 16:13:54 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 16:13:54.954] [WARN] console - this is a logger middleware.
[2017-05-05 16:13:54.958] [INFO] console - Executing (default): DROP TABLE IF EXISTS `user`;
[2017-05-05 16:13:54.967] [INFO] console - Executing (default): CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB;
[2017-05-05 16:13:54.989] [INFO] console - Executing (default): SHOW INDEX FROM `user`
[2017-05-05 16:13:55.006] [INFO] console - Executing (default): INSERT INTO `user` (`id`,`first_name`,`createdAt`,`updatedAt`) VALUES (DEFAULT,'222222','2017-05-05 08:13:54','2017-05-05 08:13:54');
[2017-05-05 16:13:55.184] [DEBUG] app - 2017-5-5 16:13:55 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 16:13:55.185] [WARN] console - this is a logger middleware.
[2017-05-05 16:13:55.187] [INFO] console - Executing (default): DROP TABLE IF EXISTS `user`;
[2017-05-05 16:13:55.193] [INFO] console - Executing (default): CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB;
[2017-05-05 16:13:55.210] [INFO] console - Executing (default): SHOW INDEX FROM `user`
[2017-05-05 16:13:55.218] [INFO] console - Executing (default): INSERT INTO `user` (`id`,`first_name`,`createdAt`,`updatedAt`) VALUES (DEFAULT,'222222','2017-05-05 08:13:55','2017-05-05 08:13:55');
[2017-05-05 16:15:31.472] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 16:15:31.556] [INFO] app - Redis client default is ready {}
[2017-05-05 16:15:31.586] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 16:15:31.594] [INFO] app - application is startup, listening on port 3000
[2017-05-05 16:15:34.969] [DEBUG] app - 2017-5-5 16:15:34 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 16:15:34.972] [WARN] console - this is a logger middleware.
[2017-05-05 16:15:34.976] [INFO] console - Executing (default): DROP TABLE IF EXISTS `user`;
[2017-05-05 16:15:34.985] [INFO] console - Executing (default): CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB;
[2017-05-05 16:15:35.009] [INFO] console - Executing (default): SHOW INDEX FROM `user`
[2017-05-05 16:15:35.019] [INFO] console - Executing (default): SELECT `id`, `first_name` AS `firstName`, `user_id` AS `userId`, `createdAt`, `updatedAt` FROM `user` AS `user` LIMIT 1;
[2017-05-05 16:15:35.021] [WARN] console - null
[2017-05-05 16:16:44.660] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 16:16:44.751] [INFO] app - Redis client default is ready {}
[2017-05-05 16:16:44.778] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 16:16:44.787] [INFO] app - application is startup, listening on port 3000
[2017-05-05 16:16:45.912] [DEBUG] app - 2017-5-5 16:16:45 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 16:16:45.918] [WARN] console - this is a logger middleware.
[2017-05-05 16:16:45.930] [INFO] console - Executing (default): DROP TABLE IF EXISTS `user`;
[2017-05-05 16:16:45.938] [INFO] console - Executing (default): CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB;
[2017-05-05 16:16:45.960] [INFO] console - Executing (default): SHOW INDEX FROM `user`
[2017-05-05 16:16:45.977] [INFO] console - Executing (default): INSERT INTO `user` (`id`,`first_name`,`createdAt`,`updatedAt`) VALUES (DEFAULT,'2222','2017-05-05 08:16:45','2017-05-05 08:16:45');
[2017-05-05 16:16:45.985] [INFO] console - Executing (default): SELECT `id`, `first_name` AS `firstName`, `user_id` AS `userId`, `createdAt`, `updatedAt` FROM `user` AS `user` LIMIT 1;
[2017-05-05 16:17:02.474] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 16:17:02.554] [INFO] app - Redis client default is ready {}
[2017-05-05 16:17:02.581] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 16:17:02.587] [INFO] app - application is startup, listening on port 3000
[2017-05-05 16:17:03.575] [DEBUG] app - 2017-5-5 16:17:03 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 16:17:03.578] [WARN] console - this is a logger middleware.
[2017-05-05 16:17:03.583] [INFO] console - Executing (default): DROP TABLE IF EXISTS `user`;
[2017-05-05 16:17:03.594] [INFO] console - Executing (default): CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB;
[2017-05-05 16:17:03.614] [INFO] console - Executing (default): SHOW INDEX FROM `user`
[2017-05-05 16:17:03.631] [INFO] console - Executing (default): INSERT INTO `user` (`id`,`first_name`,`createdAt`,`updatedAt`) VALUES (DEFAULT,'2222','2017-05-05 08:17:03','2017-05-05 08:17:03');
[2017-05-05 16:17:03.642] [INFO] console - Executing (default): SELECT `id`, `first_name` AS `firstName`, `user_id` AS `userId`, `createdAt`, `updatedAt` FROM `user` AS `user` LIMIT 1;
[2017-05-05 16:17:03.645] [WARN] console - Instance {
  dataValues: 
   { id: 1,
     firstName: '2222',
     userId: null,
     createdAt: 2017-05-05T08:17:03.000Z,
     updatedAt: 2017-05-05T08:17:03.000Z },
  _previousDataValues: 
   { id: 1,
     firstName: '2222',
     userId: null,
     createdAt: 2017-05-05T08:17:03.000Z,
     updatedAt: 2017-05-05T08:17:03.000Z },
  _changed: {},
  '$modelOptions': 
   { timestamps: true,
     instanceMethods: {},
     classMethods: {},
     validate: {},
     freezeTableName: true,
     underscored: false,
     underscoredAll: false,
     paranoid: false,
     rejectOnEmpty: false,
     whereCollection: null,
     schema: null,
     schemaDelimiter: '',
     defaultScope: {},
     scopes: [],
     hooks: {},
     indexes: [],
     name: { plural: 'users', singular: 'user' },
     omitNul: false,
     sequelize: 
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [Object],
        models: [Object],
        modelManager: [Object],
        connectionManager: [Object],
        importCache: {},
        test: [Object],
        queryInterface: [Object] },
     uniqueKeys: {},
     hasPrimaryKeys: true },
  '$options': 
   { isNewRecord: false,
     '$schema': null,
     '$schemaDelimiter': '',
     raw: true,
     attributes: [ 'id', 'firstName', 'userId', 'createdAt', 'updatedAt' ] },
  hasPrimaryKeys: true,
  __eagerlyLoadedAssociations: [],
  isNewRecord: false }
[2017-05-05 16:17:25.320] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 16:17:25.377] [INFO] app - Redis client default is ready {}
[2017-05-05 16:17:25.404] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 16:17:25.414] [INFO] app - application is startup, listening on port 3000
[2017-05-05 16:17:28.934] [DEBUG] app - 2017-5-5 16:17:28 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 16:17:28.941] [WARN] console - this is a logger middleware.
[2017-05-05 16:17:28.946] [INFO] console - Executing (default): DROP TABLE IF EXISTS `user`;
[2017-05-05 16:17:28.953] [INFO] console - Executing (default): CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB;
[2017-05-05 16:17:28.970] [INFO] console - Executing (default): SHOW INDEX FROM `user`
[2017-05-05 16:17:28.986] [INFO] console - Executing (default): INSERT INTO `user` (`id`,`first_name`,`createdAt`,`updatedAt`) VALUES (DEFAULT,'2222','2017-05-05 08:17:28','2017-05-05 08:17:28');
[2017-05-05 16:17:28.994] [INFO] console - Executing (default): SELECT `id`, `first_name` AS `firstName`, `user_id` AS `userId`, `createdAt`, `updatedAt` FROM `user` AS `user` LIMIT 1;
[2017-05-05 16:17:28.999] [WARN] console - 2222
[2017-05-05 16:19:48.008] [WARN] console - { errors: 
   { BadRequestError: { [Function: BadRequestError] super_: [Object] },
     UnauthorizedError: { [Function: UnauthorizedError] super_: [Object] },
     PaymentRequiredError: { [Function: PaymentRequiredError] super_: [Object] },
     ForbiddenError: { [Function: ForbiddenError] super_: [Object] },
     NotFoundError: { [Function: NotFoundError] super_: [Object] },
     MethodNotAllowedError: { [Function: MethodNotAllowedError] super_: [Object] },
     NotAcceptableError: { [Function: NotAcceptableError] super_: [Object] },
     ProxyAuthenticationRequiredError: { [Function: ProxyAuthenticationRequiredError] super_: [Object] },
     RequestTimeoutError: { [Function: RequestTimeoutError] super_: [Object] },
     ConflictError: { [Function: ConflictError] super_: [Object] },
     GoneError: { [Function: GoneError] super_: [Object] },
     LengthRequiredError: { [Function: LengthRequiredError] super_: [Object] },
     PreconditionFailedError: { [Function: PreconditionFailedError] super_: [Object] },
     RequestEntityTooLargeError: { [Function: RequestEntityTooLargeError] super_: [Object] },
     RequesturiTooLargeError: { [Function: RequesturiTooLargeError] super_: [Object] },
     UnsupportedMediaTypeError: { [Function: UnsupportedMediaTypeError] super_: [Object] },
     RequestedRangeNotSatisfiableError: { [Function: RequestedRangeNotSatisfiableError] super_: [Object] },
     ExpectationFailedError: { [Function: ExpectationFailedError] super_: [Object] },
     ImATeapotError: { [Function: ImATeapotError] super_: [Object] },
     UnprocessableEntityError: { [Function: UnprocessableEntityError] super_: [Object] },
     LockedError: { [Function: LockedError] super_: [Object] },
     FailedDependencyError: { [Function: FailedDependencyError] super_: [Object] },
     UnorderedCollectionError: { [Function: UnorderedCollectionError] super_: [Object] },
     UpgradeRequiredError: { [Function: UpgradeRequiredError] super_: [Object] },
     PreconditionRequiredError: { [Function: PreconditionRequiredError] super_: [Object] },
     TooManyRequestsError: { [Function: TooManyRequestsError] super_: [Object] },
     RequestHeaderFieldsTooLargeError: { [Function: RequestHeaderFieldsTooLargeError] super_: [Object] },
     InternalServerError: { [Function: InternalServerError] super_: [Object] },
     NotImplementedError: { [Function: NotImplementedError] super_: [Object] },
     BadGatewayError: { [Function: BadGatewayError] super_: [Object] },
     ServiceUnavailableError: { [Function: ServiceUnavailableError] super_: [Object] },
     GatewayTimeoutError: { [Function: GatewayTimeoutError] super_: [Object] },
     HttpVersionNotSupportedError: { [Function: HttpVersionNotSupportedError] super_: [Object] },
     VariantAlsoNegotiatesError: { [Function: VariantAlsoNegotiatesError] super_: [Object] },
     InsufficientStorageError: { [Function: InsufficientStorageError] super_: [Object] },
     BandwidthLimitExceededError: { [Function: BandwidthLimitExceededError] super_: [Object] },
     NotExtendedError: { [Function: NotExtendedError] super_: [Object] },
     NetworkAuthenticationRequiredError: { [Function: NetworkAuthenticationRequiredError] super_: [Object] },
     BadDigestError: { [Function: BadDigestError] super_: [Object] },
     BadMethodError: { [Function: BadMethodError] super_: [Object] },
     InternalError: { [Function: InternalError] super_: [Object] },
     InvalidArgumentError: { [Function: InvalidArgumentError] super_: [Object] },
     InvalidContentError: { [Function: InvalidContentError] super_: [Object] },
     InvalidCredentialsError: { [Function: InvalidCredentialsError] super_: [Object] },
     InvalidHeaderError: { [Function: InvalidHeaderError] super_: [Object] },
     MissingParameterError: { [Function: MissingParameterError] super_: [Object] },
     NotAuthorizedError: { [Function: NotAuthorizedError] super_: [Object] },
     RequestExpiredError: { [Function: RequestExpiredError] super_: [Object] },
     RequestThrottledError: { [Function: RequestThrottledError] super_: [Object] },
     WrongAcceptError: { [Function: WrongAcceptError] super_: [Object] } },
  redis: 
   { main: 
      RedisClient {
        domain: null,
        _events: [Object],
        _eventsCount: 6,
        _maxListeners: undefined,
        address: '127.0.0.1:6379',
        connection_options: [Object],
        connection_id: 0,
        connected: false,
        ready: false,
        should_buffer: false,
        max_attempts: 0,
        command_queue: [Object],
        offline_queue: [Object],
        pipeline_queue: [Object],
        connect_timeout: 3600000,
        enable_offline_queue: true,
        retry_max_delay: null,
        retry_timer: null,
        retry_totaltime: 0,
        retry_delay: 200,
        retry_backoff: 1.7,
        attempts: 1,
        pub_sub_mode: 0,
        subscription_set: {},
        monitoring: false,
        message_buffers: false,
        closing: false,
        server_info: {},
        auth_pass: undefined,
        selected_db: undefined,
        old_state: null,
        fire_strings: true,
        pipeline: false,
        sub_commands_left: 0,
        times_connected: 0,
        buffers: false,
        options: [Object],
        reply: 'ON',
        reply_parser: [Object],
        stream: [Object] } },
  mongoose: 
   { main: 
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [Object],
        models: {},
        modelManager: [Object],
        connectionManager: [Object],
        importCache: {},
        test: [Object] } },
  mysql: 
   { main: 
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [Object],
        models: {},
        modelManager: [Object],
        connectionManager: [Object],
        importCache: {},
        test: [Object] } },
  controllers: {},
  services: {},
  models: {},
  kvs: {},
  logger: Logger { category: 'app', _events: { log: [Object] }, _eventsCount: 1 } }
[2017-05-05 16:19:48.053] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 16:19:48.107] [INFO] app - Redis client default is ready {}
[2017-05-05 16:19:48.133] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 16:19:48.140] [INFO] app - application is startup, listening on port 3000
[2017-05-05 16:20:15.315] [WARN] console - { errors: 
   { BadRequestError: { [Function: BadRequestError] super_: [Object] },
     UnauthorizedError: { [Function: UnauthorizedError] super_: [Object] },
     PaymentRequiredError: { [Function: PaymentRequiredError] super_: [Object] },
     ForbiddenError: { [Function: ForbiddenError] super_: [Object] },
     NotFoundError: { [Function: NotFoundError] super_: [Object] },
     MethodNotAllowedError: { [Function: MethodNotAllowedError] super_: [Object] },
     NotAcceptableError: { [Function: NotAcceptableError] super_: [Object] },
     ProxyAuthenticationRequiredError: { [Function: ProxyAuthenticationRequiredError] super_: [Object] },
     RequestTimeoutError: { [Function: RequestTimeoutError] super_: [Object] },
     ConflictError: { [Function: ConflictError] super_: [Object] },
     GoneError: { [Function: GoneError] super_: [Object] },
     LengthRequiredError: { [Function: LengthRequiredError] super_: [Object] },
     PreconditionFailedError: { [Function: PreconditionFailedError] super_: [Object] },
     RequestEntityTooLargeError: { [Function: RequestEntityTooLargeError] super_: [Object] },
     RequesturiTooLargeError: { [Function: RequesturiTooLargeError] super_: [Object] },
     UnsupportedMediaTypeError: { [Function: UnsupportedMediaTypeError] super_: [Object] },
     RequestedRangeNotSatisfiableError: { [Function: RequestedRangeNotSatisfiableError] super_: [Object] },
     ExpectationFailedError: { [Function: ExpectationFailedError] super_: [Object] },
     ImATeapotError: { [Function: ImATeapotError] super_: [Object] },
     UnprocessableEntityError: { [Function: UnprocessableEntityError] super_: [Object] },
     LockedError: { [Function: LockedError] super_: [Object] },
     FailedDependencyError: { [Function: FailedDependencyError] super_: [Object] },
     UnorderedCollectionError: { [Function: UnorderedCollectionError] super_: [Object] },
     UpgradeRequiredError: { [Function: UpgradeRequiredError] super_: [Object] },
     PreconditionRequiredError: { [Function: PreconditionRequiredError] super_: [Object] },
     TooManyRequestsError: { [Function: TooManyRequestsError] super_: [Object] },
     RequestHeaderFieldsTooLargeError: { [Function: RequestHeaderFieldsTooLargeError] super_: [Object] },
     InternalServerError: { [Function: InternalServerError] super_: [Object] },
     NotImplementedError: { [Function: NotImplementedError] super_: [Object] },
     BadGatewayError: { [Function: BadGatewayError] super_: [Object] },
     ServiceUnavailableError: { [Function: ServiceUnavailableError] super_: [Object] },
     GatewayTimeoutError: { [Function: GatewayTimeoutError] super_: [Object] },
     HttpVersionNotSupportedError: { [Function: HttpVersionNotSupportedError] super_: [Object] },
     VariantAlsoNegotiatesError: { [Function: VariantAlsoNegotiatesError] super_: [Object] },
     InsufficientStorageError: { [Function: InsufficientStorageError] super_: [Object] },
     BandwidthLimitExceededError: { [Function: BandwidthLimitExceededError] super_: [Object] },
     NotExtendedError: { [Function: NotExtendedError] super_: [Object] },
     NetworkAuthenticationRequiredError: { [Function: NetworkAuthenticationRequiredError] super_: [Object] },
     BadDigestError: { [Function: BadDigestError] super_: [Object] },
     BadMethodError: { [Function: BadMethodError] super_: [Object] },
     InternalError: { [Function: InternalError] super_: [Object] },
     InvalidArgumentError: { [Function: InvalidArgumentError] super_: [Object] },
     InvalidContentError: { [Function: InvalidContentError] super_: [Object] },
     InvalidCredentialsError: { [Function: InvalidCredentialsError] super_: [Object] },
     InvalidHeaderError: { [Function: InvalidHeaderError] super_: [Object] },
     MissingParameterError: { [Function: MissingParameterError] super_: [Object] },
     NotAuthorizedError: { [Function: NotAuthorizedError] super_: [Object] },
     RequestExpiredError: { [Function: RequestExpiredError] super_: [Object] },
     RequestThrottledError: { [Function: RequestThrottledError] super_: [Object] },
     WrongAcceptError: { [Function: WrongAcceptError] super_: [Object] } },
  redis: 
   { main: 
      RedisClient {
        domain: null,
        _events: [Object],
        _eventsCount: 6,
        _maxListeners: undefined,
        address: '127.0.0.1:6379',
        connection_options: [Object],
        connection_id: 0,
        connected: false,
        ready: false,
        should_buffer: false,
        max_attempts: 0,
        command_queue: [Object],
        offline_queue: [Object],
        pipeline_queue: [Object],
        connect_timeout: 3600000,
        enable_offline_queue: true,
        retry_max_delay: null,
        retry_timer: null,
        retry_totaltime: 0,
        retry_delay: 200,
        retry_backoff: 1.7,
        attempts: 1,
        pub_sub_mode: 0,
        subscription_set: {},
        monitoring: false,
        message_buffers: false,
        closing: false,
        server_info: {},
        auth_pass: undefined,
        selected_db: undefined,
        old_state: null,
        fire_strings: true,
        pipeline: false,
        sub_commands_left: 0,
        times_connected: 0,
        buffers: false,
        options: [Object],
        reply: 'ON',
        reply_parser: [Object],
        stream: [Object] } },
  db: 
   { main: 
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [Object],
        models: {},
        modelManager: [Object],
        connectionManager: [Object],
        importCache: {},
        test: [Object] } },
  mongoose: 
   { main: 
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [Object],
        models: {},
        modelManager: [Object],
        connectionManager: [Object],
        importCache: {},
        test: [Object] } },
  controllers: {},
  services: {},
  models: {},
  kvs: {},
  logger: Logger { category: 'app', _events: { log: [Object] }, _eventsCount: 1 } }
[2017-05-05 16:20:15.364] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 16:20:15.424] [INFO] app - Redis client default is ready {}
[2017-05-05 16:20:15.449] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 16:20:15.456] [INFO] app - application is startup, listening on port 3000
[2017-05-05 16:20:20.326] [DEBUG] app - 2017-5-5 16:20:20 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 16:20:20.331] [WARN] console - this is a logger middleware.
[2017-05-05 16:20:20.336] [INFO] console - Executing (default): DROP TABLE IF EXISTS `user`;
[2017-05-05 16:20:20.346] [INFO] console - Executing (default): CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB;
[2017-05-05 16:20:20.379] [INFO] console - Executing (default): SHOW INDEX FROM `user`
[2017-05-05 16:20:20.397] [INFO] console - Executing (default): INSERT INTO `user` (`id`,`first_name`,`createdAt`,`updatedAt`) VALUES (DEFAULT,'2222','2017-05-05 08:20:20','2017-05-05 08:20:20');
[2017-05-05 16:20:20.403] [INFO] console - Executing (default): SELECT `id`, `first_name` AS `firstName`, `user_id` AS `userId`, `createdAt`, `updatedAt` FROM `user` AS `user` LIMIT 1;
[2017-05-05 16:20:20.407] [WARN] console - 2222
[2017-05-05 16:20:29.459] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 16:20:29.512] [INFO] app - Redis client default is ready {}
[2017-05-05 16:20:29.537] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 16:20:29.555] [INFO] app - application is startup, listening on port 3000
[2017-05-05 16:21:03.592] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 16:21:03.720] [INFO] app - Redis client default is ready {}
[2017-05-05 16:21:03.746] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 16:21:03.754] [INFO] app - application is startup, listening on port 3000
[2017-05-05 16:32:22.392] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 16:32:22.453] [INFO] app - Redis client default is ready {}
[2017-05-05 16:32:22.485] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 16:32:22.490] [INFO] app - application is startup, listening on port 3000
[2017-05-05 16:34:18.137] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 16:34:18.226] [INFO] app - Redis client default is ready {}
[2017-05-05 16:34:18.248] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 16:34:18.254] [INFO] app - application is startup, listening on port 3000
[2017-05-05 16:44:34.276] [DEBUG] app - 2017-5-5 16:44:34 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 16:44:34.280] [WARN] console - this is a logger middleware.
[2017-05-05 16:44:34.291] [INFO] console - Executing (default): DROP TABLE IF EXISTS `user`;
[2017-05-05 16:44:34.299] [INFO] console - Executing (default): CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB;
[2017-05-05 16:44:34.319] [INFO] console - Executing (default): SHOW INDEX FROM `user`
[2017-05-05 16:44:34.337] [INFO] console - Executing (default): INSERT INTO `user` (`id`,`first_name`,`createdAt`,`updatedAt`) VALUES (DEFAULT,'2222','2017-05-05 08:44:34','2017-05-05 08:44:34');
[2017-05-05 16:44:34.344] [INFO] console - Executing (default): SELECT `id`, `first_name` AS `firstName`, `user_id` AS `userId`, `createdAt`, `updatedAt` FROM `user` AS `user` LIMIT 1;
[2017-05-05 16:44:34.348] [WARN] console - 2222
[2017-05-05 17:07:38.706] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 17:07:38.786] [INFO] app - Redis client default is ready {}
[2017-05-05 17:07:38.808] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 17:07:38.816] [INFO] app - application is startup, listening on port 3000
[2017-05-05 17:07:42.013] [DEBUG] app - 2017-5-5 17:07:42 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 17:07:42.017] [WARN] console - this is a logger middleware.
[2017-05-05 17:07:42.022] [INFO] console - Executing (default): DROP TABLE IF EXISTS `user`;
[2017-05-05 17:07:42.029] [INFO] console - Executing (default): CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB;
[2017-05-05 17:07:42.052] [INFO] console - Executing (default): SHOW INDEX FROM `user`
[2017-05-05 17:07:42.068] [INFO] console - Executing (default): INSERT INTO `user` (`id`,`first_name`,`createdAt`,`updatedAt`) VALUES (DEFAULT,'2222','2017-05-05 09:07:42','2017-05-05 09:07:42');
[2017-05-05 17:07:42.076] [INFO] console - Executing (default): SELECT `id`, `first_name` AS `firstName`, `user_id` AS `userId`, `createdAt`, `updatedAt` FROM `user` AS `user` LIMIT 1;
[2017-05-05 17:07:42.080] [WARN] console - { fullName: 'undefined undefined',
  id: 1,
  firstName: '2222',
  userId: null,
  createdAt: 2017-05-05T09:07:42.000Z,
  updatedAt: 2017-05-05T09:07:42.000Z }
[2017-05-05 17:08:02.624] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 17:08:02.694] [INFO] app - Redis client default is ready {}
[2017-05-05 17:08:02.717] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 17:08:02.723] [INFO] app - application is startup, listening on port 3000
[2017-05-05 17:08:13.089] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 17:08:13.169] [INFO] app - Redis client default is ready {}
[2017-05-05 17:08:13.192] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 17:08:13.197] [INFO] app - application is startup, listening on port 3000
[2017-05-05 17:08:16.759] [DEBUG] app - 2017-5-5 17:08:16 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 17:08:16.763] [WARN] console - this is a logger middleware.
[2017-05-05 17:08:16.767] [INFO] console - Executing (default): DROP TABLE IF EXISTS `user`;
[2017-05-05 17:08:16.774] [INFO] console - Executing (default): CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB;
[2017-05-05 17:08:16.796] [INFO] console - Executing (default): SHOW INDEX FROM `user`
[2017-05-05 17:08:16.811] [INFO] console - Executing (default): INSERT INTO `user` (`id`,`first_name`,`createdAt`,`updatedAt`) VALUES (DEFAULT,'2222','2017-05-05 09:08:16','2017-05-05 09:08:16');
[2017-05-05 17:08:16.818] [INFO] console - Executing (default): SELECT `id`, `first_name` AS `firstName`, `user_id` AS `userId`, `createdAt`, `updatedAt` FROM `user` AS `user` LIMIT 1;
[2017-05-05 17:08:16.825] [WARN] console - { fullName: '2222 lastName',
  id: 1,
  firstName: '2222',
  userId: null,
  createdAt: 2017-05-05T09:08:16.000Z,
  updatedAt: 2017-05-05T09:08:16.000Z }
[2017-05-05 17:17:28.399] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 17:17:28.493] [INFO] app - Redis client default is ready {}
[2017-05-05 17:17:28.517] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 17:17:28.528] [INFO] app - application is startup, listening on port 3000
[2017-05-05 17:17:31.151] [DEBUG] app - 2017-5-5 17:17:31 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 17:17:31.154] [WARN] console - this is a logger middleware.
[2017-05-05 17:17:31.159] [INFO] console - Executing (default): DROP TABLE IF EXISTS `user`;
[2017-05-05 17:17:31.168] [INFO] console - Executing (default): CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB;
[2017-05-05 17:17:31.187] [INFO] console - Executing (default): SHOW INDEX FROM `user`
[2017-05-05 17:17:31.207] [INFO] console - Executing (default): INSERT INTO `user` (`id`,`first_name`,`createdAt`,`updatedAt`) VALUES (DEFAULT,'2222','2017-05-05 09:17:31','2017-05-05 09:17:31');
[2017-05-05 17:17:31.216] [INFO] console - Executing (default): SELECT `id`, `first_name` AS `firstName`, `user_id` AS `userId`, `createdAt`, `updatedAt` FROM `user` AS `user` LIMIT 1;
[2017-05-05 17:17:41.559] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 17:17:41.617] [INFO] app - Redis client default is ready {}
[2017-05-05 17:17:41.643] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 17:17:41.648] [INFO] app - application is startup, listening on port 3000
[2017-05-05 17:17:42.723] [DEBUG] app - 2017-5-5 17:17:42 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 17:17:42.727] [WARN] console - this is a logger middleware.
[2017-05-05 17:17:42.731] [INFO] console - Executing (default): DROP TABLE IF EXISTS `user`;
[2017-05-05 17:17:42.740] [INFO] console - Executing (default): CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB;
[2017-05-05 17:17:42.761] [INFO] console - Executing (default): SHOW INDEX FROM `user`
[2017-05-05 17:17:42.776] [INFO] console - Executing (default): INSERT INTO `user` (`id`,`first_name`,`createdAt`,`updatedAt`) VALUES (DEFAULT,'2222','2017-05-05 09:17:42','2017-05-05 09:17:42');
[2017-05-05 17:17:42.783] [INFO] console - Executing (default): SELECT `id`, `first_name` AS `firstName`, `user_id` AS `userId`, `createdAt`, `updatedAt` FROM `user` AS `user` LIMIT 1;
[2017-05-05 17:18:02.467] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 17:18:02.534] [INFO] app - Redis client default is ready {}
[2017-05-05 17:18:02.559] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 17:18:02.565] [INFO] app - application is startup, listening on port 3000
[2017-05-05 17:38:54.070] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 17:38:54.160] [INFO] app - Redis client default is ready {}
[2017-05-05 17:38:54.191] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 17:38:54.199] [INFO] app - application is startup, listening on port 3000
[2017-05-05 17:38:56.271] [DEBUG] app - 2017-5-5 17:38:56 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 17:38:56.275] [WARN] console - this is a logger middleware.
[2017-05-05 17:38:56.280] [INFO] console - Executing (default): DROP TABLE IF EXISTS `user`;
[2017-05-05 17:38:56.293] [INFO] console - Executing (default): CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`), FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE) ENGINE=InnoDB;
[2017-05-05 17:38:56.325] [ERROR] app - { SequelizeBaseError: ER_CANNOT_ADD_FOREIGN: Cannot add foreign key constraint
    at Query.formatError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:175:14)
    at Query._callback (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:49:21)
    at Query.Sequence.end (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:86:24)
    at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:88:8)
    at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
    at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
    at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
    at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
    at emitOne (events.js:96:13)
    at Socket.emit (events.js:191:7)
    at readableAddChunk (_stream_readable.js:178:18)
    at Socket.Readable.push (_stream_readable.js:136:10)
    at TCP.onread (net.js:560:20)
  name: 'SequelizeDatabaseError',
  message: 'ER_CANNOT_ADD_FOREIGN: Cannot add foreign key constraint',
  parent: 
   { Error: ER_CANNOT_ADD_FOREIGN: Cannot add foreign key constraint
       at Query.Sequence._packetToError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:52:14)
       at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:77:18)
       at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
       at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
       at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
       at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
       at emitOne (events.js:96:13)
       at Socket.emit (events.js:191:7)
       at readableAddChunk (_stream_readable.js:178:18)
       at Socket.Readable.push (_stream_readable.js:136:10)
       at TCP.onread (net.js:560:20)
       --------------------
       at Protocol._enqueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:141:48)
       at Connection.query (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:208:25)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at Query.run (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:39:17)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:849:20
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at retryAsPromised (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:30:10)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:848:12
       at tryCatcher (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/util.js:16:23)
       at Promise._settlePromiseFromHandler (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:512:31)
       at Promise._settlePromise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:569:18)
       at Promise._settlePromise0 (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:614:10)
       at Promise._settlePromises (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:693:18)
       at Async._drainQueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:133:16)
       at Async._drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:143:10)
       at Immediate.Async.drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:17:14)
     code: 'ER_CANNOT_ADD_FOREIGN',
     errno: 1215,
     sqlState: 'HY000',
     index: 0,
     sql: 'CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`), FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE) ENGINE=InnoDB;' },
  original: 
   { Error: ER_CANNOT_ADD_FOREIGN: Cannot add foreign key constraint
       at Query.Sequence._packetToError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:52:14)
       at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:77:18)
       at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
       at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
       at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
       at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
       at emitOne (events.js:96:13)
       at Socket.emit (events.js:191:7)
       at readableAddChunk (_stream_readable.js:178:18)
       at Socket.Readable.push (_stream_readable.js:136:10)
       at TCP.onread (net.js:560:20)
       --------------------
       at Protocol._enqueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:141:48)
       at Connection.query (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:208:25)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at Query.run (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:39:17)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:849:20
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at retryAsPromised (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:30:10)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:848:12
       at tryCatcher (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/util.js:16:23)
       at Promise._settlePromiseFromHandler (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:512:31)
       at Promise._settlePromise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:569:18)
       at Promise._settlePromise0 (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:614:10)
       at Promise._settlePromises (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:693:18)
       at Async._drainQueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:133:16)
       at Async._drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:143:10)
       at Immediate.Async.drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:17:14)
     code: 'ER_CANNOT_ADD_FOREIGN',
     errno: 1215,
     sqlState: 'HY000',
     index: 0,
     sql: 'CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`), FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE) ENGINE=InnoDB;' },
  sql: 'CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`), FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE) ENGINE=InnoDB;' }
[2017-05-05 17:38:56.340] [ERROR] console - (node:29365) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): AssertionError: status code must be a number
[2017-05-05 17:38:56.340] [ERROR] console - (node:29365) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
[2017-05-05 17:39:49.432] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 17:39:49.501] [INFO] app - Redis client default is ready {}
[2017-05-05 17:39:49.526] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 17:39:49.534] [INFO] app - application is startup, listening on port 3000
[2017-05-05 17:39:57.255] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 17:39:57.320] [INFO] app - Redis client default is ready {}
[2017-05-05 17:39:57.362] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 17:39:57.368] [INFO] app - application is startup, listening on port 3000
[2017-05-05 17:40:11.604] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 17:40:11.678] [INFO] app - Redis client default is ready {}
[2017-05-05 17:40:11.706] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 17:40:11.712] [INFO] app - application is startup, listening on port 3000
[2017-05-05 17:40:12.409] [DEBUG] app - 2017-5-5 17:40:12 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 17:40:12.417] [WARN] console - this is a logger middleware.
[2017-05-05 17:40:12.422] [INFO] console - Executing (default): DROP TABLE IF EXISTS `user`;
[2017-05-05 17:40:12.429] [INFO] console - Executing (default): CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`), FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE) ENGINE=InnoDB;
[2017-05-05 17:40:12.455] [ERROR] app - { SequelizeBaseError: ER_CANNOT_ADD_FOREIGN: Cannot add foreign key constraint
    at Query.formatError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:175:14)
    at Query._callback (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:49:21)
    at Query.Sequence.end (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:86:24)
    at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:88:8)
    at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
    at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
    at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
    at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
    at emitOne (events.js:96:13)
    at Socket.emit (events.js:191:7)
    at readableAddChunk (_stream_readable.js:178:18)
    at Socket.Readable.push (_stream_readable.js:136:10)
    at TCP.onread (net.js:560:20)
  name: 'SequelizeDatabaseError',
  message: 'ER_CANNOT_ADD_FOREIGN: Cannot add foreign key constraint',
  parent: 
   { Error: ER_CANNOT_ADD_FOREIGN: Cannot add foreign key constraint
       at Query.Sequence._packetToError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:52:14)
       at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:77:18)
       at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
       at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
       at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
       at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
       at emitOne (events.js:96:13)
       at Socket.emit (events.js:191:7)
       at readableAddChunk (_stream_readable.js:178:18)
       at Socket.Readable.push (_stream_readable.js:136:10)
       at TCP.onread (net.js:560:20)
       --------------------
       at Protocol._enqueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:141:48)
       at Connection.query (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:208:25)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at Query.run (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:39:17)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:849:20
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at retryAsPromised (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:30:10)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:848:12
       at tryCatcher (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/util.js:16:23)
       at Promise._settlePromiseFromHandler (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:512:31)
       at Promise._settlePromise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:569:18)
       at Promise._settlePromise0 (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:614:10)
       at Promise._settlePromises (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:693:18)
       at Async._drainQueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:133:16)
       at Async._drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:143:10)
       at Immediate.Async.drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:17:14)
     code: 'ER_CANNOT_ADD_FOREIGN',
     errno: 1215,
     sqlState: 'HY000',
     index: 0,
     sql: 'CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`), FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE) ENGINE=InnoDB;' },
  original: 
   { Error: ER_CANNOT_ADD_FOREIGN: Cannot add foreign key constraint
       at Query.Sequence._packetToError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:52:14)
       at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:77:18)
       at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
       at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
       at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
       at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
       at emitOne (events.js:96:13)
       at Socket.emit (events.js:191:7)
       at readableAddChunk (_stream_readable.js:178:18)
       at Socket.Readable.push (_stream_readable.js:136:10)
       at TCP.onread (net.js:560:20)
       --------------------
       at Protocol._enqueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:141:48)
       at Connection.query (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:208:25)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at Query.run (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:39:17)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:849:20
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at retryAsPromised (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:30:10)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:848:12
       at tryCatcher (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/util.js:16:23)
       at Promise._settlePromiseFromHandler (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:512:31)
       at Promise._settlePromise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:569:18)
       at Promise._settlePromise0 (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:614:10)
       at Promise._settlePromises (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:693:18)
       at Async._drainQueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:133:16)
       at Async._drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:143:10)
       at Immediate.Async.drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:17:14)
     code: 'ER_CANNOT_ADD_FOREIGN',
     errno: 1215,
     sqlState: 'HY000',
     index: 0,
     sql: 'CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`), FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE) ENGINE=InnoDB;' },
  sql: 'CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`), FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE) ENGINE=InnoDB;' }
[2017-05-05 17:40:12.518] [ERROR] console - (node:29457) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): AssertionError: status code must be a number
[2017-05-05 17:40:12.518] [ERROR] console - (node:29457) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
[2017-05-05 17:41:19.242] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 17:41:19.308] [INFO] app - Redis client default is ready {}
[2017-05-05 17:41:19.339] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 17:41:19.345] [INFO] app - application is startup, listening on port 3000
[2017-05-05 17:41:21.255] [DEBUG] app - 2017-5-5 17:41:21 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 17:41:21.259] [WARN] console - this is a logger middleware.
[2017-05-05 17:41:21.262] [INFO] console - Executing (default): DROP TABLE IF EXISTS `user`;
[2017-05-05 17:41:21.267] [INFO] console - Executing (default): CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`), FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE) ENGINE=InnoDB;
[2017-05-05 17:41:21.293] [ERROR] app - { SequelizeBaseError: ER_CANNOT_ADD_FOREIGN: Cannot add foreign key constraint
    at Query.formatError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:175:14)
    at Query._callback (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:49:21)
    at Query.Sequence.end (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:86:24)
    at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:88:8)
    at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
    at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
    at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
    at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
    at emitOne (events.js:96:13)
    at Socket.emit (events.js:191:7)
    at readableAddChunk (_stream_readable.js:178:18)
    at Socket.Readable.push (_stream_readable.js:136:10)
    at TCP.onread (net.js:560:20)
  name: 'SequelizeDatabaseError',
  message: 'ER_CANNOT_ADD_FOREIGN: Cannot add foreign key constraint',
  parent: 
   { Error: ER_CANNOT_ADD_FOREIGN: Cannot add foreign key constraint
       at Query.Sequence._packetToError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:52:14)
       at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:77:18)
       at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
       at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
       at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
       at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
       at emitOne (events.js:96:13)
       at Socket.emit (events.js:191:7)
       at readableAddChunk (_stream_readable.js:178:18)
       at Socket.Readable.push (_stream_readable.js:136:10)
       at TCP.onread (net.js:560:20)
       --------------------
       at Protocol._enqueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:141:48)
       at Connection.query (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:208:25)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at Query.run (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:39:17)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:849:20
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at retryAsPromised (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:30:10)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:848:12
       at tryCatcher (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/util.js:16:23)
       at Promise._settlePromiseFromHandler (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:512:31)
       at Promise._settlePromise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:569:18)
       at Promise._settlePromise0 (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:614:10)
       at Promise._settlePromises (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:693:18)
       at Async._drainQueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:133:16)
       at Async._drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:143:10)
       at Immediate.Async.drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:17:14)
     code: 'ER_CANNOT_ADD_FOREIGN',
     errno: 1215,
     sqlState: 'HY000',
     index: 0,
     sql: 'CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`), FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE) ENGINE=InnoDB;' },
  original: 
   { Error: ER_CANNOT_ADD_FOREIGN: Cannot add foreign key constraint
       at Query.Sequence._packetToError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:52:14)
       at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:77:18)
       at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
       at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
       at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
       at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
       at emitOne (events.js:96:13)
       at Socket.emit (events.js:191:7)
       at readableAddChunk (_stream_readable.js:178:18)
       at Socket.Readable.push (_stream_readable.js:136:10)
       at TCP.onread (net.js:560:20)
       --------------------
       at Protocol._enqueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:141:48)
       at Connection.query (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:208:25)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at Query.run (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:39:17)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:849:20
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at retryAsPromised (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:30:10)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:848:12
       at tryCatcher (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/util.js:16:23)
       at Promise._settlePromiseFromHandler (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:512:31)
       at Promise._settlePromise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:569:18)
       at Promise._settlePromise0 (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:614:10)
       at Promise._settlePromises (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:693:18)
       at Async._drainQueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:133:16)
       at Async._drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:143:10)
       at Immediate.Async.drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:17:14)
     code: 'ER_CANNOT_ADD_FOREIGN',
     errno: 1215,
     sqlState: 'HY000',
     index: 0,
     sql: 'CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`), FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE) ENGINE=InnoDB;' },
  sql: 'CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`), FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE) ENGINE=InnoDB;' }
[2017-05-05 17:41:21.307] [ERROR] console - (node:29578) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): AssertionError: status code must be a number
[2017-05-05 17:41:21.307] [ERROR] console - (node:29578) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
[2017-05-05 17:42:03.874] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 17:42:03.938] [INFO] app - Redis client default is ready {}
[2017-05-05 17:42:03.970] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 17:42:03.983] [INFO] app - application is startup, listening on port 3000
[2017-05-05 17:42:05.365] [DEBUG] app - 2017-5-5 17:42:05 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 17:42:05.369] [WARN] console - this is a logger middleware.
[2017-05-05 17:42:05.374] [INFO] console - Executing (default): DROP TABLE IF EXISTS `user`;
[2017-05-05 17:42:05.380] [INFO] console - Executing (default): CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`), FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE) ENGINE=InnoDB;
[2017-05-05 17:42:05.409] [ERROR] app - { SequelizeBaseError: ER_CANNOT_ADD_FOREIGN: Cannot add foreign key constraint
    at Query.formatError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:175:14)
    at Query._callback (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:49:21)
    at Query.Sequence.end (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:86:24)
    at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:88:8)
    at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
    at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
    at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
    at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
    at emitOne (events.js:96:13)
    at Socket.emit (events.js:191:7)
    at readableAddChunk (_stream_readable.js:178:18)
    at Socket.Readable.push (_stream_readable.js:136:10)
    at TCP.onread (net.js:560:20)
  name: 'SequelizeDatabaseError',
  message: 'ER_CANNOT_ADD_FOREIGN: Cannot add foreign key constraint',
  parent: 
   { Error: ER_CANNOT_ADD_FOREIGN: Cannot add foreign key constraint
       at Query.Sequence._packetToError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:52:14)
       at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:77:18)
       at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
       at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
       at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
       at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
       at emitOne (events.js:96:13)
       at Socket.emit (events.js:191:7)
       at readableAddChunk (_stream_readable.js:178:18)
       at Socket.Readable.push (_stream_readable.js:136:10)
       at TCP.onread (net.js:560:20)
       --------------------
       at Protocol._enqueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:141:48)
       at Connection.query (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:208:25)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at Query.run (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:39:17)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:849:20
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at retryAsPromised (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:30:10)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:848:12
       at tryCatcher (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/util.js:16:23)
       at Promise._settlePromiseFromHandler (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:512:31)
       at Promise._settlePromise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:569:18)
       at Promise._settlePromise0 (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:614:10)
       at Promise._settlePromises (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:693:18)
       at Async._drainQueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:133:16)
       at Async._drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:143:10)
       at Immediate.Async.drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:17:14)
     code: 'ER_CANNOT_ADD_FOREIGN',
     errno: 1215,
     sqlState: 'HY000',
     index: 0,
     sql: 'CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`), FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE) ENGINE=InnoDB;' },
  original: 
   { Error: ER_CANNOT_ADD_FOREIGN: Cannot add foreign key constraint
       at Query.Sequence._packetToError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:52:14)
       at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:77:18)
       at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
       at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
       at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
       at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
       at emitOne (events.js:96:13)
       at Socket.emit (events.js:191:7)
       at readableAddChunk (_stream_readable.js:178:18)
       at Socket.Readable.push (_stream_readable.js:136:10)
       at TCP.onread (net.js:560:20)
       --------------------
       at Protocol._enqueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:141:48)
       at Connection.query (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:208:25)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at Query.run (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:39:17)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:849:20
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at retryAsPromised (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:30:10)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:848:12
       at tryCatcher (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/util.js:16:23)
       at Promise._settlePromiseFromHandler (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:512:31)
       at Promise._settlePromise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:569:18)
       at Promise._settlePromise0 (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:614:10)
       at Promise._settlePromises (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:693:18)
       at Async._drainQueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:133:16)
       at Async._drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:143:10)
       at Immediate.Async.drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:17:14)
     code: 'ER_CANNOT_ADD_FOREIGN',
     errno: 1215,
     sqlState: 'HY000',
     index: 0,
     sql: 'CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`), FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE) ENGINE=InnoDB;' },
  sql: 'CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`), FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE) ENGINE=InnoDB;' }
[2017-05-05 17:42:05.421] [ERROR] console - (node:29606) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): AssertionError: status code must be a number
[2017-05-05 17:42:05.421] [ERROR] console - (node:29606) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
[2017-05-05 17:42:39.967] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 17:42:40.041] [INFO] app - Redis client default is ready {}
[2017-05-05 17:42:40.062] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 17:42:40.070] [INFO] app - application is startup, listening on port 3000
[2017-05-05 17:42:43.346] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 17:42:43.413] [INFO] app - Redis client default is ready {}
[2017-05-05 17:42:43.436] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 17:42:43.442] [INFO] app - application is startup, listening on port 3000
[2017-05-05 17:42:59.957] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 17:43:00.035] [INFO] app - Redis client default is ready {}
[2017-05-05 17:43:00.061] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 17:43:00.068] [INFO] app - application is startup, listening on port 3000
[2017-05-05 17:43:01.860] [DEBUG] app - 2017-5-5 17:43:01 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 17:43:01.863] [WARN] console - this is a logger middleware.
[2017-05-05 17:43:01.868] [INFO] console - Executing (default): DROP TABLE IF EXISTS `user`;
[2017-05-05 17:43:01.874] [INFO] console - Executing (default): CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`), FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE) ENGINE=InnoDB;
[2017-05-05 17:43:01.904] [ERROR] app - { SequelizeBaseError: ER_CANNOT_ADD_FOREIGN: Cannot add foreign key constraint
    at Query.formatError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:175:14)
    at Query._callback (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:49:21)
    at Query.Sequence.end (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:86:24)
    at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:88:8)
    at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
    at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
    at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
    at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
    at emitOne (events.js:96:13)
    at Socket.emit (events.js:191:7)
    at readableAddChunk (_stream_readable.js:178:18)
    at Socket.Readable.push (_stream_readable.js:136:10)
    at TCP.onread (net.js:560:20)
  name: 'SequelizeDatabaseError',
  message: 'ER_CANNOT_ADD_FOREIGN: Cannot add foreign key constraint',
  parent: 
   { Error: ER_CANNOT_ADD_FOREIGN: Cannot add foreign key constraint
       at Query.Sequence._packetToError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:52:14)
       at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:77:18)
       at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
       at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
       at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
       at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
       at emitOne (events.js:96:13)
       at Socket.emit (events.js:191:7)
       at readableAddChunk (_stream_readable.js:178:18)
       at Socket.Readable.push (_stream_readable.js:136:10)
       at TCP.onread (net.js:560:20)
       --------------------
       at Protocol._enqueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:141:48)
       at Connection.query (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:208:25)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at Query.run (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:39:17)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:849:20
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at retryAsPromised (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:30:10)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:848:12
       at tryCatcher (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/util.js:16:23)
       at Promise._settlePromiseFromHandler (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:512:31)
       at Promise._settlePromise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:569:18)
       at Promise._settlePromise0 (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:614:10)
       at Promise._settlePromises (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:693:18)
       at Async._drainQueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:133:16)
       at Async._drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:143:10)
       at Immediate.Async.drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:17:14)
     code: 'ER_CANNOT_ADD_FOREIGN',
     errno: 1215,
     sqlState: 'HY000',
     index: 0,
     sql: 'CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`), FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE) ENGINE=InnoDB;' },
  original: 
   { Error: ER_CANNOT_ADD_FOREIGN: Cannot add foreign key constraint
       at Query.Sequence._packetToError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:52:14)
       at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:77:18)
       at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
       at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
       at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
       at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
       at emitOne (events.js:96:13)
       at Socket.emit (events.js:191:7)
       at readableAddChunk (_stream_readable.js:178:18)
       at Socket.Readable.push (_stream_readable.js:136:10)
       at TCP.onread (net.js:560:20)
       --------------------
       at Protocol._enqueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:141:48)
       at Connection.query (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:208:25)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at Query.run (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:39:17)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:849:20
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at retryAsPromised (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:30:10)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:848:12
       at tryCatcher (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/util.js:16:23)
       at Promise._settlePromiseFromHandler (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:512:31)
       at Promise._settlePromise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:569:18)
       at Promise._settlePromise0 (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:614:10)
       at Promise._settlePromises (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:693:18)
       at Async._drainQueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:133:16)
       at Async._drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:143:10)
       at Immediate.Async.drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:17:14)
     code: 'ER_CANNOT_ADD_FOREIGN',
     errno: 1215,
     sqlState: 'HY000',
     index: 0,
     sql: 'CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`), FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE) ENGINE=InnoDB;' },
  sql: 'CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`), FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE) ENGINE=InnoDB;' }
[2017-05-05 17:43:01.916] [ERROR] console - (node:29691) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): AssertionError: status code must be a number
[2017-05-05 17:43:01.917] [ERROR] console - (node:29691) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
[2017-05-05 17:43:23.347] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 17:43:23.415] [INFO] app - Redis client default is ready {}
[2017-05-05 17:43:23.443] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 17:43:23.451] [INFO] app - application is startup, listening on port 3000
[2017-05-05 17:43:48.057] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 17:43:48.153] [INFO] app - Redis client default is ready {}
[2017-05-05 17:43:48.182] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 17:43:48.192] [INFO] app - application is startup, listening on port 3000
[2017-05-05 17:44:04.556] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 17:44:04.658] [INFO] app - Redis client default is ready {}
[2017-05-05 17:44:04.682] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 17:44:04.688] [INFO] app - application is startup, listening on port 3000
[2017-05-05 17:44:15.825] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 17:44:15.897] [INFO] app - Redis client default is ready {}
[2017-05-05 17:44:15.933] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 17:44:15.943] [INFO] app - application is startup, listening on port 3000
[2017-05-05 17:44:18.541] [DEBUG] app - 2017-5-5 17:44:18 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 17:44:18.545] [WARN] console - this is a logger middleware.
[2017-05-05 17:44:18.552] [INFO] console - Executing (default): DROP TABLE IF EXISTS `user`;
[2017-05-05 17:44:18.557] [INFO] console - Executing (default): CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`), FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE) ENGINE=InnoDB;
[2017-05-05 17:44:18.586] [ERROR] app - { SequelizeBaseError: ER_CANNOT_ADD_FOREIGN: Cannot add foreign key constraint
    at Query.formatError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:175:14)
    at Query._callback (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:49:21)
    at Query.Sequence.end (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:86:24)
    at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:88:8)
    at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
    at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
    at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
    at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
    at emitOne (events.js:96:13)
    at Socket.emit (events.js:191:7)
    at readableAddChunk (_stream_readable.js:178:18)
    at Socket.Readable.push (_stream_readable.js:136:10)
    at TCP.onread (net.js:560:20)
  name: 'SequelizeDatabaseError',
  message: 'ER_CANNOT_ADD_FOREIGN: Cannot add foreign key constraint',
  parent: 
   { Error: ER_CANNOT_ADD_FOREIGN: Cannot add foreign key constraint
       at Query.Sequence._packetToError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:52:14)
       at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:77:18)
       at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
       at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
       at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
       at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
       at emitOne (events.js:96:13)
       at Socket.emit (events.js:191:7)
       at readableAddChunk (_stream_readable.js:178:18)
       at Socket.Readable.push (_stream_readable.js:136:10)
       at TCP.onread (net.js:560:20)
       --------------------
       at Protocol._enqueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:141:48)
       at Connection.query (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:208:25)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at Query.run (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:39:17)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:849:20
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at retryAsPromised (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:30:10)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:848:12
       at tryCatcher (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/util.js:16:23)
       at Promise._settlePromiseFromHandler (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:512:31)
       at Promise._settlePromise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:569:18)
       at Promise._settlePromise0 (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:614:10)
       at Promise._settlePromises (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:693:18)
       at Async._drainQueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:133:16)
       at Async._drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:143:10)
       at Immediate.Async.drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:17:14)
     code: 'ER_CANNOT_ADD_FOREIGN',
     errno: 1215,
     sqlState: 'HY000',
     index: 0,
     sql: 'CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`), FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE) ENGINE=InnoDB;' },
  original: 
   { Error: ER_CANNOT_ADD_FOREIGN: Cannot add foreign key constraint
       at Query.Sequence._packetToError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:52:14)
       at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:77:18)
       at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
       at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
       at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
       at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
       at emitOne (events.js:96:13)
       at Socket.emit (events.js:191:7)
       at readableAddChunk (_stream_readable.js:178:18)
       at Socket.Readable.push (_stream_readable.js:136:10)
       at TCP.onread (net.js:560:20)
       --------------------
       at Protocol._enqueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:141:48)
       at Connection.query (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:208:25)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at Query.run (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:39:17)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:849:20
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at retryAsPromised (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:30:10)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:848:12
       at tryCatcher (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/util.js:16:23)
       at Promise._settlePromiseFromHandler (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:512:31)
       at Promise._settlePromise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:569:18)
       at Promise._settlePromise0 (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:614:10)
       at Promise._settlePromises (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:693:18)
       at Async._drainQueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:133:16)
       at Async._drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:143:10)
       at Immediate.Async.drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:17:14)
     code: 'ER_CANNOT_ADD_FOREIGN',
     errno: 1215,
     sqlState: 'HY000',
     index: 0,
     sql: 'CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`), FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE) ENGINE=InnoDB;' },
  sql: 'CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`), FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE) ENGINE=InnoDB;' }
[2017-05-05 17:44:18.601] [ERROR] console - (node:29822) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): AssertionError: status code must be a number
[2017-05-05 17:44:18.601] [ERROR] console - (node:29822) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
[2017-05-05 17:44:50.602] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 17:44:50.663] [INFO] app - Redis client default is ready {}
[2017-05-05 17:44:50.690] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 17:44:50.696] [INFO] app - application is startup, listening on port 3000
[2017-05-05 17:45:07.131] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-05 17:45:07.197] [INFO] app - Redis client default is ready {}
[2017-05-05 17:45:07.221] [INFO] console - Executing (default): SELECT 1+1 AS result
[2017-05-05 17:45:07.227] [INFO] app - application is startup, listening on port 3000
[2017-05-05 17:45:08.586] [DEBUG] app - 2017-5-5 17:45:08 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 17:45:08.593] [WARN] console - this is a logger middleware.
[2017-05-05 17:45:08.602] [INFO] console - Executing (default): DROP TABLE IF EXISTS `users`;
[2017-05-05 17:45:08.608] [INFO] console - Executing (default): CREATE TABLE IF NOT EXISTS `users` (`id` INTEGER NOT NULL auto_increment , `companyName` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB;
[2017-05-05 17:45:08.630] [INFO] console - Executing (default): SHOW INDEX FROM `users`
[2017-05-05 17:45:08.635] [INFO] console - Executing (default): DROP TABLE IF EXISTS `user`;
[2017-05-05 17:45:08.640] [INFO] console - Executing (default): CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`), FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE) ENGINE=InnoDB;
[2017-05-05 17:45:08.664] [ERROR] app - { SequelizeBaseError: ER_CANNOT_ADD_FOREIGN: Cannot add foreign key constraint
    at Query.formatError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:175:14)
    at Query._callback (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:49:21)
    at Query.Sequence.end (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:86:24)
    at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:88:8)
    at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
    at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
    at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
    at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
    at emitOne (events.js:96:13)
    at Socket.emit (events.js:191:7)
    at readableAddChunk (_stream_readable.js:178:18)
    at Socket.Readable.push (_stream_readable.js:136:10)
    at TCP.onread (net.js:560:20)
  name: 'SequelizeDatabaseError',
  message: 'ER_CANNOT_ADD_FOREIGN: Cannot add foreign key constraint',
  parent: 
   { Error: ER_CANNOT_ADD_FOREIGN: Cannot add foreign key constraint
       at Query.Sequence._packetToError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:52:14)
       at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:77:18)
       at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
       at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
       at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
       at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
       at emitOne (events.js:96:13)
       at Socket.emit (events.js:191:7)
       at readableAddChunk (_stream_readable.js:178:18)
       at Socket.Readable.push (_stream_readable.js:136:10)
       at TCP.onread (net.js:560:20)
       --------------------
       at Protocol._enqueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:141:48)
       at Connection.query (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:208:25)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at Query.run (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:39:17)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:849:20
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at retryAsPromised (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:30:10)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:848:12
       at tryCatcher (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/util.js:16:23)
       at Promise._settlePromiseFromHandler (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:512:31)
       at Promise._settlePromise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:569:18)
       at Promise._settlePromise0 (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:614:10)
       at Promise._settlePromises (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:693:18)
       at Async._drainQueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:133:16)
       at Async._drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:143:10)
       at Immediate.Async.drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:17:14)
     code: 'ER_CANNOT_ADD_FOREIGN',
     errno: 1215,
     sqlState: 'HY000',
     index: 0,
     sql: 'CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`), FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE) ENGINE=InnoDB;' },
  original: 
   { Error: ER_CANNOT_ADD_FOREIGN: Cannot add foreign key constraint
       at Query.Sequence._packetToError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:52:14)
       at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:77:18)
       at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
       at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
       at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
       at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
       at emitOne (events.js:96:13)
       at Socket.emit (events.js:191:7)
       at readableAddChunk (_stream_readable.js:178:18)
       at Socket.Readable.push (_stream_readable.js:136:10)
       at TCP.onread (net.js:560:20)
       --------------------
       at Protocol._enqueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:141:48)
       at Connection.query (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:208:25)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at Query.run (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:39:17)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:849:20
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at retryAsPromised (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:30:10)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:848:12
       at tryCatcher (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/util.js:16:23)
       at Promise._settlePromiseFromHandler (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:512:31)
       at Promise._settlePromise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:569:18)
       at Promise._settlePromise0 (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:614:10)
       at Promise._settlePromises (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:693:18)
       at Async._drainQueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:133:16)
       at Async._drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:143:10)
       at Immediate.Async.drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:17:14)
     code: 'ER_CANNOT_ADD_FOREIGN',
     errno: 1215,
     sqlState: 'HY000',
     index: 0,
     sql: 'CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`), FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE) ENGINE=InnoDB;' },
  sql: 'CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`), FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE) ENGINE=InnoDB;' }
[2017-05-05 17:45:08.680] [ERROR] console - (node:29878) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): AssertionError: status code must be a number
[2017-05-05 17:45:08.680] [ERROR] console - (node:29878) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
[2017-05-05 17:47:08.604] [DEBUG] app - 2017-5-5 17:47:08 ::1 -- GET /api/user/111 HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
[2017-05-05 17:47:08.605] [WARN] console - this is a logger middleware.
[2017-05-05 17:47:08.612] [INFO] console - Executing (default): DROP TABLE IF EXISTS `users`;
[2017-05-05 17:47:08.619] [INFO] console - Executing (default): CREATE TABLE IF NOT EXISTS `users` (`id` INTEGER NOT NULL auto_increment , `companyName` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB;
[2017-05-05 17:47:08.635] [INFO] console - Executing (default): SHOW INDEX FROM `users`
[2017-05-05 17:47:08.639] [INFO] console - Executing (default): DROP TABLE IF EXISTS `user`;
[2017-05-05 17:47:08.641] [INFO] console - Executing (default): CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`), FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE) ENGINE=InnoDB;
[2017-05-05 17:47:08.658] [ERROR] app - { SequelizeBaseError: ER_CANNOT_ADD_FOREIGN: Cannot add foreign key constraint
    at Query.formatError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:175:14)
    at Query._callback (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:49:21)
    at Query.Sequence.end (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:86:24)
    at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:88:8)
    at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
    at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
    at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
    at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
    at emitOne (events.js:96:13)
    at Socket.emit (events.js:191:7)
    at readableAddChunk (_stream_readable.js:178:18)
    at Socket.Readable.push (_stream_readable.js:136:10)
    at TCP.onread (net.js:560:20)
  name: 'SequelizeDatabaseError',
  message: 'ER_CANNOT_ADD_FOREIGN: Cannot add foreign key constraint',
  parent: 
   { Error: ER_CANNOT_ADD_FOREIGN: Cannot add foreign key constraint
       at Query.Sequence._packetToError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:52:14)
       at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:77:18)
       at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
       at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
       at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
       at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
       at emitOne (events.js:96:13)
       at Socket.emit (events.js:191:7)
       at readableAddChunk (_stream_readable.js:178:18)
       at Socket.Readable.push (_stream_readable.js:136:10)
       at TCP.onread (net.js:560:20)
       --------------------
       at Protocol._enqueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:141:48)
       at Connection.query (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:208:25)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at Query.run (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:39:17)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:849:20
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at retryAsPromised (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:30:10)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:848:12
       at tryCatcher (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/util.js:16:23)
       at Promise._settlePromiseFromHandler (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:512:31)
       at Promise._settlePromise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:569:18)
       at Promise._settlePromise0 (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:614:10)
       at Promise._settlePromises (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:693:18)
       at Async._drainQueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:133:16)
       at Async._drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:143:10)
       at Immediate.Async.drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:17:14)
     code: 'ER_CANNOT_ADD_FOREIGN',
     errno: 1215,
     sqlState: 'HY000',
     index: 0,
     sql: 'CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`), FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE) ENGINE=InnoDB;' },
  original: 
   { Error: ER_CANNOT_ADD_FOREIGN: Cannot add foreign key constraint
       at Query.Sequence._packetToError (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Sequence.js:52:14)
       at Query.ErrorPacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/sequences/Query.js:77:18)
       at Protocol._parsePacket (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:280:23)
       at Parser.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Parser.js:75:12)
       at Protocol.write (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:39:16)
       at Socket.<anonymous> (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:103:28)
       at emitOne (events.js:96:13)
       at Socket.emit (events.js:191:7)
       at readableAddChunk (_stream_readable.js:178:18)
       at Socket.Readable.push (_stream_readable.js:136:10)
       at TCP.onread (net.js:560:20)
       --------------------
       at Protocol._enqueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/protocol/Protocol.js:141:48)
       at Connection.query (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/mysql/lib/Connection.js:208:25)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at Query.run (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/dialects/mysql/query.js:39:17)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:849:20
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:40:21
       at Promise._execute (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/debuggability.js:300:9)
       at Promise._resolveFromExecutor (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:483:18)
       at new Promise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:79:10)
       at retryAsPromised (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/retry-as-promised/index.js:30:10)
       at /Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/sequelize/lib/sequelize.js:848:12
       at tryCatcher (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/util.js:16:23)
       at Promise._settlePromiseFromHandler (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:512:31)
       at Promise._settlePromise (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:569:18)
       at Promise._settlePromise0 (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:614:10)
       at Promise._settlePromises (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/promise.js:693:18)
       at Async._drainQueue (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:133:16)
       at Async._drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:143:10)
       at Immediate.Async.drainQueues (/Users/rick_lee/dev/codebase/node-webapp-scaffolding/node_modules/bluebird/js/release/async.js:17:14)
     code: 'ER_CANNOT_ADD_FOREIGN',
     errno: 1215,
     sqlState: 'HY000',
     index: 0,
     sql: 'CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`), FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE) ENGINE=InnoDB;' },
  sql: 'CREATE TABLE IF NOT EXISTS `user` (`id` INTEGER NOT NULL auto_increment , `first_name` VARCHAR(255), `user_id` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`), FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE) ENGINE=InnoDB;' }
[2017-05-05 17:47:08.662] [ERROR] console - (node:29878) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 2): AssertionError: status code must be a number
[2017-05-10 16:55:03.084] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 16:55:03.101] [INFO] app - Redis client default is ready {}
[2017-05-10 16:55:03.106] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 16:55:03.112] [INFO] app - application is startup, listening on port 3000
[2017-05-10 16:55:15.581] [DEBUG] app - 2017-5-10 16:55:15 ::1 -- GET / HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36
[2017-05-10 16:55:15.595] [ERROR] app - { [NotFoundError: Not Found]
  restCode: null,
  statusCode: 404,
  message: 'Not Found',
  constructorOpt: undefined,
  name: 'NotFoundError',
  expose: true,
  status: 404 }
[2017-05-10 16:55:15.666] [DEBUG] app - 2017-5-10 16:55:15 ::1 -- GET /favicon.ico HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36
[2017-05-10 16:55:15.667] [ERROR] app - { [NotFoundError: Not Found]
  restCode: null,
  statusCode: 404,
  message: 'Not Found',
  constructorOpt: undefined,
  name: 'NotFoundError',
  expose: true,
  status: 404 }
[2017-05-10 16:55:16.582] [DEBUG] app - 2017-5-10 16:55:16 ::1 -- GET / HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36
[2017-05-10 16:55:16.582] [ERROR] app - { [NotFoundError: Not Found]
  restCode: null,
  statusCode: 404,
  message: 'Not Found',
  constructorOpt: undefined,
  name: 'NotFoundError',
  expose: true,
  status: 404 }
[2017-05-10 16:55:32.060] [DEBUG] app - 2017-5-10 16:55:32 ::1 -- GET /user HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36
[2017-05-10 16:55:32.061] [ERROR] app - { [NotFoundError: Not Found]
  restCode: null,
  statusCode: 404,
  message: 'Not Found',
  constructorOpt: undefined,
  name: 'NotFoundError',
  expose: true,
  status: 404 }
[2017-05-10 16:55:34.223] [DEBUG] app - 2017-5-10 16:55:34 ::1 -- GET /order HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36
[2017-05-10 16:55:34.223] [ERROR] app - { [NotFoundError: Not Found]
  restCode: null,
  statusCode: 404,
  message: 'Not Found',
  constructorOpt: undefined,
  name: 'NotFoundError',
  expose: true,
  status: 404 }
[2017-05-10 16:56:09.177] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 16:56:09.194] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 16:56:09.197] [INFO] app - Redis client default is ready {}
[2017-05-10 16:56:09.200] [INFO] app - application is startup, listening on port 3000
[2017-05-10 16:56:11.529] [DEBUG] app - 2017-5-10 16:56:11 ::1 -- GET /order HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36
[2017-05-10 16:56:11.533] [WARN] console - this is a logger middleware.
[2017-05-10 16:56:11.533] [WARN] console - ok
[2017-05-10 16:56:20.504] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 16:56:20.515] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 16:56:20.518] [INFO] app - Redis client default is ready {}
[2017-05-10 16:56:20.522] [INFO] app - application is startup, listening on port 3000
[2017-05-10 16:56:22.281] [DEBUG] app - 2017-5-10 16:56:22 ::1 -- GET /order HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36
[2017-05-10 16:56:22.286] [WARN] console - this is a logger middleware.
[2017-05-10 16:56:22.286] [WARN] console - ok
[2017-05-10 16:56:22.288] [ERROR] app - TypeError: Cannot set property 'body' of undefined
    at /Users/rick_lee/dev/codebase/superclick/src/routes/order.js:11:5
    at dispatch (/Users/rick_lee/dev/codebase/superclick/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/superclick/node_modules/koa-compose/index.js:45:18)
    at /Users/rick_lee/dev/codebase/superclick/node_modules/koa-router/lib/router.js:326:16
    at dispatch (/Users/rick_lee/dev/codebase/superclick/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/superclick/node_modules/koa-compose/index.js:45:18)
    at _callee$ (/Users/rick_lee/dev/codebase/superclick/src/middlewares/logger.js:3:9)
    at tryCatch (/Users/rick_lee/dev/codebase/superclick/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/superclick/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/superclick/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/superclick/src/middlewares/logger.js:7:191)
    at /Users/rick_lee/dev/codebase/superclick/src/middlewares/logger.js:7:437
    at /Users/rick_lee/dev/codebase/superclick/src/middlewares/logger.js:7:99
    at logger (/Users/rick_lee/dev/codebase/superclick/src/middlewares/logger.js:28:17)
    at dispatch (/Users/rick_lee/dev/codebase/superclick/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/superclick/node_modules/koa-compose/index.js:45:18)
    at /Users/rick_lee/dev/codebase/superclick/node_modules/koa-router/lib/router.js:326:16
    at dispatch (/Users/rick_lee/dev/codebase/superclick/node_modules/koa-compose/index.js:44:32)
    at /Users/rick_lee/dev/codebase/superclick/node_modules/koa-compose/index.js:36:12
    at dispatch (/Users/rick_lee/dev/codebase/superclick/node_modules/koa-router/lib/router.js:331:31)
    at dispatch (/Users/rick_lee/dev/codebase/superclick/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/superclick/node_modules/koa-compose/index.js:45:18)
    at createGenerator (/Users/rick_lee/dev/codebase/superclick/node_modules/koa-convert/index.js:24:16)
    at createGenerator.next (<anonymous>)
    at onFulfilled (/Users/rick_lee/dev/codebase/superclick/node_modules/co/index.js:65:19)
    at /Users/rick_lee/dev/codebase/superclick/node_modules/co/index.js:54:5
    at Object.co (/Users/rick_lee/dev/codebase/superclick/node_modules/co/index.js:50:10)
    at Object.toPromise (/Users/rick_lee/dev/codebase/superclick/node_modules/co/index.js:118:63)
[2017-05-10 16:56:22.300] [ERROR] console - (node:72753) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 2): AssertionError: status code must be a number
[2017-05-10 16:56:22.300] [ERROR] console - (node:72753) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
[2017-05-10 16:56:23.914] [DEBUG] app - 2017-5-10 16:56:23 ::1 -- GET /order HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36
[2017-05-10 16:56:23.914] [WARN] console - this is a logger middleware.
[2017-05-10 16:56:23.915] [WARN] console - ok
[2017-05-10 16:56:23.915] [ERROR] app - TypeError: Cannot set property 'body' of undefined
    at /Users/rick_lee/dev/codebase/superclick/src/routes/order.js:11:5
    at dispatch (/Users/rick_lee/dev/codebase/superclick/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/superclick/node_modules/koa-compose/index.js:45:18)
    at /Users/rick_lee/dev/codebase/superclick/node_modules/koa-router/lib/router.js:326:16
    at dispatch (/Users/rick_lee/dev/codebase/superclick/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/superclick/node_modules/koa-compose/index.js:45:18)
    at _callee$ (/Users/rick_lee/dev/codebase/superclick/src/middlewares/logger.js:3:9)
    at tryCatch (/Users/rick_lee/dev/codebase/superclick/node_modules/regenerator-runtime/runtime.js:65:40)
    at Generator.invoke [as _invoke] (/Users/rick_lee/dev/codebase/superclick/node_modules/regenerator-runtime/runtime.js:303:22)
    at Generator.prototype.(anonymous function) [as next] (/Users/rick_lee/dev/codebase/superclick/node_modules/regenerator-runtime/runtime.js:117:21)
    at step (/Users/rick_lee/dev/codebase/superclick/src/middlewares/logger.js:7:191)
    at /Users/rick_lee/dev/codebase/superclick/src/middlewares/logger.js:7:437
    at /Users/rick_lee/dev/codebase/superclick/src/middlewares/logger.js:7:99
    at logger (/Users/rick_lee/dev/codebase/superclick/src/middlewares/logger.js:28:17)
    at dispatch (/Users/rick_lee/dev/codebase/superclick/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/superclick/node_modules/koa-compose/index.js:45:18)
    at /Users/rick_lee/dev/codebase/superclick/node_modules/koa-router/lib/router.js:326:16
    at dispatch (/Users/rick_lee/dev/codebase/superclick/node_modules/koa-compose/index.js:44:32)
    at /Users/rick_lee/dev/codebase/superclick/node_modules/koa-compose/index.js:36:12
    at dispatch (/Users/rick_lee/dev/codebase/superclick/node_modules/koa-router/lib/router.js:331:31)
    at dispatch (/Users/rick_lee/dev/codebase/superclick/node_modules/koa-compose/index.js:44:32)
    at next (/Users/rick_lee/dev/codebase/superclick/node_modules/koa-compose/index.js:45:18)
    at createGenerator (/Users/rick_lee/dev/codebase/superclick/node_modules/koa-convert/index.js:24:16)
    at createGenerator.next (<anonymous>)
    at onFulfilled (/Users/rick_lee/dev/codebase/superclick/node_modules/co/index.js:65:19)
    at /Users/rick_lee/dev/codebase/superclick/node_modules/co/index.js:54:5
    at Object.co (/Users/rick_lee/dev/codebase/superclick/node_modules/co/index.js:50:10)
    at Object.toPromise (/Users/rick_lee/dev/codebase/superclick/node_modules/co/index.js:118:63)
[2017-05-10 16:56:23.916] [ERROR] console - (node:72753) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 4): AssertionError: status code must be a number
[2017-05-10 16:56:35.452] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 16:56:35.465] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 16:56:35.467] [INFO] app - Redis client default is ready {}
[2017-05-10 16:56:35.471] [INFO] app - application is startup, listening on port 3000
[2017-05-10 16:56:37.026] [DEBUG] app - 2017-5-10 16:56:37 ::1 -- GET /order HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36
[2017-05-10 16:56:37.031] [WARN] console - this is a logger middleware.
[2017-05-10 16:56:37.032] [WARN] console - ok
[2017-05-10 16:57:50.946] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 16:57:50.960] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 16:57:50.962] [INFO] app - Redis client default is ready {}
[2017-05-10 16:57:50.967] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:00:17.510] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:00:17.530] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:00:17.533] [INFO] app - Redis client default is ready {}
[2017-05-10 17:00:17.536] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:00:20.978] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:00:20.989] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:00:20.993] [INFO] app - Redis client default is ready {}
[2017-05-10 17:00:20.996] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:00:23.072] [DEBUG] app - 2017-5-10 17:00:23 ::1 -- GET /order HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36
[2017-05-10 17:00:23.079] [WARN] console - this is a logger middleware.
[2017-05-10 17:00:23.083] [WARN] console - { errors: 
   { BadRequestError: { [Function: BadRequestError] super_: [Object] },
     UnauthorizedError: { [Function: UnauthorizedError] super_: [Object] },
     PaymentRequiredError: { [Function: PaymentRequiredError] super_: [Object] },
     ForbiddenError: { [Function: ForbiddenError] super_: [Object] },
     NotFoundError: { [Function: NotFoundError] super_: [Object] },
     MethodNotAllowedError: { [Function: MethodNotAllowedError] super_: [Object] },
     NotAcceptableError: { [Function: NotAcceptableError] super_: [Object] },
     ProxyAuthenticationRequiredError: { [Function: ProxyAuthenticationRequiredError] super_: [Object] },
     RequestTimeoutError: { [Function: RequestTimeoutError] super_: [Object] },
     ConflictError: { [Function: ConflictError] super_: [Object] },
     GoneError: { [Function: GoneError] super_: [Object] },
     LengthRequiredError: { [Function: LengthRequiredError] super_: [Object] },
     PreconditionFailedError: { [Function: PreconditionFailedError] super_: [Object] },
     RequestEntityTooLargeError: { [Function: RequestEntityTooLargeError] super_: [Object] },
     RequesturiTooLargeError: { [Function: RequesturiTooLargeError] super_: [Object] },
     UnsupportedMediaTypeError: { [Function: UnsupportedMediaTypeError] super_: [Object] },
     RequestedRangeNotSatisfiableError: { [Function: RequestedRangeNotSatisfiableError] super_: [Object] },
     ExpectationFailedError: { [Function: ExpectationFailedError] super_: [Object] },
     ImATeapotError: { [Function: ImATeapotError] super_: [Object] },
     UnprocessableEntityError: { [Function: UnprocessableEntityError] super_: [Object] },
     LockedError: { [Function: LockedError] super_: [Object] },
     FailedDependencyError: { [Function: FailedDependencyError] super_: [Object] },
     UnorderedCollectionError: { [Function: UnorderedCollectionError] super_: [Object] },
     UpgradeRequiredError: { [Function: UpgradeRequiredError] super_: [Object] },
     PreconditionRequiredError: { [Function: PreconditionRequiredError] super_: [Object] },
     TooManyRequestsError: { [Function: TooManyRequestsError] super_: [Object] },
     RequestHeaderFieldsTooLargeError: { [Function: RequestHeaderFieldsTooLargeError] super_: [Object] },
     InternalServerError: { [Function: InternalServerError] super_: [Object] },
     NotImplementedError: { [Function: NotImplementedError] super_: [Object] },
     BadGatewayError: { [Function: BadGatewayError] super_: [Object] },
     ServiceUnavailableError: { [Function: ServiceUnavailableError] super_: [Object] },
     GatewayTimeoutError: { [Function: GatewayTimeoutError] super_: [Object] },
     HttpVersionNotSupportedError: { [Function: HttpVersionNotSupportedError] super_: [Object] },
     VariantAlsoNegotiatesError: { [Function: VariantAlsoNegotiatesError] super_: [Object] },
     InsufficientStorageError: { [Function: InsufficientStorageError] super_: [Object] },
     BandwidthLimitExceededError: { [Function: BandwidthLimitExceededError] super_: [Object] },
     NotExtendedError: { [Function: NotExtendedError] super_: [Object] },
     NetworkAuthenticationRequiredError: { [Function: NetworkAuthenticationRequiredError] super_: [Object] },
     BadDigestError: { [Function: BadDigestError] super_: [Object] },
     BadMethodError: { [Function: BadMethodError] super_: [Object] },
     InternalError: { [Function: InternalError] super_: [Object] },
     InvalidArgumentError: { [Function: InvalidArgumentError] super_: [Object] },
     InvalidContentError: { [Function: InvalidContentError] super_: [Object] },
     InvalidCredentialsError: { [Function: InvalidCredentialsError] super_: [Object] },
     InvalidHeaderError: { [Function: InvalidHeaderError] super_: [Object] },
     MissingParameterError: { [Function: MissingParameterError] super_: [Object] },
     NotAuthorizedError: { [Function: NotAuthorizedError] super_: [Object] },
     RequestExpiredError: { [Function: RequestExpiredError] super_: [Object] },
     RequestThrottledError: { [Function: RequestThrottledError] super_: [Object] },
     WrongAcceptError: { [Function: WrongAcceptError] super_: [Object] } },
  redis: 
   { main: 
      RedisClient {
        domain: null,
        _events: [Object],
        _eventsCount: 6,
        _maxListeners: undefined,
        address: '127.0.0.1:6379',
        connection_options: [Object],
        connection_id: 0,
        connected: true,
        ready: true,
        should_buffer: false,
        max_attempts: 0,
        command_queue: [Object],
        offline_queue: [Object],
        pipeline_queue: [Object],
        connect_timeout: 3600000,
        enable_offline_queue: true,
        retry_max_delay: null,
        retry_timer: null,
        retry_totaltime: 0,
        retry_delay: 200,
        retry_backoff: 1.7,
        attempts: 1,
        pub_sub_mode: 0,
        subscription_set: {},
        monitoring: false,
        message_buffers: false,
        closing: false,
        server_info: [Object],
        auth_pass: undefined,
        selected_db: undefined,
        old_state: null,
        fire_strings: true,
        pipeline: false,
        sub_commands_left: 0,
        times_connected: 1,
        buffers: false,
        options: [Object],
        reply: 'ON',
        reply_parser: [Object],
        stream: [Object],
        emitted_end: false,
        cork: [Function],
        uncork: [Function] } },
  db: 
   { main: 
      Mongoose {
        connections: [Object],
        plugins: [],
        models: [Object],
        modelSchemas: [Object],
        options: [Object] } },
  mongoose: 
   { main: 
      Mongoose {
        connections: [Object],
        plugins: [],
        models: [Object],
        modelSchemas: [Object],
        options: [Object] } },
  controllers: 
   { userController: UserController {},
     mainController: MainController {} },
  services: { UserService: [Function] },
  models: 
   { User: 
      { [Function: model]
        hooks: [Object],
        base: [Object],
        modelName: 'User',
        model: [Function: model],
        db: [Object],
        discriminators: undefined,
        schema: [Object],
        collection: [Object],
        Query: [Object],
        '$__insertMany': [Function],
        insertMany: [Function] } },
  kvs: { UserKv: [Function] },
  logger: 
   Logger {
     category: 'app',
     _events: { log: [Object] },
     _eventsCount: 1,
     level: Level { level: 10000, levelStr: 'DEBUG' } } }
[2017-05-10 17:01:10.307] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:01:10.346] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:01:10.349] [INFO] app - Redis client default is ready {}
[2017-05-10 17:01:10.353] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:01:21.885] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:01:21.897] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:01:21.899] [INFO] app - Redis client default is ready {}
[2017-05-10 17:01:21.903] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:01:36.602] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:01:36.615] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:01:36.618] [INFO] app - Redis client default is ready {}
[2017-05-10 17:01:36.621] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:01:45.091] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:01:45.107] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:01:45.110] [INFO] app - Redis client default is ready {}
[2017-05-10 17:01:45.113] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:01:56.070] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:01:56.082] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:01:56.084] [INFO] app - Redis client default is ready {}
[2017-05-10 17:01:56.087] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:01:58.268] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:01:58.278] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:01:58.281] [INFO] app - Redis client default is ready {}
[2017-05-10 17:01:58.284] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:02:20.511] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:02:20.524] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:02:20.527] [INFO] app - Redis client default is ready {}
[2017-05-10 17:02:20.530] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:02:22.350] [DEBUG] app - 2017-5-10 17:02:22 ::1 -- GET /order HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36
[2017-05-10 17:02:22.355] [WARN] console - this is a logger middleware.
[2017-05-10 17:02:22.356] [WARN] console - undefined
[2017-05-10 17:02:29.015] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:02:29.028] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:02:29.031] [INFO] app - Redis client default is ready {}
[2017-05-10 17:02:29.035] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:02:30.195] [DEBUG] app - 2017-5-10 17:02:30 ::1 -- GET /order HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36
[2017-05-10 17:02:30.201] [WARN] console - this is a logger middleware.
[2017-05-10 17:02:30.201] [WARN] console - { userController: UserController {},
  mainController: MainController {} }
[2017-05-10 17:02:54.240] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:02:54.249] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:02:54.252] [INFO] app - Redis client default is ready {}
[2017-05-10 17:02:54.255] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:02:56.069] [DEBUG] app - 2017-5-10 17:02:56 ::1 -- GET /order HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36
[2017-05-10 17:02:56.075] [WARN] console - this is a logger middleware.
[2017-05-10 17:02:56.076] [WARN] console - { userController: UserController {},
  orderController: OrderController {} }
[2017-05-10 17:03:46.890] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:03:46.915] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:03:46.923] [INFO] app - Redis client default is ready {}
[2017-05-10 17:03:46.929] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:03:48.992] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:03:49.005] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:03:49.008] [INFO] app - Redis client default is ready {}
[2017-05-10 17:03:49.012] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:03:50.514] [DEBUG] app - 2017-5-10 17:03:50 ::1 -- GET /order HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36
[2017-05-10 17:03:50.517] [WARN] console - this is a logger middleware.
[2017-05-10 17:04:24.281] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:04:24.292] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:04:24.296] [INFO] app - Redis client default is ready {}
[2017-05-10 17:04:24.299] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:05:52.639] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:05:52.650] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:05:52.653] [INFO] app - Redis client default is ready {}
[2017-05-10 17:05:52.657] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:06:03.587] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:06:03.599] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:06:03.602] [INFO] app - Redis client default is ready {}
[2017-05-10 17:06:03.606] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:06:12.269] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:06:12.288] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:06:12.291] [INFO] app - Redis client default is ready {}
[2017-05-10 17:06:12.294] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:06:46.180] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:06:46.191] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:06:46.194] [INFO] app - Redis client default is ready {}
[2017-05-10 17:06:46.197] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:06:50.900] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:06:50.911] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:06:50.914] [INFO] app - Redis client default is ready {}
[2017-05-10 17:06:50.917] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:06:52.674] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:06:52.686] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:06:52.688] [INFO] app - Redis client default is ready {}
[2017-05-10 17:06:52.691] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:07:24.110] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:07:24.121] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:07:24.124] [INFO] app - Redis client default is ready {}
[2017-05-10 17:07:24.127] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:14:17.600] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:14:17.621] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:14:17.627] [INFO] app - Redis client default is ready {}
[2017-05-10 17:14:17.632] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:15:41.808] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:15:41.818] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:15:41.821] [INFO] app - Redis client default is ready {}
[2017-05-10 17:15:41.824] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:16:07.767] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:16:07.782] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:16:07.784] [INFO] app - Redis client default is ready {}
[2017-05-10 17:16:07.787] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:16:26.735] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:16:26.749] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:16:26.752] [INFO] app - Redis client default is ready {}
[2017-05-10 17:16:26.756] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:18:02.680] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:18:02.692] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:18:02.695] [INFO] app - Redis client default is ready {}
[2017-05-10 17:18:02.702] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:18:26.473] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:18:26.484] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:18:26.487] [INFO] app - Redis client default is ready {}
[2017-05-10 17:18:26.491] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:18:34.484] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:18:34.495] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:18:34.498] [INFO] app - Redis client default is ready {}
[2017-05-10 17:18:34.501] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:18:47.142] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:18:47.155] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:18:47.158] [INFO] app - Redis client default is ready {}
[2017-05-10 17:18:47.163] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:21:15.364] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:21:15.380] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:21:15.383] [INFO] app - Redis client default is ready {}
[2017-05-10 17:21:15.387] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:21:32.206] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:21:32.216] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:21:32.220] [INFO] app - Redis client default is ready {}
[2017-05-10 17:21:32.223] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:21:47.616] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:21:47.628] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:21:47.632] [INFO] app - Redis client default is ready {}
[2017-05-10 17:21:47.636] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:21:50.882] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:21:50.894] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:21:50.897] [INFO] app - Redis client default is ready {}
[2017-05-10 17:21:50.902] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:22:18.529] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:22:18.543] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:22:18.547] [INFO] app - Redis client default is ready {}
[2017-05-10 17:22:18.550] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:22:55.746] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:22:55.763] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:22:55.767] [INFO] app - Redis client default is ready {}
[2017-05-10 17:22:55.773] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:23:16.058] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:23:16.069] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:23:16.072] [INFO] app - Redis client default is ready {}
[2017-05-10 17:23:16.075] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:24:04.276] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:24:04.289] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:24:04.292] [INFO] app - Redis client default is ready {}
[2017-05-10 17:24:04.295] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:27:20.307] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:27:20.325] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:27:20.328] [INFO] app - Redis client default is ready {}
[2017-05-10 17:27:20.332] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:28:13.309] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:28:13.325] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:28:13.328] [INFO] app - Redis client default is ready {}
[2017-05-10 17:28:13.331] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:28:56.495] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:28:56.508] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:28:56.512] [INFO] app - Redis client default is ready {}
[2017-05-10 17:28:56.517] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:29:02.392] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:29:02.404] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:29:02.406] [INFO] app - Redis client default is ready {}
[2017-05-10 17:29:02.410] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:29:51.815] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:29:51.828] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:29:51.831] [INFO] app - Redis client default is ready {}
[2017-05-10 17:29:51.834] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:34:42.973] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:34:42.983] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:34:42.988] [INFO] app - Redis client default is ready {}
[2017-05-10 17:34:42.994] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:34:53.674] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:34:53.687] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:34:53.690] [INFO] app - Redis client default is ready {}
[2017-05-10 17:34:53.694] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:35:45.304] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:35:45.329] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:35:45.335] [INFO] app - Redis client default is ready {}
[2017-05-10 17:35:45.339] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:39:05.554] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:39:05.584] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:39:05.591] [INFO] app - Redis client default is ready {}
[2017-05-10 17:39:05.599] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:45:38.025] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:45:38.043] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:45:38.049] [INFO] app - Redis client default is ready {}
[2017-05-10 17:45:38.052] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:47:16.151] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:47:16.166] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:47:16.169] [INFO] app - Redis client default is ready {}
[2017-05-10 17:47:16.174] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:52:30.540] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:52:30.561] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:52:30.564] [INFO] app - Redis client default is ready {}
[2017-05-10 17:52:30.568] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:52:43.095] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:52:43.109] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:52:43.113] [INFO] app - Redis client default is ready {}
[2017-05-10 17:52:43.117] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:53:14.722] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:53:14.732] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:53:14.735] [INFO] app - Redis client default is ready {}
[2017-05-10 17:53:14.738] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:53:30.312] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:53:30.324] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:53:30.327] [INFO] app - Redis client default is ready {}
[2017-05-10 17:53:30.331] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:56:38.840] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:56:38.851] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:56:38.854] [INFO] app - Redis client default is ready {}
[2017-05-10 17:56:38.858] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:59:21.999] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:59:22.012] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:59:22.016] [INFO] app - Redis client default is ready {}
[2017-05-10 17:59:22.021] [INFO] app - application is startup, listening on port 3000
[2017-05-10 17:59:40.999] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 17:59:41.009] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 17:59:41.011] [INFO] app - Redis client default is ready {}
[2017-05-10 17:59:41.014] [INFO] app - application is startup, listening on port 3000
[2017-05-10 18:02:38.394] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 18:02:38.405] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 18:02:38.408] [INFO] app - Redis client default is ready {}
[2017-05-10 18:02:38.411] [INFO] app - application is startup, listening on port 3000
[2017-05-10 18:06:16.128] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 18:06:16.141] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 18:06:16.144] [INFO] app - Redis client default is ready {}
[2017-05-10 18:06:16.147] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:12:54.835] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:12:54.849] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:12:54.852] [INFO] app - Redis client default is ready {}
[2017-05-10 20:12:54.856] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:13:40.828] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:13:40.838] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:13:40.841] [INFO] app - Redis client default is ready {}
[2017-05-10 20:13:40.847] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:25:36.778] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:25:36.793] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:25:36.796] [INFO] app - Redis client default is ready {}
[2017-05-10 20:25:36.799] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:26:06.690] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:26:06.701] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:26:06.703] [INFO] app - Redis client default is ready {}
[2017-05-10 20:26:06.707] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:26:38.626] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:26:38.640] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:26:38.643] [INFO] app - Redis client default is ready {}
[2017-05-10 20:26:38.647] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:26:41.253] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:26:41.264] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:26:41.267] [INFO] app - Redis client default is ready {}
[2017-05-10 20:26:41.270] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:26:54.630] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:26:54.640] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:26:54.643] [INFO] app - Redis client default is ready {}
[2017-05-10 20:26:54.646] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:27:03.256] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:27:03.267] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:27:03.270] [INFO] app - Redis client default is ready {}
[2017-05-10 20:27:03.277] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:27:56.475] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:27:56.486] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:27:56.489] [INFO] app - Redis client default is ready {}
[2017-05-10 20:27:56.492] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:28:03.343] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:28:03.354] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:28:03.357] [INFO] app - Redis client default is ready {}
[2017-05-10 20:28:03.365] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:28:17.056] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:28:17.067] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:28:17.070] [INFO] app - Redis client default is ready {}
[2017-05-10 20:28:17.073] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:28:29.053] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:28:29.063] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:28:29.066] [INFO] app - Redis client default is ready {}
[2017-05-10 20:28:29.069] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:28:35.838] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:28:35.849] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:28:35.853] [INFO] app - Redis client default is ready {}
[2017-05-10 20:28:35.859] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:30:41.955] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:30:41.970] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:30:41.974] [INFO] app - Redis client default is ready {}
[2017-05-10 20:30:41.978] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:30:52.452] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:30:52.463] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:30:52.466] [INFO] app - Redis client default is ready {}
[2017-05-10 20:30:52.469] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:31:32.029] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:31:32.039] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:31:32.042] [INFO] app - Redis client default is ready {}
[2017-05-10 20:31:32.048] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:32:17.623] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:32:17.634] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:32:17.637] [INFO] app - Redis client default is ready {}
[2017-05-10 20:32:17.640] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:32:28.429] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:32:28.440] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:32:28.443] [INFO] app - Redis client default is ready {}
[2017-05-10 20:32:28.451] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:32:36.287] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:32:36.298] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:32:36.301] [INFO] app - Redis client default is ready {}
[2017-05-10 20:32:36.304] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:32:38.372] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:32:38.382] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:32:38.385] [INFO] app - Redis client default is ready {}
[2017-05-10 20:32:38.389] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:32:44.239] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:32:44.251] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:32:44.254] [INFO] app - Redis client default is ready {}
[2017-05-10 20:32:44.259] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:32:54.264] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:32:54.275] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:32:54.277] [INFO] app - Redis client default is ready {}
[2017-05-10 20:32:54.281] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:36:58.379] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:36:58.400] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:36:58.403] [INFO] app - Redis client default is ready {}
[2017-05-10 20:36:58.407] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:37:26.502] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:37:26.513] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:37:26.516] [INFO] app - Redis client default is ready {}
[2017-05-10 20:37:26.523] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:39:23.454] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:39:23.465] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:39:23.468] [INFO] app - Redis client default is ready {}
[2017-05-10 20:39:23.471] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:39:33.505] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:39:33.516] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:39:33.519] [INFO] app - Redis client default is ready {}
[2017-05-10 20:39:33.526] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:40:21.756] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:40:21.767] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:40:21.769] [INFO] app - Redis client default is ready {}
[2017-05-10 20:40:21.773] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:40:32.437] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:40:32.447] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:40:32.450] [INFO] app - Redis client default is ready {}
[2017-05-10 20:40:32.457] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:41:23.397] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:41:23.411] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:41:23.413] [INFO] app - Redis client default is ready {}
[2017-05-10 20:41:23.417] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:41:33.880] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:41:33.891] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:41:33.893] [INFO] app - Redis client default is ready {}
[2017-05-10 20:41:33.897] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:41:48.168] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:41:48.178] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:41:48.181] [INFO] app - Redis client default is ready {}
[2017-05-10 20:41:48.185] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:42:08.438] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:42:08.449] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:42:08.452] [INFO] app - Redis client default is ready {}
[2017-05-10 20:42:08.456] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:42:19.161] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:42:19.171] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:42:19.174] [INFO] app - Redis client default is ready {}
[2017-05-10 20:42:19.178] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:42:36.452] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:42:36.463] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:42:36.466] [INFO] app - Redis client default is ready {}
[2017-05-10 20:42:36.469] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:42:43.855] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:42:43.866] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:42:43.868] [INFO] app - Redis client default is ready {}
[2017-05-10 20:42:43.872] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:43:34.065] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:43:34.076] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:43:34.079] [INFO] app - Redis client default is ready {}
[2017-05-10 20:43:34.086] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:44:06.493] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:44:06.504] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:44:06.507] [INFO] app - Redis client default is ready {}
[2017-05-10 20:44:06.514] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:58:30.985] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:58:30.996] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:58:48.261] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-10 20:58:48.274] [INFO] console - Mongoose connected to mongodb://127.0.0.1:27017/wenode
[2017-05-10 20:58:48.277] [INFO] app - Redis client default is ready {}
[2017-05-10 20:58:48.280] [INFO] app - application is startup, listening on port 3000
[2017-05-10 20:58:51.150] [DEBUG] app - 2017-5-10 20:58:51 ::1 -- GET / HTTP/1.1, null Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36
[2017-05-10 20:58:51.155] [ERROR] app - { [NotFoundError: Not Found]
  restCode: null,
  statusCode: 404,
  message: 'Not Found',
  constructorOpt: undefined,
  name: 'NotFoundError',
  expose: true,
  status: 404 }
[2017-05-12 15:28:36.301] [WARN] console - ack!
[2017-05-12 15:28:36.307] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:28:36.316] [INFO] app - Redis client default is ready {}
[2017-05-12 15:28:39.410] [WARN] console - message ******** alive
[2017-05-12 15:28:42.412] [WARN] console - message ******** alive
[2017-05-12 15:29:23.093] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:29:23.101] [INFO] app - Redis client default is ready {}
[2017-05-12 15:29:23.113] [WARN] console - ack!
[2017-05-12 15:29:26.206] [WARN] console - message ******** alive
[2017-05-12 15:29:29.208] [WARN] console - message ******** alive
[2017-05-12 15:29:32.211] [WARN] console - message ******** alive
[2017-05-12 15:29:35.215] [WARN] console - message ******** alive
[2017-05-12 15:29:38.217] [WARN] console - message ******** alive
[2017-05-12 15:29:41.219] [WARN] console - message ******** alive
[2017-05-12 15:29:44.222] [WARN] console - message ******** alive
[2017-05-12 15:29:47.225] [WARN] console - message ******** alive
[2017-05-12 15:29:50.228] [WARN] console - message ******** alive
[2017-05-12 15:29:53.229] [WARN] console - message ******** alive
[2017-05-12 15:29:56.230] [WARN] console - message ******** alive
[2017-05-12 15:29:59.232] [WARN] console - message ******** alive
[2017-05-12 15:30:02.233] [WARN] console - message ******** alive
[2017-05-12 15:30:05.234] [WARN] console - message ******** alive
[2017-05-12 15:30:08.236] [WARN] console - message ******** alive
[2017-05-12 15:30:11.241] [WARN] console - message ******** alive
[2017-05-12 15:30:14.244] [WARN] console - message ******** alive
[2017-05-12 15:30:17.246] [WARN] console - message ******** alive
[2017-05-12 15:30:20.015] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:30:20.024] [INFO] app - Redis client default is ready {}
[2017-05-12 15:30:20.030] [WARN] console - Worker {
  domain: null,
  _events: {},
  _eventsCount: 0,
  _maxListeners: undefined,
  router: 
   doRoute {
     routeMap: { 'rush-concert': [Object], 'register-doctor': [Object] } },
  status: 'IDLE' }
[2017-05-12 15:30:20.039] [WARN] console - ack!
[2017-05-12 15:30:23.139] [WARN] console - message ******** alive
[2017-05-12 15:30:26.142] [WARN] console - message ******** alive
[2017-05-12 15:30:29.147] [WARN] console - message ******** alive
[2017-05-12 15:30:32.148] [WARN] console - message ******** alive
[2017-05-12 15:30:35.149] [WARN] console - message ******** alive
[2017-05-12 15:30:38.154] [WARN] console - message ******** alive
[2017-05-12 15:30:41.155] [WARN] console - message ******** alive
[2017-05-12 15:30:44.157] [WARN] console - message ******** alive
[2017-05-12 15:30:47.162] [WARN] console - message ******** alive
[2017-05-12 15:30:50.167] [WARN] console - message ******** alive
[2017-05-12 15:30:53.171] [WARN] console - message ******** alive
[2017-05-12 15:30:56.172] [WARN] console - message ******** alive
[2017-05-12 15:30:59.175] [WARN] console - message ******** alive
[2017-05-12 15:31:02.177] [WARN] console - message ******** alive
[2017-05-12 15:31:05.181] [WARN] console - message ******** alive
[2017-05-12 15:31:08.184] [WARN] console - message ******** alive
[2017-05-12 15:31:11.189] [WARN] console - message ******** alive
[2017-05-12 15:31:14.190] [WARN] console - message ******** alive
[2017-05-12 15:31:17.194] [WARN] console - message ******** alive
[2017-05-12 15:31:20.198] [WARN] console - message ******** alive
[2017-05-12 15:31:23.203] [WARN] console - message ******** alive
[2017-05-12 15:31:26.208] [WARN] console - message ******** alive
[2017-05-12 15:31:29.212] [WARN] console - message ******** alive
[2017-05-12 15:31:32.217] [WARN] console - message ******** alive
[2017-05-12 15:31:35.223] [WARN] console - message ******** alive
[2017-05-12 15:31:38.226] [WARN] console - message ******** alive
[2017-05-12 15:31:41.229] [WARN] console - message ******** alive
[2017-05-12 15:31:44.234] [WARN] console - message ******** alive
[2017-05-12 15:31:47.237] [WARN] console - message ******** alive
[2017-05-12 15:31:50.240] [WARN] console - message ******** alive
[2017-05-12 15:31:53.242] [WARN] console - message ******** alive
[2017-05-12 15:31:56.244] [WARN] console - message ******** alive
[2017-05-12 15:31:59.245] [WARN] console - message ******** alive
[2017-05-12 15:32:02.248] [WARN] console - message ******** alive
[2017-05-12 15:32:03.997] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:32:04.007] [INFO] app - Redis client default is ready {}
[2017-05-12 15:32:04.014] [WARN] console - Worker {
  domain: null,
  _events: {},
  _eventsCount: 0,
  _maxListeners: undefined,
  router: 
   doRoute {
     routeMap: { 'rush-concert': [Object], 'register-doctor': [Object] } },
  status: 'IDLE' }
[2017-05-12 15:32:04.026] [WARN] console - ack!
[2017-05-12 15:33:17.079] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:33:17.090] [INFO] app - Redis client default is ready {}
[2017-05-12 15:33:17.097] [WARN] console - Worker {
  domain: null,
  _events: {},
  _eventsCount: 0,
  _maxListeners: undefined,
  router: 
   doRoute {
     routeMap: { 'rush-concert': [Object], 'register-doctor': [Object] } },
  status: 'IDLE' }
[2017-05-12 15:33:17.106] [WARN] console - ack!
[2017-05-12 15:33:23.415] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:33:23.431] [INFO] app - Redis client default is ready {}
[2017-05-12 15:33:23.441] [WARN] console - Worker {
  domain: null,
  _events: {},
  _eventsCount: 0,
  _maxListeners: undefined,
  router: 
   doRoute {
     routeMap: { 'rush-concert': [Object], 'register-doctor': [Object] } },
  status: 'IDLE' }
[2017-05-12 15:33:23.455] [WARN] console - ack!
[2017-05-12 15:33:47.912] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:33:47.922] [INFO] app - Redis client default is ready {}
[2017-05-12 15:33:47.937] [WARN] console - ack!
[2017-05-12 15:34:27.547] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:34:27.557] [INFO] app - Redis client default is ready {}
[2017-05-12 15:34:27.570] [WARN] console - ack!
[2017-05-12 15:34:38.839] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:34:38.849] [INFO] app - Redis client default is ready {}
[2017-05-12 15:34:38.862] [WARN] console - ack!
[2017-05-12 15:35:12.446] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:35:12.456] [INFO] app - Redis client default is ready {}
[2017-05-12 15:35:12.463] [WARN] console - RedisClient {
  domain: null,
  _events: 
   { newListener: [Function],
     connect: [Function],
     ready: [Function],
     reconnecting: [Function],
     error: [ [Function], [Function: errorHandler] ],
     end: [Function] },
  _eventsCount: 6,
  _maxListeners: undefined,
  address: '127.0.0.1:6379',
  connection_options: { port: 6379, host: '127.0.0.1', family: 4 },
  connection_id: 0,
  connected: true,
  ready: true,
  should_buffer: false,
  max_attempts: 0,
  command_queue: { [String: ''] '0': undefined, _capacity: 16, _length: 0, _front: 1 },
  offline_queue: { [String: ''] _capacity: 16, _length: 0, _front: 0 },
  pipeline_queue: { [String: ''] _capacity: 16, _length: 0, _front: 0 },
  connect_timeout: 3600000,
  enable_offline_queue: true,
  retry_max_delay: null,
  retry_timer: null,
  retry_totaltime: 0,
  retry_delay: 200,
  retry_backoff: 1.7,
  attempts: 1,
  pub_sub_mode: 0,
  subscription_set: {},
  monitoring: false,
  message_buffers: false,
  closing: false,
  server_info: 
   { redis_version: '3.2.8',
     redis_git_sha1: '00000000',
     redis_git_dirty: '0',
     redis_build_id: 'ae7e7d2604b97c53',
     redis_mode: 'standalone',
     os: 'Darwin 15.0.0 x86_64',
     arch_bits: '64',
     multiplexing_api: 'kqueue',
     gcc_version: '4.2.1',
     process_id: '96159',
     run_id: 'ebe29182b7fe6e47163ac97dca7db95076a825ff',
     tcp_port: '6379',
     uptime_in_seconds: '700365',
     uptime_in_days: '8',
     hz: '10',
     lru_clock: '1402288',
     executable: '/usr/local/redis/./bin/redis-server',
     config_file: '/usr/local/redis/./etc/redis.conf',
     connected_clients: '1',
     client_longest_output_list: '0',
     client_biggest_input_buf: '0',
     blocked_clients: '0',
     used_memory: '1250640',
     used_memory_human: '1.19M',
     used_memory_rss: '618496',
     used_memory_rss_human: '604.00K',
     used_memory_peak: '1318496',
     used_memory_peak_human: '1.26M',
     total_system_memory: '8589934592',
     total_system_memory_human: '8.00G',
     used_memory_lua: '37888',
     used_memory_lua_human: '37.00K',
     maxmemory: '0',
     maxmemory_human: '0B',
     maxmemory_policy: 'noeviction',
     mem_fragmentation_ratio: '0.49',
     mem_allocator: 'libc',
     loading: '0',
     rdb_changes_since_last_save: '0',
     rdb_bgsave_in_progress: '0',
     rdb_last_save_time: '1493968832',
     rdb_last_bgsave_status: 'ok',
     rdb_last_bgsave_time_sec: '0',
     rdb_current_bgsave_time_sec: '-1',
     aof_enabled: '0',
     aof_rewrite_in_progress: '0',
     aof_rewrite_scheduled: '0',
     aof_last_rewrite_time_sec: '-1',
     aof_current_rewrite_time_sec: '-1',
     aof_last_bgrewrite_status: 'ok',
     aof_last_write_status: 'ok',
     total_connections_received: '739',
     total_commands_processed: '962',
     instantaneous_ops_per_sec: '0',
     total_net_input_bytes: '835082',
     total_net_output_bytes: '21918844',
     instantaneous_input_kbps: '0.00',
     instantaneous_output_kbps: '0.00',
     rejected_connections: '0',
     sync_full: '0',
     sync_partial_ok: '0',
     sync_partial_err: '0',
     expired_keys: '0',
     evicted_keys: '0',
     keyspace_hits: '94',
     keyspace_misses: '9',
     pubsub_channels: '0',
     pubsub_patterns: '0',
     latest_fork_usec: '477',
     migrate_cached_sockets: '0',
     role: 'master',
     connected_slaves: '0',
     master_repl_offset: '0',
     repl_backlog_active: '0',
     repl_backlog_size: '1048576',
     repl_backlog_first_byte_offset: '0',
     repl_backlog_histlen: '0',
     used_cpu_sys: '101.74',
     used_cpu_user: '59.08',
     used_cpu_sys_children: '0.04',
     used_cpu_user_children: '0.04',
     cluster_enabled: '0',
     db0: { avg_ttl: 0, expires: 0, keys: 9 },
     db2: { avg_ttl: 0, expires: 0, keys: 1 },
     versions: [ 3, 2, 8 ] },
  auth_pass: undefined,
  selected_db: undefined,
  old_state: null,
  fire_strings: true,
  pipeline: false,
  sub_commands_left: 0,
  times_connected: 1,
  buffers: false,
  options: 
   { port: 6379,
     host: '127.0.0.1',
     socket_nodelay: true,
     socket_keepalive: true,
     return_buffers: false,
     detect_buffers: false },
  reply: 'ON',
  reply_parser: 
   JavascriptRedisParser {
     optionReturnBuffers: false,
     optionStringNumbers: false,
     returnError: [Function: returnError],
     returnFatalError: [Function: returnFatalError],
     returnReply: [Function: returnReply],
     name: 'javascript',
     offset: 2226,
     buffer: null,
     bigStrSize: 0,
     bigOffset: 0,
     totalChunkSize: 0,
     bufferCache: [],
     arrayCache: [],
     arrayPos: [] },
  stream: 
   Socket {
     connecting: false,
     _hadError: false,
     _handle: 
      TCP {
        bytesRead: 2226,
        _externalStream: {},
        fd: 14,
        reading: true,
        owner: [Circular],
        onread: [Function: onread],
        onconnection: null,
        writeQueueSize: 0 },
     _parent: null,
     _host: null,
     _readableState: 
      ReadableState {
        objectMode: false,
        highWaterMark: 16384,
        buffer: [Object],
        length: 0,
        pipes: null,
        pipesCount: 0,
        flowing: true,
        ended: false,
        endEmitted: false,
        reading: true,
        sync: false,
        needReadable: true,
        emittedReadable: false,
        readableListening: false,
        resumeScheduled: false,
        defaultEncoding: 'utf8',
        ranOut: false,
        awaitDrain: 0,
        readingMore: false,
        decoder: null,
        encoding: null },
     readable: true,
     domain: null,
     _events: 
      { end: [Object],
        finish: [Function: onSocketFinish],
        _socketEnd: [Function: onSocketEnd],
        data: [Function],
        error: [Function],
        clientError: [Function],
        close: [Object],
        drain: [Function] },
     _eventsCount: 8,
     _maxListeners: undefined,
     _writableState: 
      WritableState {
        objectMode: false,
        highWaterMark: 16384,
        needDrain: false,
        ending: false,
        ended: false,
        finished: false,
        decodeStrings: false,
        defaultEncoding: 'utf8',
        length: 0,
        writing: false,
        corked: 0,
        sync: false,
        bufferProcessing: false,
        onwrite: [Function: bound onwrite],
        writecb: null,
        writelen: 0,
        bufferedRequest: null,
        lastBufferedRequest: null,
        pendingcb: 0,
        prefinished: false,
        errorEmitted: false,
        bufferedRequestCount: 0,
        corkedRequestsFree: [Object] },
     writable: true,
     allowHalfOpen: false,
     destroyed: false,
     _bytesDispatched: 14,
     _sockname: null,
     _pendingData: null,
     _pendingEncoding: '',
     server: null,
     _server: null,
     read: [Function],
     _consuming: true,
     _idleNext: null,
     _idlePrev: null,
     _idleTimeout: -1 },
  emitted_end: false,
  cork: [Function],
  uncork: [Function] }
[2017-05-12 15:35:12.480] [WARN] console - ack!
[2017-05-12 15:35:26.897] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:35:26.908] [INFO] app - Redis client default is ready {}
[2017-05-12 15:35:26.924] [WARN] console - ack!
[2017-05-12 15:36:12.589] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:36:12.595] [INFO] app - Redis client default is ready {}
[2017-05-12 15:36:12.601] [WARN] console - { subdomainOffset: 2, proxy: false, env: 'development' }
[2017-05-12 15:36:12.610] [WARN] console - ack!
[2017-05-12 15:36:23.568] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:36:23.578] [INFO] app - Redis client default is ready {}
[2017-05-12 15:36:23.585] [WARN] console - RedisClient {
  domain: null,
  _events: 
   { newListener: [Function],
     connect: [Function],
     ready: [Function],
     reconnecting: [Function],
     error: [ [Function], [Function: errorHandler] ],
     end: [Function] },
  _eventsCount: 6,
  _maxListeners: undefined,
  address: '127.0.0.1:6379',
  connection_options: { port: 6379, host: '127.0.0.1', family: 4 },
  connection_id: 0,
  connected: true,
  ready: true,
  should_buffer: false,
  max_attempts: 0,
  command_queue: { [String: ''] '0': undefined, _capacity: 16, _length: 0, _front: 1 },
  offline_queue: { [String: ''] _capacity: 16, _length: 0, _front: 0 },
  pipeline_queue: { [String: ''] _capacity: 16, _length: 0, _front: 0 },
  connect_timeout: 3600000,
  enable_offline_queue: true,
  retry_max_delay: null,
  retry_timer: null,
  retry_totaltime: 0,
  retry_delay: 200,
  retry_backoff: 1.7,
  attempts: 1,
  pub_sub_mode: 0,
  subscription_set: {},
  monitoring: false,
  message_buffers: false,
  closing: false,
  server_info: 
   { redis_version: '3.2.8',
     redis_git_sha1: '00000000',
     redis_git_dirty: '0',
     redis_build_id: 'ae7e7d2604b97c53',
     redis_mode: 'standalone',
     os: 'Darwin 15.0.0 x86_64',
     arch_bits: '64',
     multiplexing_api: 'kqueue',
     gcc_version: '4.2.1',
     process_id: '96159',
     run_id: 'ebe29182b7fe6e47163ac97dca7db95076a825ff',
     tcp_port: '6379',
     uptime_in_seconds: '700436',
     uptime_in_days: '8',
     hz: '10',
     lru_clock: '1402359',
     executable: '/usr/local/redis/./bin/redis-server',
     config_file: '/usr/local/redis/./etc/redis.conf',
     connected_clients: '1',
     client_longest_output_list: '0',
     client_biggest_input_buf: '0',
     blocked_clients: '0',
     used_memory: '1250640',
     used_memory_human: '1.19M',
     used_memory_rss: '638976',
     used_memory_rss_human: '624.00K',
     used_memory_peak: '1318496',
     used_memory_peak_human: '1.26M',
     total_system_memory: '8589934592',
     total_system_memory_human: '8.00G',
     used_memory_lua: '37888',
     used_memory_lua_human: '37.00K',
     maxmemory: '0',
     maxmemory_human: '0B',
     maxmemory_policy: 'noeviction',
     mem_fragmentation_ratio: '0.51',
     mem_allocator: 'libc',
     loading: '0',
     rdb_changes_since_last_save: '0',
     rdb_bgsave_in_progress: '0',
     rdb_last_save_time: '1493968832',
     rdb_last_bgsave_status: 'ok',
     rdb_last_bgsave_time_sec: '0',
     rdb_current_bgsave_time_sec: '-1',
     aof_enabled: '0',
     aof_rewrite_in_progress: '0',
     aof_rewrite_scheduled: '0',
     aof_last_rewrite_time_sec: '-1',
     aof_current_rewrite_time_sec: '-1',
     aof_last_bgrewrite_status: 'ok',
     aof_last_write_status: 'ok',
     total_connections_received: '742',
     total_commands_processed: '965',
     instantaneous_ops_per_sec: '0',
     total_net_input_bytes: '835124',
     total_net_output_bytes: '21925522',
     instantaneous_input_kbps: '0.00',
     instantaneous_output_kbps: '0.00',
     rejected_connections: '0',
     sync_full: '0',
     sync_partial_ok: '0',
     sync_partial_err: '0',
     expired_keys: '0',
     evicted_keys: '0',
     keyspace_hits: '94',
     keyspace_misses: '9',
     pubsub_channels: '0',
     pubsub_patterns: '0',
     latest_fork_usec: '477',
     migrate_cached_sockets: '0',
     role: 'master',
     connected_slaves: '0',
     master_repl_offset: '0',
     repl_backlog_active: '0',
     repl_backlog_size: '1048576',
     repl_backlog_first_byte_offset: '0',
     repl_backlog_histlen: '0',
     used_cpu_sys: '101.76',
     used_cpu_user: '59.10',
     used_cpu_sys_children: '0.04',
     used_cpu_user_children: '0.04',
     cluster_enabled: '0',
     db0: { avg_ttl: 0, expires: 0, keys: 9 },
     db2: { avg_ttl: 0, expires: 0, keys: 1 },
     versions: [ 3, 2, 8 ] },
  auth_pass: undefined,
  selected_db: undefined,
  old_state: null,
  fire_strings: true,
  pipeline: false,
  sub_commands_left: 0,
  times_connected: 1,
  buffers: false,
  options: 
   { port: 6379,
     host: '127.0.0.1',
     socket_nodelay: true,
     socket_keepalive: true,
     return_buffers: false,
     detect_buffers: false },
  reply: 'ON',
  reply_parser: 
   JavascriptRedisParser {
     optionReturnBuffers: false,
     optionStringNumbers: false,
     returnError: [Function: returnError],
     returnFatalError: [Function: returnFatalError],
     returnReply: [Function: returnReply],
     name: 'javascript',
     offset: 2226,
     buffer: null,
     bigStrSize: 0,
     bigOffset: 0,
     totalChunkSize: 0,
     bufferCache: [],
     arrayCache: [],
     arrayPos: [] },
  stream: 
   Socket {
     connecting: false,
     _hadError: false,
     _handle: 
      TCP {
        bytesRead: 2226,
        _externalStream: {},
        fd: 14,
        reading: true,
        owner: [Circular],
        onread: [Function: onread],
        onconnection: null,
        writeQueueSize: 0 },
     _parent: null,
     _host: null,
     _readableState: 
      ReadableState {
        objectMode: false,
        highWaterMark: 16384,
        buffer: [Object],
        length: 0,
        pipes: null,
        pipesCount: 0,
        flowing: true,
        ended: false,
        endEmitted: false,
        reading: true,
        sync: false,
        needReadable: true,
        emittedReadable: false,
        readableListening: false,
        resumeScheduled: false,
        defaultEncoding: 'utf8',
        ranOut: false,
        awaitDrain: 0,
        readingMore: true,
        decoder: null,
        encoding: null },
     readable: true,
     domain: null,
     _events: 
      { end: [Object],
        finish: [Function: onSocketFinish],
        _socketEnd: [Function: onSocketEnd],
        data: [Function],
        error: [Function],
        clientError: [Function],
        close: [Object],
        drain: [Function] },
     _eventsCount: 8,
     _maxListeners: undefined,
     _writableState: 
      WritableState {
        objectMode: false,
        highWaterMark: 16384,
        needDrain: false,
        ending: false,
        ended: false,
        finished: false,
        decodeStrings: false,
        defaultEncoding: 'utf8',
        length: 0,
        writing: false,
        corked: 0,
        sync: false,
        bufferProcessing: false,
        onwrite: [Function: bound onwrite],
        writecb: null,
        writelen: 0,
        bufferedRequest: null,
        lastBufferedRequest: null,
        pendingcb: 0,
        prefinished: false,
        errorEmitted: false,
        bufferedRequestCount: 0,
        corkedRequestsFree: [Object] },
     writable: true,
     allowHalfOpen: false,
     destroyed: false,
     _bytesDispatched: 14,
     _sockname: null,
     _pendingData: null,
     _pendingEncoding: '',
     server: null,
     _server: null,
     read: [Function],
     _consuming: true,
     _idleNext: null,
     _idlePrev: null,
     _idleTimeout: -1 },
  emitted_end: false,
  cork: [Function],
  uncork: [Function] }
[2017-05-12 15:36:23.605] [WARN] console - ack!
[2017-05-12 15:41:24.914] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:41:24.926] [INFO] app - Redis client default is ready {}
[2017-05-12 15:41:24.938] [WARN] console - RedisClient {
  domain: null,
  _events: 
   { newListener: [Function],
     connect: [Function],
     ready: [Function],
     reconnecting: [Function],
     error: [ [Function], [Function: errorHandler] ],
     end: [Function] },
  _eventsCount: 6,
  _maxListeners: undefined,
  address: '127.0.0.1:6379',
  connection_options: { port: 6379, host: '127.0.0.1', family: 4 },
  connection_id: 0,
  connected: true,
  ready: true,
  should_buffer: false,
  max_attempts: 0,
  command_queue: { [String: ''] '0': undefined, _capacity: 16, _length: 0, _front: 1 },
  offline_queue: { [String: ''] _capacity: 16, _length: 0, _front: 0 },
  pipeline_queue: { [String: ''] _capacity: 16, _length: 0, _front: 0 },
  connect_timeout: 3600000,
  enable_offline_queue: true,
  retry_max_delay: null,
  retry_timer: null,
  retry_totaltime: 0,
  retry_delay: 200,
  retry_backoff: 1.7,
  attempts: 1,
  pub_sub_mode: 0,
  subscription_set: {},
  monitoring: false,
  message_buffers: false,
  closing: false,
  server_info: 
   { redis_version: '3.2.8',
     redis_git_sha1: '00000000',
     redis_git_dirty: '0',
     redis_build_id: 'ae7e7d2604b97c53',
     redis_mode: 'standalone',
     os: 'Darwin 15.0.0 x86_64',
     arch_bits: '64',
     multiplexing_api: 'kqueue',
     gcc_version: '4.2.1',
     process_id: '96159',
     run_id: 'ebe29182b7fe6e47163ac97dca7db95076a825ff',
     tcp_port: '6379',
     uptime_in_seconds: '700737',
     uptime_in_days: '8',
     hz: '10',
     lru_clock: '1402660',
     executable: '/usr/local/redis/./bin/redis-server',
     config_file: '/usr/local/redis/./etc/redis.conf',
     connected_clients: '1',
     client_longest_output_list: '0',
     client_biggest_input_buf: '0',
     blocked_clients: '0',
     used_memory: '1250640',
     used_memory_human: '1.19M',
     used_memory_rss: '647168',
     used_memory_rss_human: '632.00K',
     used_memory_peak: '1318496',
     used_memory_peak_human: '1.26M',
     total_system_memory: '8589934592',
     total_system_memory_human: '8.00G',
     used_memory_lua: '37888',
     used_memory_lua_human: '37.00K',
     maxmemory: '0',
     maxmemory_human: '0B',
     maxmemory_policy: 'noeviction',
     mem_fragmentation_ratio: '0.52',
     mem_allocator: 'libc',
     loading: '0',
     rdb_changes_since_last_save: '0',
     rdb_bgsave_in_progress: '0',
     rdb_last_save_time: '1493968832',
     rdb_last_bgsave_status: 'ok',
     rdb_last_bgsave_time_sec: '0',
     rdb_current_bgsave_time_sec: '-1',
     aof_enabled: '0',
     aof_rewrite_in_progress: '0',
     aof_rewrite_scheduled: '0',
     aof_last_rewrite_time_sec: '-1',
     aof_current_rewrite_time_sec: '-1',
     aof_last_bgrewrite_status: 'ok',
     aof_last_write_status: 'ok',
     total_connections_received: '743',
     total_commands_processed: '966',
     instantaneous_ops_per_sec: '0',
     total_net_input_bytes: '835138',
     total_net_output_bytes: '21927748',
     instantaneous_input_kbps: '0.00',
     instantaneous_output_kbps: '0.00',
     rejected_connections: '0',
     sync_full: '0',
     sync_partial_ok: '0',
     sync_partial_err: '0',
     expired_keys: '0',
     evicted_keys: '0',
     keyspace_hits: '94',
     keyspace_misses: '9',
     pubsub_channels: '0',
     pubsub_patterns: '0',
     latest_fork_usec: '477',
     migrate_cached_sockets: '0',
     role: 'master',
     connected_slaves: '0',
     master_repl_offset: '0',
     repl_backlog_active: '0',
     repl_backlog_size: '1048576',
     repl_backlog_first_byte_offset: '0',
     repl_backlog_histlen: '0',
     used_cpu_sys: '101.85',
     used_cpu_user: '59.15',
     used_cpu_sys_children: '0.04',
     used_cpu_user_children: '0.04',
     cluster_enabled: '0',
     db0: { avg_ttl: 0, expires: 0, keys: 9 },
     db2: { avg_ttl: 0, expires: 0, keys: 1 },
     versions: [ 3, 2, 8 ] },
  auth_pass: undefined,
  selected_db: undefined,
  old_state: null,
  fire_strings: true,
  pipeline: false,
  sub_commands_left: 0,
  times_connected: 1,
  buffers: false,
  options: 
   { port: 6379,
     host: '127.0.0.1',
     socket_nodelay: true,
     socket_keepalive: true,
     return_buffers: false,
     detect_buffers: false },
  reply: 'ON',
  reply_parser: 
   JavascriptRedisParser {
     optionReturnBuffers: false,
     optionStringNumbers: false,
     returnError: [Function: returnError],
     returnFatalError: [Function: returnFatalError],
     returnReply: [Function: returnReply],
     name: 'javascript',
     offset: 2226,
     buffer: null,
     bigStrSize: 0,
     bigOffset: 0,
     totalChunkSize: 0,
     bufferCache: [],
     arrayCache: [],
     arrayPos: [] },
  stream: 
   Socket {
     connecting: false,
     _hadError: false,
     _handle: 
      TCP {
        bytesRead: 2226,
        _externalStream: {},
        fd: 14,
        reading: true,
        owner: [Circular],
        onread: [Function: onread],
        onconnection: null,
        writeQueueSize: 0 },
     _parent: null,
     _host: null,
     _readableState: 
      ReadableState {
        objectMode: false,
        highWaterMark: 16384,
        buffer: [Object],
        length: 0,
        pipes: null,
        pipesCount: 0,
        flowing: true,
        ended: false,
        endEmitted: false,
        reading: true,
        sync: false,
        needReadable: true,
        emittedReadable: false,
        readableListening: false,
        resumeScheduled: false,
        defaultEncoding: 'utf8',
        ranOut: false,
        awaitDrain: 0,
        readingMore: true,
        decoder: null,
        encoding: null },
     readable: true,
     domain: null,
     _events: 
      { end: [Object],
        finish: [Function: onSocketFinish],
        _socketEnd: [Function: onSocketEnd],
        data: [Function],
        error: [Function],
        clientError: [Function],
        close: [Object],
        drain: [Function] },
     _eventsCount: 8,
     _maxListeners: undefined,
     _writableState: 
      WritableState {
        objectMode: false,
        highWaterMark: 16384,
        needDrain: false,
        ending: false,
        ended: false,
        finished: false,
        decodeStrings: false,
        defaultEncoding: 'utf8',
        length: 0,
        writing: false,
        corked: 0,
        sync: false,
        bufferProcessing: false,
        onwrite: [Function: bound onwrite],
        writecb: null,
        writelen: 0,
        bufferedRequest: null,
        lastBufferedRequest: null,
        pendingcb: 0,
        prefinished: false,
        errorEmitted: false,
        bufferedRequestCount: 0,
        corkedRequestsFree: [Object] },
     writable: true,
     allowHalfOpen: false,
     destroyed: false,
     _bytesDispatched: 14,
     _sockname: null,
     _pendingData: null,
     _pendingEncoding: '',
     server: null,
     _server: null,
     read: [Function],
     _consuming: true,
     _idleNext: null,
     _idlePrev: null,
     _idleTimeout: -1 },
  emitted_end: false,
  cork: [Function],
  uncork: [Function] }
[2017-05-12 15:41:24.955] [WARN] console - ack!
[2017-05-12 15:47:16.552] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:47:16.561] [INFO] app - Redis client default is ready {}
[2017-05-12 15:47:16.575] [WARN] console - ack!
[2017-05-12 15:48:58.647] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:48:58.656] [INFO] app - Redis client default is ready {}
[2017-05-12 15:48:58.676] [WARN] console - ack!
[2017-05-12 15:49:18.420] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:49:18.426] [INFO] app - Redis client default is ready {}
[2017-05-12 15:49:18.443] [WARN] console - ack!
[2017-05-12 15:50:18.521] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:50:18.546] [INFO] app - Redis client default is ready {}
[2017-05-12 15:50:18.571] [WARN] console - ack!
[2017-05-12 15:50:47.706] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:50:47.716] [INFO] app - Redis client default is ready {}
[2017-05-12 15:50:47.731] [WARN] console - ack!
[2017-05-12 15:51:18.964] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:51:18.975] [INFO] app - Redis client default is ready {}
[2017-05-12 15:51:18.981] [WARN] console - undefined
[2017-05-12 15:51:18.990] [WARN] console - ack!
[2017-05-12 15:51:43.333] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:51:43.345] [INFO] app - Redis client default is ready {}
[2017-05-12 15:51:43.363] [ERROR] console - (node:49844) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): TypeError: Cannot read property 'body' of undefined
[2017-05-12 15:51:43.363] [ERROR] console - (node:49844) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
[2017-05-12 15:51:56.055] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:51:56.066] [INFO] app - Redis client default is ready {}
[2017-05-12 15:51:56.074] [WARN] console - { intention: 'register-doctor',
  date: '2017-5-12 20:10',
  telephone: '15210383276',
  username: 'leekangtaqi',
  orderId: 1111 }
[2017-05-12 15:51:56.083] [WARN] console - ack!
[2017-05-12 15:52:01.421] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:52:01.434] [INFO] app - Redis client default is ready {}
[2017-05-12 15:52:01.440] [WARN] console - { intention: 'register-doctor',
  date: '2017-5-12 20:10',
  telephone: '15210383276',
  username: 'leekangtaqi',
  orderId: 1111 }
[2017-05-12 15:52:01.443] [WARN] console - { intention: 'register-doctor',
  date: '2017-5-12 20:10',
  telephone: '15210383276',
  username: 'leekangtaqi',
  orderId: 1111 }
[2017-05-12 15:52:01.452] [WARN] console - ack!
[2017-05-12 15:52:08.640] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:52:08.651] [INFO] app - Redis client default is ready {}
[2017-05-12 15:52:08.659] [WARN] console - { intention: 'register-doctor',
  date: '2017-5-12 20:10',
  telephone: '15210383276',
  username: 'leekangtaqi',
  orderId: 1111 }
[2017-05-12 15:52:08.670] [WARN] console - ack!
[2017-05-12 15:52:12.071] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:52:12.079] [INFO] app - Redis client default is ready {}
[2017-05-12 15:52:12.085] [WARN] console - { intention: 'register-doctor',
  date: '2017-5-12 20:10',
  telephone: '15210383276',
  username: 'leekangtaqi',
  orderId: 1111 }
[2017-05-12 15:52:12.093] [WARN] console - ack!
[2017-05-12 15:52:30.686] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:52:30.696] [INFO] app - Redis client default is ready {}
[2017-05-12 15:52:30.709] [WARN] console - ack!
[2017-05-12 15:53:30.464] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:53:30.470] [INFO] app - Redis client default is ready {}
[2017-05-12 15:53:30.486] [WARN] console - ack!
[2017-05-12 15:53:59.942] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:53:59.952] [INFO] app - Redis client default is ready {}
[2017-05-12 15:53:59.971] [WARN] console - ack!
[2017-05-12 15:55:24.082] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:55:24.094] [INFO] app - Redis client default is ready {}
[2017-05-12 15:55:24.112] [WARN] console - ack!
[2017-05-12 15:55:47.612] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:55:47.622] [INFO] app - Redis client default is ready {}
[2017-05-12 15:55:47.638] [WARN] console - ack!
[2017-05-12 15:56:21.904] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:56:21.915] [INFO] app - Redis client default is ready {}
[2017-05-12 15:56:21.937] [WARN] console - ack!
[2017-05-12 15:56:31.554] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:56:31.567] [INFO] app - Redis client default is ready {}
[2017-05-12 15:56:31.587] [WARN] console - ack!
[2017-05-12 15:57:05.786] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:57:05.796] [INFO] app - Redis client default is ready {}
[2017-05-12 15:57:37.614] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:57:37.625] [INFO] app - Redis client default is ready {}
[2017-05-12 15:57:37.630] [WARN] console - WorkerFactory { capacity: 10, workers: [] }
[2017-05-12 15:58:07.211] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:58:07.221] [INFO] app - Redis client default is ready {}
[2017-05-12 15:58:07.234] [ERROR] console - (node:50351) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 2): ReferenceError: worker is not defined
[2017-05-12 15:58:07.234] [ERROR] console - (node:50351) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
[2017-05-12 15:58:30.369] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:58:30.376] [INFO] app - Redis client default is ready {}
[2017-05-12 15:58:30.388] [ERROR] console - (node:50382) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): ReplyError: ERR wrong number of arguments for 'hmget' command
[2017-05-12 15:58:30.388] [ERROR] console - (node:50382) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
[2017-05-12 15:58:56.150] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:58:56.160] [INFO] app - Redis client default is ready {}
[2017-05-12 15:58:56.168] [WARN] console - { id: '111', status: 'IDLE' }
[2017-05-12 15:59:36.498] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:59:36.505] [INFO] app - Redis client default is ready {}
[2017-05-12 15:59:36.518] [WARN] console - { id: '111', status: 'IDLE' }
[2017-05-12 15:59:36.574] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:59:36.581] [INFO] app - Redis client default is ready {}
[2017-05-12 15:59:47.724] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:59:47.734] [INFO] app - Redis client default is ready {}
[2017-05-12 15:59:53.374] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 15:59:53.384] [INFO] app - Redis client default is ready {}
[2017-05-12 15:59:53.392] [WARN] console - { id: '111', status: 'IDLE' }
[2017-05-12 16:00:58.492] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:00:58.515] [INFO] app - Redis client default is ready {}
[2017-05-12 16:00:58.526] [WARN] console - { id: '111', status: 'IDLE' }
[2017-05-12 16:01:19.109] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:01:19.119] [INFO] app - Redis client default is ready {}
[2017-05-12 16:01:19.128] [WARN] console - { id: '111', status: 'IDLE' }
[2017-05-12 16:01:29.521] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:01:29.532] [INFO] app - Redis client default is ready {}
[2017-05-12 16:01:38.890] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:01:38.901] [INFO] app - Redis client default is ready {}
[2017-05-12 16:01:38.917] [WARN] console - ack!
[2017-05-12 16:01:58.324] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:01:58.336] [INFO] app - Redis client default is ready {}
[2017-05-12 16:01:58.353] [WARN] console - ack!
[2017-05-12 16:03:38.887] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:03:38.894] [INFO] app - Redis client default is ready {}
[2017-05-12 16:03:38.918] [ERROR] console - (node:50799) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 2): TypeError: Cannot set property 'worker' of undefined
[2017-05-12 16:03:38.918] [ERROR] console - (node:50799) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
[2017-05-12 16:03:55.789] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:03:55.801] [INFO] app - Redis client default is ready {}
[2017-05-12 16:03:55.813] [WARN] console - { body: 
   { intention: 'register-doctor',
     date: '2017-5-12 20:10',
     telephone: '15210383276',
     username: 'leekangtaqi',
     orderId: 1111 },
  req: { param: {}, query: {} } }
[2017-05-12 16:03:55.827] [ERROR] console - (node:50826) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 2): TypeError: Cannot set property 'worker' of undefined
[2017-05-12 16:03:55.827] [ERROR] console - (node:50826) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
[2017-05-12 16:04:13.947] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:04:13.955] [INFO] app - Redis client default is ready {}
[2017-05-12 16:04:13.977] [WARN] console - ack!
[2017-05-12 16:04:49.087] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:04:49.096] [INFO] app - Redis client default is ready {}
[2017-05-12 16:04:49.111] [WARN] console - { id: 0,
  target: 
   ChildProcess {
     domain: null,
     _events: { internalMessage: [Function] },
     _eventsCount: 1,
     _maxListeners: undefined,
     _closesNeeded: 2,
     _closesGot: 0,
     connected: true,
     signalCode: null,
     exitCode: null,
     killed: false,
     spawnfile: 'node',
     _handle: Process { owner: [Circular], onexit: [Function], pid: 50895 },
     spawnargs: [ 'node', 'register-doctor.js' ],
     pid: 50895,
     stdin: null,
     stdout: null,
     stderr: null,
     stdio: [ null, null, null, null ],
     channel: 
      Pipe {
        bytesRead: 0,
        _externalStream: {},
        fd: 16,
        writeQueueSize: 0,
        buffering: false,
        onread: [Function],
        sockets: [Object] },
     _channel: [Getter/Setter],
     _handleQueue: null,
     _pendingHandle: null,
     send: [Function],
     _send: [Function],
     disconnect: [Function],
     _disconnect: [Function] } }
[2017-05-12 16:04:49.116] [WARN] console - ack!
[2017-05-12 16:05:13.199] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:05:13.208] [INFO] app - Redis client default is ready {}
[2017-05-12 16:05:13.222] [WARN] console - { id: 
   Worker {
     domain: null,
     _events: {},
     _eventsCount: 0,
     _maxListeners: undefined,
     router: doRoute { routeMap: [Object] },
     status: 'IDLE',
     id: 111,
     order: 1111 },
  target: 
   ChildProcess {
     domain: null,
     _events: { internalMessage: [Function] },
     _eventsCount: 1,
     _maxListeners: undefined,
     _closesNeeded: 2,
     _closesGot: 0,
     connected: true,
     signalCode: null,
     exitCode: null,
     killed: false,
     spawnfile: 'node',
     _handle: Process { owner: [Circular], onexit: [Function], pid: 50927 },
     spawnargs: [ 'node', 'register-doctor.js' ],
     pid: 50927,
     stdin: null,
     stdout: null,
     stderr: null,
     stdio: [ null, null, null, null ],
     channel: 
      Pipe {
        bytesRead: 0,
        _externalStream: {},
        fd: 16,
        writeQueueSize: 0,
        buffering: false,
        onread: [Function],
        sockets: [Object] },
     _channel: [Getter/Setter],
     _handleQueue: null,
     _pendingHandle: null,
     send: [Function],
     _send: [Function],
     disconnect: [Function],
     _disconnect: [Function] } }
[2017-05-12 16:05:13.230] [WARN] console - ack!
[2017-05-12 16:05:16.322] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:05:16.332] [INFO] app - Redis client default is ready {}
[2017-05-12 16:05:16.348] [WARN] console - { worker: 
   Worker {
     domain: null,
     _events: {},
     _eventsCount: 0,
     _maxListeners: undefined,
     router: doRoute { routeMap: [Object] },
     status: 'IDLE',
     id: 111,
     order: 1111 },
  target: 
   ChildProcess {
     domain: null,
     _events: { internalMessage: [Function] },
     _eventsCount: 1,
     _maxListeners: undefined,
     _closesNeeded: 2,
     _closesGot: 0,
     connected: true,
     signalCode: null,
     exitCode: null,
     killed: false,
     spawnfile: 'node',
     _handle: Process { owner: [Circular], onexit: [Function], pid: 50939 },
     spawnargs: [ 'node', 'register-doctor.js' ],
     pid: 50939,
     stdin: null,
     stdout: null,
     stderr: null,
     stdio: [ null, null, null, null ],
     channel: 
      Pipe {
        bytesRead: 0,
        _externalStream: {},
        fd: 16,
        writeQueueSize: 0,
        buffering: false,
        onread: [Function],
        sockets: [Object] },
     _channel: [Getter/Setter],
     _handleQueue: null,
     _pendingHandle: null,
     send: [Function],
     _send: [Function],
     disconnect: [Function],
     _disconnect: [Function] } }
[2017-05-12 16:05:16.354] [WARN] console - ack!
[2017-05-12 16:05:51.535] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:05:51.545] [INFO] app - Redis client default is ready {}
[2017-05-12 16:05:51.561] [WARN] console - undefined
[2017-05-12 16:05:51.563] [WARN] console - ack!
[2017-05-12 16:06:09.386] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:06:09.392] [INFO] app - Redis client default is ready {}
[2017-05-12 16:06:09.407] [WARN] console - Worker {
  domain: null,
  _events: {},
  _eventsCount: 0,
  _maxListeners: undefined,
  router: 
   doRoute {
     routeMap: { 'rush-concert': [Object], 'register-doctor': [Object] } },
  status: 'IDLE',
  id: 111,
  order: 1111 }
[2017-05-12 16:06:09.410] [WARN] console - ack!
[2017-05-12 16:07:33.359] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:07:33.367] [INFO] app - Redis client default is ready {}
[2017-05-12 16:07:33.381] [ERROR] console - (node:51104) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): ReferenceError: worker is not defined
[2017-05-12 16:07:33.381] [ERROR] console - (node:51104) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
[2017-05-12 16:07:33.386] [ERROR] console - (node:51104) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 2): ReplyError: ERR wrong number of arguments for 'hmset' command
[2017-05-12 16:08:07.516] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:08:07.527] [INFO] app - Redis client default is ready {}
[2017-05-12 16:08:07.540] [ERROR] console - (node:51146) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): ReplyError: ERR wrong number of arguments for 'hmset' command
[2017-05-12 16:08:07.540] [ERROR] console - (node:51146) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
[2017-05-12 16:08:44.253] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:08:44.264] [INFO] app - Redis client default is ready {}
[2017-05-12 16:08:44.271] [WARN] console - Promise { { id: 111, status: 'IDLE' } }
[2017-05-12 16:08:44.294] [ERROR] console - (node:51186) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): ReplyError: ERR wrong number of arguments for 'hmset' command
[2017-05-12 16:08:44.294] [ERROR] console - (node:51186) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
[2017-05-12 16:08:58.204] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:08:58.212] [INFO] app - Redis client default is ready {}
[2017-05-12 16:08:58.218] [WARN] console - { id: 111, status: 'IDLE' }
[2017-05-12 16:08:58.228] [WARN] console - Worker {
  domain: null,
  _events: {},
  _eventsCount: 0,
  _maxListeners: undefined,
  router: 
   doRoute {
     routeMap: { 'rush-concert': [Object], 'register-doctor': [Object] } },
  status: 'IDLE',
  id: 111,
  order: 1111 }
[2017-05-12 16:08:58.231] [WARN] console - ack!
[2017-05-12 16:09:13.892] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:09:13.906] [INFO] app - Redis client default is ready {}
[2017-05-12 16:09:13.933] [WARN] console - Worker {
  domain: null,
  _events: {},
  _eventsCount: 0,
  _maxListeners: undefined,
  router: 
   doRoute {
     routeMap: { 'rush-concert': [Object], 'register-doctor': [Object] } },
  status: 'IDLE',
  id: 111,
  order: 1111 }
[2017-05-12 16:09:13.946] [WARN] console - ack!
[2017-05-12 16:09:31.486] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:09:31.496] [INFO] app - Redis client default is ready {}
[2017-05-12 16:09:31.514] [WARN] console - { id: 111, status: 'IDLE' }
[2017-05-12 16:09:31.516] [WARN] console - ack!
[2017-05-12 16:09:44.184] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:09:44.194] [INFO] app - Redis client default is ready {}
[2017-05-12 16:09:44.213] [WARN] console - ack!
[2017-05-12 16:20:48.337] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:20:48.347] [INFO] app - Redis client default is ready {}
[2017-05-12 16:20:48.368] [WARN] console - ack!
[2017-05-12 16:20:52.130] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:20:52.140] [INFO] app - Redis client default is ready {}
[2017-05-12 16:20:52.159] [WARN] console - ack!
[2017-05-12 16:24:32.630] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:24:32.641] [INFO] app - Redis client default is ready {}
[2017-05-12 16:24:32.659] [WARN] console - ack!
[2017-05-12 16:24:35.413] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:24:35.424] [INFO] app - Redis client default is ready {}
[2017-05-12 16:24:35.442] [WARN] console - ack!
[2017-05-12 16:25:20.632] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:25:20.639] [INFO] app - Redis client default is ready {}
[2017-05-12 16:25:20.654] [WARN] console - ack!
[2017-05-12 16:26:08.819] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:26:08.833] [INFO] app - Redis client default is ready {}
[2017-05-12 16:26:08.856] [WARN] console - ack!
[2017-05-12 16:26:28.963] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:26:28.975] [INFO] app - Redis client default is ready {}
[2017-05-12 16:26:28.993] [WARN] console - ack!
[2017-05-12 16:40:59.514] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:40:59.527] [INFO] app - Redis client default is ready {}
[2017-05-12 16:40:59.547] [WARN] console - ack!
[2017-05-12 16:41:59.071] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:41:59.081] [INFO] app - Redis client default is ready {}
[2017-05-12 16:41:59.102] [WARN] console - ack!
[2017-05-12 16:42:07.874] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:42:07.886] [INFO] app - Redis client default is ready {}
[2017-05-12 16:42:07.894] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-12 16:42:07.907] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-12 16:42:07.908] [WARN] console - ack!
[2017-05-12 16:42:28.546] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:42:28.553] [INFO] app - Redis client default is ready {}
[2017-05-12 16:42:28.560] [WARN] console - { id: 111, status: 'IDLE', origin: undefined }
[2017-05-12 16:42:28.562] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-12 16:42:28.571] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-12 16:42:28.572] [WARN] console - ack!
[2017-05-12 16:42:47.477] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:42:47.484] [INFO] app - Redis client default is ready {}
[2017-05-12 16:42:47.490] [WARN] console - { id: 111, status: 'IDLE', origin: undefined }
[2017-05-12 16:42:47.493] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-12 16:42:47.501] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-12 16:42:47.502] [WARN] console - ack!
[2017-05-12 16:43:28.301] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:43:28.309] [INFO] app - Redis client default is ready {}
[2017-05-12 16:43:28.317] [WARN] console - { id: 111, status: 'IDLE', origin: undefined }
[2017-05-12 16:43:28.319] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-12 16:43:28.333] [WARN] console - node_redis: Deprecated: The HMSET command contains a "undefined" argument.
This is converted to a "undefined" string now and will return an error from v.3.0 on.
Please handle this in your code to make sure everything works as you intended it to.
[2017-05-12 16:43:28.334] [WARN] console - ack!
[2017-05-12 16:43:54.503] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:43:54.512] [INFO] app - Redis client default is ready {}
[2017-05-12 16:43:54.518] [WARN] console - { id: 111, status: 'IDLE', origin: 'xxxxx' }
[2017-05-12 16:43:54.533] [WARN] console - ack!
[2017-05-12 16:44:28.158] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:44:28.170] [INFO] app - Redis client default is ready {}
[2017-05-12 16:44:28.177] [WARN] console - { id: 111, status: 'IDLE', origin: 'xxxxx' }
[2017-05-12 16:44:28.188] [WARN] console - ack!
[2017-05-12 16:45:50.820] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:45:50.828] [INFO] app - Redis client default is ready {}
[2017-05-12 16:45:50.835] [WARN] console - { id: 111, status: 'IDLE', origin: 'xxxxx' }
[2017-05-12 16:45:50.850] [WARN] console - ack!
[2017-05-12 16:48:08.007] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:48:08.017] [INFO] app - Redis client default is ready {}
[2017-05-12 16:48:08.025] [WARN] console - { id: 111, status: 'IDLE', origin: 'xxxxx' }
[2017-05-12 16:48:08.037] [WARN] console - ack!
[2017-05-12 16:57:22.787] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:57:22.798] [INFO] app - Redis client default is ready {}
[2017-05-12 16:57:22.814] [WARN] console - { id: 111, status: 'IDLE', origin: 'xxxxx' }
[2017-05-12 16:57:22.831] [WARN] console - ack!
[2017-05-12 16:57:27.402] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:57:27.417] [INFO] app - Redis client default is ready {}
[2017-05-12 16:57:27.430] [WARN] console - { id: 111, status: 'IDLE', origin: 'xxxxx' }
[2017-05-12 16:57:27.469] [WARN] console - ack!
[2017-05-12 16:57:27.619] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:57:27.629] [INFO] app - Redis client default is ready {}
[2017-05-12 16:57:27.689] [INFO] app - Redis client default is connecting to redis://127.0.0.1:6379 {}
[2017-05-12 16:57:27.700] [INFO] app - Redis client default is ready {}
